// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/jhana-app/jhana-app/ent"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/property"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Content() ContentResolver
	ContentEpisode() ContentEpisodeResolver
	ContentProgress() ContentProgressResolver
	Course() CourseResolver
	JournalRecord() JournalRecordResolver
	Lesson() LessonResolver
	LessonAudio() LessonAudioResolver
	LessonTechnique() LessonTechniqueResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Technique() TechniqueResolver
	Unit() UnitResolver
	UnitTechnique() UnitTechniqueResolver
	User() UserResolver
	UserProgress() UserProgressResolver
	ContentEpisodeWhereInput() ContentEpisodeWhereInputResolver
	ContentProgressWhereInput() ContentProgressWhereInputResolver
	ContentWhereInput() ContentWhereInputResolver
	CourseWhereInput() CourseWhereInputResolver
	JournalRecordWhereInput() JournalRecordWhereInputResolver
	LessonAudioWhereInput() LessonAudioWhereInputResolver
	LessonWhereInput() LessonWhereInputResolver
	TechniqueWhereInput() TechniqueWhereInputResolver
	UnitWhereInput() UnitWhereInputResolver
	UserProgressWhereInput() UserProgressWhereInputResolver
	UserWhereInput() UserWhereInputResolver
}

type DirectiveRoot struct {
	HasPermissions func(ctx context.Context, obj interface{}, next graphql.Resolver, permissions []string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Content struct {
		CoverImage    func(childComplexity int) int
		Description   func(childComplexity int) int
		Episodes      func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ContentEpisodeOrder, where *ent.ContentEpisodeWhereInput) int
		EpisodesCount func(childComplexity int) int
		EpisodesList  func(childComplexity int) int
		ID            func(childComplexity int) int
		IconImage     func(childComplexity int) int
		IsHidden      func(childComplexity int) int
		Licence       func(childComplexity int) int
		LicenceURL    func(childComplexity int) int
		Order         func(childComplexity int) int
		SingleEpisode func(childComplexity int) int
		Source        func(childComplexity int) int
		SourceURL     func(childComplexity int) int
		Subtitle      func(childComplexity int) int
		Title         func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	ContentConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ContentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ContentEpisode struct {
		Content     func(childComplexity int) int
		ContentID   func(childComplexity int) int
		Description func(childComplexity int) int
		DownloadURL func(childComplexity int) int
		Duration    func(childComplexity int) int
		FinishedAt  func(childComplexity int) int
		ID          func(childComplexity int) int
		IsHidden    func(childComplexity int) int
		Licence     func(childComplexity int) int
		LicenceURL  func(childComplexity int) int
		Order       func(childComplexity int) int
		Progress    func(childComplexity int) int
		Source      func(childComplexity int) int
		SourceURL   func(childComplexity int) int
		StreamURL   func(childComplexity int) int
		Subtitle    func(childComplexity int) int
		Title       func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	ContentEpisodeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ContentEpisodeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ContentProgress struct {
		Content     func(childComplexity int) int
		ContentID   func(childComplexity int) int
		ContentType func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Episode     func(childComplexity int) int
		EpisodeID   func(childComplexity int) int
		FinishedAt  func(childComplexity int) int
		ID          func(childComplexity int) int
		Progress    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	Course struct {
		Active      func(childComplexity int) int
		Color       func(childComplexity int) int
		CoverImage  func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		IconImage   func(childComplexity int) int
		IsStarted   func(childComplexity int) int
		Order       func(childComplexity int) int
		Title       func(childComplexity int) int
		Units       func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.UnitOrder, where *ent.UnitWhereInput) int
	}

	CourseConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CourseEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DownloadContentEpisodeResult struct {
		Success func(childComplexity int) int
	}

	DownloadContentResult struct {
		Success func(childComplexity int) int
	}

	DownloadLessonResult struct {
		Success func(childComplexity int) int
	}

	DownloadUnitResult struct {
		Success func(childComplexity int) int
	}

	FinishContentEpisodeResult struct {
		Episode     func(childComplexity int) int
		NextEpisode func(childComplexity int) int
	}

	FinishLessonResult struct {
		JournalRecord func(childComplexity int) int
		Lesson        func(childComplexity int) int
		NextLesson    func(childComplexity int) int
	}

	JournalRecord struct {
		CreatedAt func(childComplexity int) int
		DateTime  func(childComplexity int) int
		Duration  func(childComplexity int) int
		ID        func(childComplexity int) int
		Lesson    func(childComplexity int) int
		LessonID  func(childComplexity int) int
		Note      func(childComplexity int) int
		UnitColor func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	JournalRecordConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	JournalRecordEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Lesson struct {
		Audios           func(childComplexity int) int
		CoverImage       func(childComplexity int) int
		Description      func(childComplexity int) int
		FinishedAt       func(childComplexity int) int
		ID               func(childComplexity int) int
		IconImage        func(childComplexity int) int
		IsLast           func(childComplexity int) int
		IsNext           func(childComplexity int) int
		LessonTechniques func(childComplexity int) int
		Order            func(childComplexity int) int
		Progress         func(childComplexity int) int
		Techniques       func(childComplexity int) int
		Title            func(childComplexity int) int
		Type             func(childComplexity int) int
		Unit             func(childComplexity int) int
		UnitID           func(childComplexity int) int
	}

	LessonAudio struct {
		AudioURL func(childComplexity int) int
		Duration func(childComplexity int) int
		ID       func(childComplexity int) int
		Lesson   func(childComplexity int) int
		LessonID func(childComplexity int) int
	}

	LessonConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LessonEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	LessonTechnique struct {
		LessonID    func(childComplexity int) int
		Order       func(childComplexity int) int
		Technique   func(childComplexity int) int
		TechniqueID func(childComplexity int) int
	}

	MeditationsStats struct {
		CurrentStrike      func(childComplexity int) int
		HoursTotal         func(childComplexity int) int
		LastMeditationDate func(childComplexity int) int
		SessionsTotal      func(childComplexity int) int
	}

	Mutation struct {
		CreateJournalRecord         func(childComplexity int, input CreateJournalRecordInput) int
		DeleteJournalRecord         func(childComplexity int, id gqlid.Base64ID) int
		DownloadContent             func(childComplexity int, id gqlid.Base64ID, input DownloadContentInput) int
		DownloadContentEpisode      func(childComplexity int, id gqlid.Base64ID, input DownloadContentEpisodeInput) int
		DownloadLesson              func(childComplexity int, id gqlid.Base64ID, input DownloadLessonInput) int
		DownloadUnit                func(childComplexity int, id gqlid.Base64ID, input DownloadUnitInput) int
		FinishContentEpisode        func(childComplexity int, id gqlid.Base64ID, input FinishContentEpisodeInput) int
		FinishLesson                func(childComplexity int, id gqlid.Base64ID, input FinishLessonInput) int
		RefreshToken                func(childComplexity int, input RefreshTokenInput) int
		ResetContentEpisodeProgress func(childComplexity int, id gqlid.Base64ID, input ResetContentEpisodeProgressInput) int
		ResetContentProgress        func(childComplexity int, id gqlid.Base64ID, input ResetContentProgressInput) int
		ResetLessonProgress         func(childComplexity int, id gqlid.Base64ID, input ResetLessonProgressInput) int
		ResetUnitProgress           func(childComplexity int, id gqlid.Base64ID, input ResetUnitProgressInput) int
		SaveContentEpisodeProgress  func(childComplexity int, id gqlid.Base64ID, input SaveContentEpisodeProgressInput) int
		SaveLessonProgress          func(childComplexity int, id gqlid.Base64ID, input SaveLessonProgressInput) int
		SignInWithEmailAndPassword  func(childComplexity int, input SignInWithEmailAndPasswordInput) int
		SignOut                     func(childComplexity int, input SignOutInput) int
		SignUpWithEmailAndPassword  func(childComplexity int, input SignUpWithEmailAndPasswordInput) int
		UpdateJournalRecord         func(childComplexity int, id gqlid.Base64ID, input UpdateJournalRecordInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		ActiveEpisode    func(childComplexity int, contentID gqlid.Base64ID) int
		ActiveEpisodes   func(childComplexity int) int
		ActiveLessons    func(childComplexity int) int
		ContentEpisodes  func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ContentEpisodeOrder, where *ent.ContentEpisodeWhereInput) int
		Contents         func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ContentOrder, where *ent.ContentWhereInput) int
		Courses          func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.CourseOrder, where *ent.CourseWhereInput) int
		JournalRecords   func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.JournalRecordOrder, where *ent.JournalRecordWhereInput) int
		Lessons          func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.LessonOrder, where *ent.LessonWhereInput) int
		Me               func(childComplexity int) int
		MeditationsStats func(childComplexity int, input MeditationsStatsInput) int
		Node             func(childComplexity int, id gqlid.Base64ID) int
		Nodes            func(childComplexity int, ids []*gqlid.Base64ID) int
		Techniques       func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.TechniqueOrder, where *ent.TechniqueWhereInput) int
		Units            func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.UnitOrder, where *ent.UnitWhereInput) int
		WeekStats        func(childComplexity int) int
	}

	RefreshTokenResult struct {
		AccessToken  func(childComplexity int) int
		RefreshToken func(childComplexity int) int
	}

	SignInWithEmailAndPasswordResult struct {
		AccessToken  func(childComplexity int) int
		RefreshToken func(childComplexity int) int
		User         func(childComplexity int) int
	}

	SignUpWithEmailAndPasswordResult struct {
		AccessToken  func(childComplexity int) int
		RefreshToken func(childComplexity int) int
		User         func(childComplexity int) int
	}

	Technique struct {
		CoverImage  func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		IconImage   func(childComplexity int) int
		Lessons     func(childComplexity int) int
		Order       func(childComplexity int) int
		Subtitle    func(childComplexity int) int
		Techniques  func(childComplexity int) int
		Title       func(childComplexity int) int
		Unit        func(childComplexity int) int
		UnitID      func(childComplexity int) int
	}

	TechniqueConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TechniqueEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Unit struct {
		Color            func(childComplexity int) int
		Course           func(childComplexity int) int
		CourseID         func(childComplexity int) int
		CoverImage       func(childComplexity int) int
		Days             func(childComplexity int) int
		Description      func(childComplexity int) int
		ID               func(childComplexity int) int
		IconImage        func(childComplexity int) int
		IsActive         func(childComplexity int) int
		Lessons          func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.LessonOrder, where *ent.LessonWhereInput) int
		LessonsCompleted func(childComplexity int) int
		LessonsTotal     func(childComplexity int) int
		Mastering        func(childComplexity int) int
		NextUnit         func(childComplexity int) int
		Order            func(childComplexity int) int
		Subtitle         func(childComplexity int) int
		Techniques       func(childComplexity int) int
		Title            func(childComplexity int) int
		UnitTechniques   func(childComplexity int) int
	}

	UnitConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UnitEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UnitTechnique struct {
		Position    func(childComplexity int) int
		Technique   func(childComplexity int) int
		TechniqueID func(childComplexity int) int
		UnitID      func(childComplexity int) int
	}

	User struct {
		AuthMethod    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DisplayName   func(childComplexity int) int
		Email         func(childComplexity int) int
		EmailVerified func(childComplexity int) int
		FirebaseUid   func(childComplexity int) int
		ID            func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	UserProgress struct {
		Course     func(childComplexity int) int
		CourseID   func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		FinishedAt func(childComplexity int) int
		ID         func(childComplexity int) int
		IsLast     func(childComplexity int) int
		IsNext     func(childComplexity int) int
		Lesson     func(childComplexity int) int
		LessonID   func(childComplexity int) int
		LessonType func(childComplexity int) int
		Progress   func(childComplexity int) int
		Unit       func(childComplexity int) int
		UnitID     func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		User       func(childComplexity int) int
		UserID     func(childComplexity int) int
	}
}

type ContentResolver interface {
	ID(ctx context.Context, obj *ent.Content) (*gqlid.Base64ID, error)

	SingleEpisode(ctx context.Context, obj *ent.Content) (*ent.ContentEpisode, error)
	EpisodesList(ctx context.Context, obj *ent.Content) ([]*ent.ContentEpisode, error)
}
type ContentEpisodeResolver interface {
	ID(ctx context.Context, obj *ent.ContentEpisode) (*gqlid.Base64ID, error)
	ContentID(ctx context.Context, obj *ent.ContentEpisode) (*gqlid.Base64ID, error)

	Progress(ctx context.Context, obj *ent.ContentEpisode) (int, error)
	FinishedAt(ctx context.Context, obj *ent.ContentEpisode) (*time.Time, error)
}
type ContentProgressResolver interface {
	ID(ctx context.Context, obj *ent.ContentProgress) (*gqlid.Base64ID, error)
	UserID(ctx context.Context, obj *ent.ContentProgress) (*gqlid.Base64ID, error)
	ContentID(ctx context.Context, obj *ent.ContentProgress) (*gqlid.Base64ID, error)
	EpisodeID(ctx context.Context, obj *ent.ContentProgress) (*gqlid.Base64ID, error)
}
type CourseResolver interface {
	ID(ctx context.Context, obj *ent.Course) (*gqlid.Base64ID, error)

	IsStarted(ctx context.Context, obj *ent.Course) (bool, error)
}
type JournalRecordResolver interface {
	ID(ctx context.Context, obj *ent.JournalRecord) (*gqlid.Base64ID, error)
	UserID(ctx context.Context, obj *ent.JournalRecord) (*gqlid.Base64ID, error)
	LessonID(ctx context.Context, obj *ent.JournalRecord) (*gqlid.Base64ID, error)

	UnitColor(ctx context.Context, obj *ent.JournalRecord) (*string, error)
}
type LessonResolver interface {
	ID(ctx context.Context, obj *ent.Lesson) (*gqlid.Base64ID, error)
	UnitID(ctx context.Context, obj *ent.Lesson) (*gqlid.Base64ID, error)

	IsLast(ctx context.Context, obj *ent.Lesson) (bool, error)
	IsNext(ctx context.Context, obj *ent.Lesson) (bool, error)
	Progress(ctx context.Context, obj *ent.Lesson) (int, error)
	FinishedAt(ctx context.Context, obj *ent.Lesson) (*time.Time, error)
	Techniques(ctx context.Context, obj *ent.Lesson) ([]*ent.Technique, error)
	LessonTechniques(ctx context.Context, obj *ent.Lesson) ([]*ent.LessonTechnique, error)
	Audios(ctx context.Context, obj *ent.Lesson) ([]*ent.LessonAudio, error)
}
type LessonAudioResolver interface {
	ID(ctx context.Context, obj *ent.LessonAudio) (*gqlid.Base64ID, error)
	LessonID(ctx context.Context, obj *ent.LessonAudio) (*gqlid.Base64ID, error)
}
type LessonTechniqueResolver interface {
	LessonID(ctx context.Context, obj *ent.LessonTechnique) (*gqlid.Base64ID, error)
	TechniqueID(ctx context.Context, obj *ent.LessonTechnique) (*gqlid.Base64ID, error)
	Technique(ctx context.Context, obj *ent.LessonTechnique) (*ent.Technique, error)
}
type MutationResolver interface {
	SignInWithEmailAndPassword(ctx context.Context, input SignInWithEmailAndPasswordInput) (*SignInWithEmailAndPasswordResult, error)
	SignUpWithEmailAndPassword(ctx context.Context, input SignUpWithEmailAndPasswordInput) (*SignUpWithEmailAndPasswordResult, error)
	RefreshToken(ctx context.Context, input RefreshTokenInput) (*RefreshTokenResult, error)
	SignOut(ctx context.Context, input SignOutInput) (bool, error)
	DownloadUnit(ctx context.Context, id gqlid.Base64ID, input DownloadUnitInput) (*DownloadUnitResult, error)
	ResetUnitProgress(ctx context.Context, id gqlid.Base64ID, input ResetUnitProgressInput) (*ent.Unit, error)
	SaveLessonProgress(ctx context.Context, id gqlid.Base64ID, input SaveLessonProgressInput) (bool, error)
	DownloadLesson(ctx context.Context, id gqlid.Base64ID, input DownloadLessonInput) (*DownloadLessonResult, error)
	ResetLessonProgress(ctx context.Context, id gqlid.Base64ID, input ResetLessonProgressInput) (*ent.Lesson, error)
	FinishLesson(ctx context.Context, id gqlid.Base64ID, input FinishLessonInput) (*FinishLessonResult, error)
	DownloadContent(ctx context.Context, id gqlid.Base64ID, input DownloadContentInput) (*DownloadContentResult, error)
	ResetContentProgress(ctx context.Context, id gqlid.Base64ID, input ResetContentProgressInput) (*ent.Content, error)
	SaveContentEpisodeProgress(ctx context.Context, id gqlid.Base64ID, input SaveContentEpisodeProgressInput) (bool, error)
	DownloadContentEpisode(ctx context.Context, id gqlid.Base64ID, input DownloadContentEpisodeInput) (*DownloadContentEpisodeResult, error)
	ResetContentEpisodeProgress(ctx context.Context, id gqlid.Base64ID, input ResetContentEpisodeProgressInput) (*ent.ContentEpisode, error)
	FinishContentEpisode(ctx context.Context, id gqlid.Base64ID, input FinishContentEpisodeInput) (*FinishContentEpisodeResult, error)
	CreateJournalRecord(ctx context.Context, input CreateJournalRecordInput) (*ent.JournalRecord, error)
	UpdateJournalRecord(ctx context.Context, id gqlid.Base64ID, input UpdateJournalRecordInput) (*ent.JournalRecord, error)
	DeleteJournalRecord(ctx context.Context, id gqlid.Base64ID) (*ent.JournalRecord, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id gqlid.Base64ID) (ent.Noder, error)
	Nodes(ctx context.Context, ids []*gqlid.Base64ID) ([]ent.Noder, error)
	Contents(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ContentOrder, where *ent.ContentWhereInput) (*ent.ContentConnection, error)
	ContentEpisodes(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ContentEpisodeOrder, where *ent.ContentEpisodeWhereInput) (*ent.ContentEpisodeConnection, error)
	Courses(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.CourseOrder, where *ent.CourseWhereInput) (*ent.CourseConnection, error)
	JournalRecords(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.JournalRecordOrder, where *ent.JournalRecordWhereInput) (*ent.JournalRecordConnection, error)
	Lessons(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.LessonOrder, where *ent.LessonWhereInput) (*ent.LessonConnection, error)
	Techniques(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.TechniqueOrder, where *ent.TechniqueWhereInput) (*ent.TechniqueConnection, error)
	Units(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.UnitOrder, where *ent.UnitWhereInput) (*ent.UnitConnection, error)
	ActiveEpisodes(ctx context.Context) ([]*ent.ContentEpisode, error)
	ActiveEpisode(ctx context.Context, contentID gqlid.Base64ID) (*ent.ContentEpisode, error)
	WeekStats(ctx context.Context) ([]*ent.JournalRecord, error)
	ActiveLessons(ctx context.Context) ([]*ent.Lesson, error)
	Me(ctx context.Context) (*ent.User, error)
	MeditationsStats(ctx context.Context, input MeditationsStatsInput) (*MeditationsStats, error)
}
type TechniqueResolver interface {
	ID(ctx context.Context, obj *ent.Technique) (*gqlid.Base64ID, error)
	UnitID(ctx context.Context, obj *ent.Technique) (*gqlid.Base64ID, error)
}
type UnitResolver interface {
	ID(ctx context.Context, obj *ent.Unit) (*gqlid.Base64ID, error)
	CourseID(ctx context.Context, obj *ent.Unit) (*gqlid.Base64ID, error)

	LessonsTotal(ctx context.Context, obj *ent.Unit) (int, error)
	LessonsCompleted(ctx context.Context, obj *ent.Unit) (int, error)
	IsActive(ctx context.Context, obj *ent.Unit) (bool, error)
	NextUnit(ctx context.Context, obj *ent.Unit) (*ent.Unit, error)
	Techniques(ctx context.Context, obj *ent.Unit) ([]*ent.Technique, error)
	UnitTechniques(ctx context.Context, obj *ent.Unit) ([]*ent.UnitTechnique, error)
}
type UnitTechniqueResolver interface {
	UnitID(ctx context.Context, obj *ent.UnitTechnique) (*gqlid.Base64ID, error)
	TechniqueID(ctx context.Context, obj *ent.UnitTechnique) (*gqlid.Base64ID, error)
	Technique(ctx context.Context, obj *ent.UnitTechnique) (*ent.Technique, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *ent.User) (*gqlid.Base64ID, error)
}
type UserProgressResolver interface {
	ID(ctx context.Context, obj *ent.UserProgress) (*gqlid.Base64ID, error)
	UserID(ctx context.Context, obj *ent.UserProgress) (*gqlid.Base64ID, error)
	CourseID(ctx context.Context, obj *ent.UserProgress) (*gqlid.Base64ID, error)
	UnitID(ctx context.Context, obj *ent.UserProgress) (*gqlid.Base64ID, error)
	LessonID(ctx context.Context, obj *ent.UserProgress) (*gqlid.Base64ID, error)
}

type ContentEpisodeWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	ContentID(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	ContentIDNeq(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data *gqlid.Base64ID) error
	ContentIDIn(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data []*gqlid.Base64ID) error
	ContentIDNotIn(ctx context.Context, obj *ent.ContentEpisodeWhereInput, data []*gqlid.Base64ID) error
}
type ContentProgressWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	UserID(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	UserIDNeq(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	UserIDIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	UserIDNotIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	ContentID(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	ContentIDNeq(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	ContentIDIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	ContentIDNotIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	EpisodeID(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	EpisodeIDNeq(ctx context.Context, obj *ent.ContentProgressWhereInput, data *gqlid.Base64ID) error
	EpisodeIDIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
	EpisodeIDNotIn(ctx context.Context, obj *ent.ContentProgressWhereInput, data []*gqlid.Base64ID) error
}
type ContentWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.ContentWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.ContentWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.ContentWhereInput, data *gqlid.Base64ID) error
}
type CourseWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.CourseWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.CourseWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.CourseWhereInput, data *gqlid.Base64ID) error
}
type JournalRecordWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	UserID(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	UserIDNeq(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	UserIDIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
	UserIDNotIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
	LessonID(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	LessonIDNeq(ctx context.Context, obj *ent.JournalRecordWhereInput, data *gqlid.Base64ID) error
	LessonIDIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
	LessonIDNotIn(ctx context.Context, obj *ent.JournalRecordWhereInput, data []*gqlid.Base64ID) error
}
type LessonAudioWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.LessonAudioWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.LessonAudioWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	LessonID(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	LessonIDNeq(ctx context.Context, obj *ent.LessonAudioWhereInput, data *gqlid.Base64ID) error
	LessonIDIn(ctx context.Context, obj *ent.LessonAudioWhereInput, data []*gqlid.Base64ID) error
	LessonIDNotIn(ctx context.Context, obj *ent.LessonAudioWhereInput, data []*gqlid.Base64ID) error
}
type LessonWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.LessonWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.LessonWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	UnitID(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	UnitIDNeq(ctx context.Context, obj *ent.LessonWhereInput, data *gqlid.Base64ID) error
	UnitIDIn(ctx context.Context, obj *ent.LessonWhereInput, data []*gqlid.Base64ID) error
	UnitIDNotIn(ctx context.Context, obj *ent.LessonWhereInput, data []*gqlid.Base64ID) error
}
type TechniqueWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.TechniqueWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.TechniqueWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	UnitID(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	UnitIDNeq(ctx context.Context, obj *ent.TechniqueWhereInput, data *gqlid.Base64ID) error
	UnitIDIn(ctx context.Context, obj *ent.TechniqueWhereInput, data []*gqlid.Base64ID) error
	UnitIDNotIn(ctx context.Context, obj *ent.TechniqueWhereInput, data []*gqlid.Base64ID) error
}
type UnitWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.UnitWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.UnitWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	CourseID(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	CourseIDNeq(ctx context.Context, obj *ent.UnitWhereInput, data *gqlid.Base64ID) error
	CourseIDIn(ctx context.Context, obj *ent.UnitWhereInput, data []*gqlid.Base64ID) error
	CourseIDNotIn(ctx context.Context, obj *ent.UnitWhereInput, data []*gqlid.Base64ID) error
}
type UserProgressWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	UserID(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	UserIDNeq(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	UserIDIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	UserIDNotIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	CourseID(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	CourseIDNeq(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	CourseIDIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	CourseIDNotIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	UnitID(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	UnitIDNeq(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	UnitIDIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	UnitIDNotIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	LessonID(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	LessonIDNeq(ctx context.Context, obj *ent.UserProgressWhereInput, data *gqlid.Base64ID) error
	LessonIDIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
	LessonIDNotIn(ctx context.Context, obj *ent.UserProgressWhereInput, data []*gqlid.Base64ID) error
}
type UserWhereInputResolver interface {
	ID(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
	IDNeq(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
	IDIn(ctx context.Context, obj *ent.UserWhereInput, data []*gqlid.Base64ID) error
	IDNotIn(ctx context.Context, obj *ent.UserWhereInput, data []*gqlid.Base64ID) error
	IDGt(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
	IDGte(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
	IDLt(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
	IDLte(ctx context.Context, obj *ent.UserWhereInput, data *gqlid.Base64ID) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Content.coverimage":
		if e.complexity.Content.CoverImage == nil {
			break
		}

		return e.complexity.Content.CoverImage(childComplexity), true

	case "Content.description":
		if e.complexity.Content.Description == nil {
			break
		}

		return e.complexity.Content.Description(childComplexity), true

	case "Content.episodes":
		if e.complexity.Content.Episodes == nil {
			break
		}

		args, err := ec.field_Content_episodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Content.Episodes(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.ContentEpisodeOrder), args["where"].(*ent.ContentEpisodeWhereInput)), true

	case "Content.episodescount":
		if e.complexity.Content.EpisodesCount == nil {
			break
		}

		return e.complexity.Content.EpisodesCount(childComplexity), true

	case "Content.episodesList":
		if e.complexity.Content.EpisodesList == nil {
			break
		}

		return e.complexity.Content.EpisodesList(childComplexity), true

	case "Content.id":
		if e.complexity.Content.ID == nil {
			break
		}

		return e.complexity.Content.ID(childComplexity), true

	case "Content.iconimage":
		if e.complexity.Content.IconImage == nil {
			break
		}

		return e.complexity.Content.IconImage(childComplexity), true

	case "Content.ishidden":
		if e.complexity.Content.IsHidden == nil {
			break
		}

		return e.complexity.Content.IsHidden(childComplexity), true

	case "Content.licence":
		if e.complexity.Content.Licence == nil {
			break
		}

		return e.complexity.Content.Licence(childComplexity), true

	case "Content.licenceurl":
		if e.complexity.Content.LicenceURL == nil {
			break
		}

		return e.complexity.Content.LicenceURL(childComplexity), true

	case "Content.order":
		if e.complexity.Content.Order == nil {
			break
		}

		return e.complexity.Content.Order(childComplexity), true

	case "Content.singleEpisode":
		if e.complexity.Content.SingleEpisode == nil {
			break
		}

		return e.complexity.Content.SingleEpisode(childComplexity), true

	case "Content.source":
		if e.complexity.Content.Source == nil {
			break
		}

		return e.complexity.Content.Source(childComplexity), true

	case "Content.sourceurl":
		if e.complexity.Content.SourceURL == nil {
			break
		}

		return e.complexity.Content.SourceURL(childComplexity), true

	case "Content.subtitle":
		if e.complexity.Content.Subtitle == nil {
			break
		}

		return e.complexity.Content.Subtitle(childComplexity), true

	case "Content.title":
		if e.complexity.Content.Title == nil {
			break
		}

		return e.complexity.Content.Title(childComplexity), true

	case "Content.type":
		if e.complexity.Content.Type == nil {
			break
		}

		return e.complexity.Content.Type(childComplexity), true

	case "ContentConnection.edges":
		if e.complexity.ContentConnection.Edges == nil {
			break
		}

		return e.complexity.ContentConnection.Edges(childComplexity), true

	case "ContentConnection.pageInfo":
		if e.complexity.ContentConnection.PageInfo == nil {
			break
		}

		return e.complexity.ContentConnection.PageInfo(childComplexity), true

	case "ContentConnection.totalCount":
		if e.complexity.ContentConnection.TotalCount == nil {
			break
		}

		return e.complexity.ContentConnection.TotalCount(childComplexity), true

	case "ContentEdge.cursor":
		if e.complexity.ContentEdge.Cursor == nil {
			break
		}

		return e.complexity.ContentEdge.Cursor(childComplexity), true

	case "ContentEdge.node":
		if e.complexity.ContentEdge.Node == nil {
			break
		}

		return e.complexity.ContentEdge.Node(childComplexity), true

	case "ContentEpisode.content":
		if e.complexity.ContentEpisode.Content == nil {
			break
		}

		return e.complexity.ContentEpisode.Content(childComplexity), true

	case "ContentEpisode.contentID":
		if e.complexity.ContentEpisode.ContentID == nil {
			break
		}

		return e.complexity.ContentEpisode.ContentID(childComplexity), true

	case "ContentEpisode.description":
		if e.complexity.ContentEpisode.Description == nil {
			break
		}

		return e.complexity.ContentEpisode.Description(childComplexity), true

	case "ContentEpisode.downloadurl":
		if e.complexity.ContentEpisode.DownloadURL == nil {
			break
		}

		return e.complexity.ContentEpisode.DownloadURL(childComplexity), true

	case "ContentEpisode.duration":
		if e.complexity.ContentEpisode.Duration == nil {
			break
		}

		return e.complexity.ContentEpisode.Duration(childComplexity), true

	case "ContentEpisode.finishedAt":
		if e.complexity.ContentEpisode.FinishedAt == nil {
			break
		}

		return e.complexity.ContentEpisode.FinishedAt(childComplexity), true

	case "ContentEpisode.id":
		if e.complexity.ContentEpisode.ID == nil {
			break
		}

		return e.complexity.ContentEpisode.ID(childComplexity), true

	case "ContentEpisode.ishidden":
		if e.complexity.ContentEpisode.IsHidden == nil {
			break
		}

		return e.complexity.ContentEpisode.IsHidden(childComplexity), true

	case "ContentEpisode.licence":
		if e.complexity.ContentEpisode.Licence == nil {
			break
		}

		return e.complexity.ContentEpisode.Licence(childComplexity), true

	case "ContentEpisode.licenceurl":
		if e.complexity.ContentEpisode.LicenceURL == nil {
			break
		}

		return e.complexity.ContentEpisode.LicenceURL(childComplexity), true

	case "ContentEpisode.order":
		if e.complexity.ContentEpisode.Order == nil {
			break
		}

		return e.complexity.ContentEpisode.Order(childComplexity), true

	case "ContentEpisode.progress":
		if e.complexity.ContentEpisode.Progress == nil {
			break
		}

		return e.complexity.ContentEpisode.Progress(childComplexity), true

	case "ContentEpisode.source":
		if e.complexity.ContentEpisode.Source == nil {
			break
		}

		return e.complexity.ContentEpisode.Source(childComplexity), true

	case "ContentEpisode.sourceurl":
		if e.complexity.ContentEpisode.SourceURL == nil {
			break
		}

		return e.complexity.ContentEpisode.SourceURL(childComplexity), true

	case "ContentEpisode.streamurl":
		if e.complexity.ContentEpisode.StreamURL == nil {
			break
		}

		return e.complexity.ContentEpisode.StreamURL(childComplexity), true

	case "ContentEpisode.subtitle":
		if e.complexity.ContentEpisode.Subtitle == nil {
			break
		}

		return e.complexity.ContentEpisode.Subtitle(childComplexity), true

	case "ContentEpisode.title":
		if e.complexity.ContentEpisode.Title == nil {
			break
		}

		return e.complexity.ContentEpisode.Title(childComplexity), true

	case "ContentEpisode.type":
		if e.complexity.ContentEpisode.Type == nil {
			break
		}

		return e.complexity.ContentEpisode.Type(childComplexity), true

	case "ContentEpisodeConnection.edges":
		if e.complexity.ContentEpisodeConnection.Edges == nil {
			break
		}

		return e.complexity.ContentEpisodeConnection.Edges(childComplexity), true

	case "ContentEpisodeConnection.pageInfo":
		if e.complexity.ContentEpisodeConnection.PageInfo == nil {
			break
		}

		return e.complexity.ContentEpisodeConnection.PageInfo(childComplexity), true

	case "ContentEpisodeConnection.totalCount":
		if e.complexity.ContentEpisodeConnection.TotalCount == nil {
			break
		}

		return e.complexity.ContentEpisodeConnection.TotalCount(childComplexity), true

	case "ContentEpisodeEdge.cursor":
		if e.complexity.ContentEpisodeEdge.Cursor == nil {
			break
		}

		return e.complexity.ContentEpisodeEdge.Cursor(childComplexity), true

	case "ContentEpisodeEdge.node":
		if e.complexity.ContentEpisodeEdge.Node == nil {
			break
		}

		return e.complexity.ContentEpisodeEdge.Node(childComplexity), true

	case "ContentProgress.content":
		if e.complexity.ContentProgress.Content == nil {
			break
		}

		return e.complexity.ContentProgress.Content(childComplexity), true

	case "ContentProgress.contentID":
		if e.complexity.ContentProgress.ContentID == nil {
			break
		}

		return e.complexity.ContentProgress.ContentID(childComplexity), true

	case "ContentProgress.contentType":
		if e.complexity.ContentProgress.ContentType == nil {
			break
		}

		return e.complexity.ContentProgress.ContentType(childComplexity), true

	case "ContentProgress.createdat":
		if e.complexity.ContentProgress.CreatedAt == nil {
			break
		}

		return e.complexity.ContentProgress.CreatedAt(childComplexity), true

	case "ContentProgress.episode":
		if e.complexity.ContentProgress.Episode == nil {
			break
		}

		return e.complexity.ContentProgress.Episode(childComplexity), true

	case "ContentProgress.episodeID":
		if e.complexity.ContentProgress.EpisodeID == nil {
			break
		}

		return e.complexity.ContentProgress.EpisodeID(childComplexity), true

	case "ContentProgress.finishedat":
		if e.complexity.ContentProgress.FinishedAt == nil {
			break
		}

		return e.complexity.ContentProgress.FinishedAt(childComplexity), true

	case "ContentProgress.id":
		if e.complexity.ContentProgress.ID == nil {
			break
		}

		return e.complexity.ContentProgress.ID(childComplexity), true

	case "ContentProgress.progress":
		if e.complexity.ContentProgress.Progress == nil {
			break
		}

		return e.complexity.ContentProgress.Progress(childComplexity), true

	case "ContentProgress.updatedat":
		if e.complexity.ContentProgress.UpdatedAt == nil {
			break
		}

		return e.complexity.ContentProgress.UpdatedAt(childComplexity), true

	case "ContentProgress.user":
		if e.complexity.ContentProgress.User == nil {
			break
		}

		return e.complexity.ContentProgress.User(childComplexity), true

	case "ContentProgress.userID":
		if e.complexity.ContentProgress.UserID == nil {
			break
		}

		return e.complexity.ContentProgress.UserID(childComplexity), true

	case "Course.active":
		if e.complexity.Course.Active == nil {
			break
		}

		return e.complexity.Course.Active(childComplexity), true

	case "Course.color":
		if e.complexity.Course.Color == nil {
			break
		}

		return e.complexity.Course.Color(childComplexity), true

	case "Course.coverimage":
		if e.complexity.Course.CoverImage == nil {
			break
		}

		return e.complexity.Course.CoverImage(childComplexity), true

	case "Course.description":
		if e.complexity.Course.Description == nil {
			break
		}

		return e.complexity.Course.Description(childComplexity), true

	case "Course.id":
		if e.complexity.Course.ID == nil {
			break
		}

		return e.complexity.Course.ID(childComplexity), true

	case "Course.iconimage":
		if e.complexity.Course.IconImage == nil {
			break
		}

		return e.complexity.Course.IconImage(childComplexity), true

	case "Course.isStarted":
		if e.complexity.Course.IsStarted == nil {
			break
		}

		return e.complexity.Course.IsStarted(childComplexity), true

	case "Course.order":
		if e.complexity.Course.Order == nil {
			break
		}

		return e.complexity.Course.Order(childComplexity), true

	case "Course.title":
		if e.complexity.Course.Title == nil {
			break
		}

		return e.complexity.Course.Title(childComplexity), true

	case "Course.units":
		if e.complexity.Course.Units == nil {
			break
		}

		args, err := ec.field_Course_units_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Course.Units(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.UnitOrder), args["where"].(*ent.UnitWhereInput)), true

	case "CourseConnection.edges":
		if e.complexity.CourseConnection.Edges == nil {
			break
		}

		return e.complexity.CourseConnection.Edges(childComplexity), true

	case "CourseConnection.pageInfo":
		if e.complexity.CourseConnection.PageInfo == nil {
			break
		}

		return e.complexity.CourseConnection.PageInfo(childComplexity), true

	case "CourseConnection.totalCount":
		if e.complexity.CourseConnection.TotalCount == nil {
			break
		}

		return e.complexity.CourseConnection.TotalCount(childComplexity), true

	case "CourseEdge.cursor":
		if e.complexity.CourseEdge.Cursor == nil {
			break
		}

		return e.complexity.CourseEdge.Cursor(childComplexity), true

	case "CourseEdge.node":
		if e.complexity.CourseEdge.Node == nil {
			break
		}

		return e.complexity.CourseEdge.Node(childComplexity), true

	case "DownloadContentEpisodeResult.success":
		if e.complexity.DownloadContentEpisodeResult.Success == nil {
			break
		}

		return e.complexity.DownloadContentEpisodeResult.Success(childComplexity), true

	case "DownloadContentResult.success":
		if e.complexity.DownloadContentResult.Success == nil {
			break
		}

		return e.complexity.DownloadContentResult.Success(childComplexity), true

	case "DownloadLessonResult.success":
		if e.complexity.DownloadLessonResult.Success == nil {
			break
		}

		return e.complexity.DownloadLessonResult.Success(childComplexity), true

	case "DownloadUnitResult.success":
		if e.complexity.DownloadUnitResult.Success == nil {
			break
		}

		return e.complexity.DownloadUnitResult.Success(childComplexity), true

	case "FinishContentEpisodeResult.episode":
		if e.complexity.FinishContentEpisodeResult.Episode == nil {
			break
		}

		return e.complexity.FinishContentEpisodeResult.Episode(childComplexity), true

	case "FinishContentEpisodeResult.nextEpisode":
		if e.complexity.FinishContentEpisodeResult.NextEpisode == nil {
			break
		}

		return e.complexity.FinishContentEpisodeResult.NextEpisode(childComplexity), true

	case "FinishLessonResult.journalRecord":
		if e.complexity.FinishLessonResult.JournalRecord == nil {
			break
		}

		return e.complexity.FinishLessonResult.JournalRecord(childComplexity), true

	case "FinishLessonResult.lesson":
		if e.complexity.FinishLessonResult.Lesson == nil {
			break
		}

		return e.complexity.FinishLessonResult.Lesson(childComplexity), true

	case "FinishLessonResult.nextLesson":
		if e.complexity.FinishLessonResult.NextLesson == nil {
			break
		}

		return e.complexity.FinishLessonResult.NextLesson(childComplexity), true

	case "JournalRecord.createdat":
		if e.complexity.JournalRecord.CreatedAt == nil {
			break
		}

		return e.complexity.JournalRecord.CreatedAt(childComplexity), true

	case "JournalRecord.datetime":
		if e.complexity.JournalRecord.DateTime == nil {
			break
		}

		return e.complexity.JournalRecord.DateTime(childComplexity), true

	case "JournalRecord.duration":
		if e.complexity.JournalRecord.Duration == nil {
			break
		}

		return e.complexity.JournalRecord.Duration(childComplexity), true

	case "JournalRecord.id":
		if e.complexity.JournalRecord.ID == nil {
			break
		}

		return e.complexity.JournalRecord.ID(childComplexity), true

	case "JournalRecord.lesson":
		if e.complexity.JournalRecord.Lesson == nil {
			break
		}

		return e.complexity.JournalRecord.Lesson(childComplexity), true

	case "JournalRecord.lessonID":
		if e.complexity.JournalRecord.LessonID == nil {
			break
		}

		return e.complexity.JournalRecord.LessonID(childComplexity), true

	case "JournalRecord.note":
		if e.complexity.JournalRecord.Note == nil {
			break
		}

		return e.complexity.JournalRecord.Note(childComplexity), true

	case "JournalRecord.unitColor":
		if e.complexity.JournalRecord.UnitColor == nil {
			break
		}

		return e.complexity.JournalRecord.UnitColor(childComplexity), true

	case "JournalRecord.updatedat":
		if e.complexity.JournalRecord.UpdatedAt == nil {
			break
		}

		return e.complexity.JournalRecord.UpdatedAt(childComplexity), true

	case "JournalRecord.user":
		if e.complexity.JournalRecord.User == nil {
			break
		}

		return e.complexity.JournalRecord.User(childComplexity), true

	case "JournalRecord.userID":
		if e.complexity.JournalRecord.UserID == nil {
			break
		}

		return e.complexity.JournalRecord.UserID(childComplexity), true

	case "JournalRecordConnection.edges":
		if e.complexity.JournalRecordConnection.Edges == nil {
			break
		}

		return e.complexity.JournalRecordConnection.Edges(childComplexity), true

	case "JournalRecordConnection.pageInfo":
		if e.complexity.JournalRecordConnection.PageInfo == nil {
			break
		}

		return e.complexity.JournalRecordConnection.PageInfo(childComplexity), true

	case "JournalRecordConnection.totalCount":
		if e.complexity.JournalRecordConnection.TotalCount == nil {
			break
		}

		return e.complexity.JournalRecordConnection.TotalCount(childComplexity), true

	case "JournalRecordEdge.cursor":
		if e.complexity.JournalRecordEdge.Cursor == nil {
			break
		}

		return e.complexity.JournalRecordEdge.Cursor(childComplexity), true

	case "JournalRecordEdge.node":
		if e.complexity.JournalRecordEdge.Node == nil {
			break
		}

		return e.complexity.JournalRecordEdge.Node(childComplexity), true

	case "Lesson.audios":
		if e.complexity.Lesson.Audios == nil {
			break
		}

		return e.complexity.Lesson.Audios(childComplexity), true

	case "Lesson.coverimage":
		if e.complexity.Lesson.CoverImage == nil {
			break
		}

		return e.complexity.Lesson.CoverImage(childComplexity), true

	case "Lesson.description":
		if e.complexity.Lesson.Description == nil {
			break
		}

		return e.complexity.Lesson.Description(childComplexity), true

	case "Lesson.finishedAt":
		if e.complexity.Lesson.FinishedAt == nil {
			break
		}

		return e.complexity.Lesson.FinishedAt(childComplexity), true

	case "Lesson.id":
		if e.complexity.Lesson.ID == nil {
			break
		}

		return e.complexity.Lesson.ID(childComplexity), true

	case "Lesson.iconimage":
		if e.complexity.Lesson.IconImage == nil {
			break
		}

		return e.complexity.Lesson.IconImage(childComplexity), true

	case "Lesson.isLast":
		if e.complexity.Lesson.IsLast == nil {
			break
		}

		return e.complexity.Lesson.IsLast(childComplexity), true

	case "Lesson.isNext":
		if e.complexity.Lesson.IsNext == nil {
			break
		}

		return e.complexity.Lesson.IsNext(childComplexity), true

	case "Lesson.lessonTechniques":
		if e.complexity.Lesson.LessonTechniques == nil {
			break
		}

		return e.complexity.Lesson.LessonTechniques(childComplexity), true

	case "Lesson.order":
		if e.complexity.Lesson.Order == nil {
			break
		}

		return e.complexity.Lesson.Order(childComplexity), true

	case "Lesson.progress":
		if e.complexity.Lesson.Progress == nil {
			break
		}

		return e.complexity.Lesson.Progress(childComplexity), true

	case "Lesson.techniques":
		if e.complexity.Lesson.Techniques == nil {
			break
		}

		return e.complexity.Lesson.Techniques(childComplexity), true

	case "Lesson.title":
		if e.complexity.Lesson.Title == nil {
			break
		}

		return e.complexity.Lesson.Title(childComplexity), true

	case "Lesson.type":
		if e.complexity.Lesson.Type == nil {
			break
		}

		return e.complexity.Lesson.Type(childComplexity), true

	case "Lesson.unit":
		if e.complexity.Lesson.Unit == nil {
			break
		}

		return e.complexity.Lesson.Unit(childComplexity), true

	case "Lesson.unitID":
		if e.complexity.Lesson.UnitID == nil {
			break
		}

		return e.complexity.Lesson.UnitID(childComplexity), true

	case "LessonAudio.audiourl":
		if e.complexity.LessonAudio.AudioURL == nil {
			break
		}

		return e.complexity.LessonAudio.AudioURL(childComplexity), true

	case "LessonAudio.duration":
		if e.complexity.LessonAudio.Duration == nil {
			break
		}

		return e.complexity.LessonAudio.Duration(childComplexity), true

	case "LessonAudio.id":
		if e.complexity.LessonAudio.ID == nil {
			break
		}

		return e.complexity.LessonAudio.ID(childComplexity), true

	case "LessonAudio.lesson":
		if e.complexity.LessonAudio.Lesson == nil {
			break
		}

		return e.complexity.LessonAudio.Lesson(childComplexity), true

	case "LessonAudio.lessonID":
		if e.complexity.LessonAudio.LessonID == nil {
			break
		}

		return e.complexity.LessonAudio.LessonID(childComplexity), true

	case "LessonConnection.edges":
		if e.complexity.LessonConnection.Edges == nil {
			break
		}

		return e.complexity.LessonConnection.Edges(childComplexity), true

	case "LessonConnection.pageInfo":
		if e.complexity.LessonConnection.PageInfo == nil {
			break
		}

		return e.complexity.LessonConnection.PageInfo(childComplexity), true

	case "LessonConnection.totalCount":
		if e.complexity.LessonConnection.TotalCount == nil {
			break
		}

		return e.complexity.LessonConnection.TotalCount(childComplexity), true

	case "LessonEdge.cursor":
		if e.complexity.LessonEdge.Cursor == nil {
			break
		}

		return e.complexity.LessonEdge.Cursor(childComplexity), true

	case "LessonEdge.node":
		if e.complexity.LessonEdge.Node == nil {
			break
		}

		return e.complexity.LessonEdge.Node(childComplexity), true

	case "LessonTechnique.lessonId":
		if e.complexity.LessonTechnique.LessonID == nil {
			break
		}

		return e.complexity.LessonTechnique.LessonID(childComplexity), true

	case "LessonTechnique.order":
		if e.complexity.LessonTechnique.Order == nil {
			break
		}

		return e.complexity.LessonTechnique.Order(childComplexity), true

	case "LessonTechnique.technique":
		if e.complexity.LessonTechnique.Technique == nil {
			break
		}

		return e.complexity.LessonTechnique.Technique(childComplexity), true

	case "LessonTechnique.techniqueId":
		if e.complexity.LessonTechnique.TechniqueID == nil {
			break
		}

		return e.complexity.LessonTechnique.TechniqueID(childComplexity), true

	case "MeditationsStats.currentStrike":
		if e.complexity.MeditationsStats.CurrentStrike == nil {
			break
		}

		return e.complexity.MeditationsStats.CurrentStrike(childComplexity), true

	case "MeditationsStats.hoursTotal":
		if e.complexity.MeditationsStats.HoursTotal == nil {
			break
		}

		return e.complexity.MeditationsStats.HoursTotal(childComplexity), true

	case "MeditationsStats.lastMeditationDate":
		if e.complexity.MeditationsStats.LastMeditationDate == nil {
			break
		}

		return e.complexity.MeditationsStats.LastMeditationDate(childComplexity), true

	case "MeditationsStats.sessionsTotal":
		if e.complexity.MeditationsStats.SessionsTotal == nil {
			break
		}

		return e.complexity.MeditationsStats.SessionsTotal(childComplexity), true

	case "Mutation.createJournalRecord":
		if e.complexity.Mutation.CreateJournalRecord == nil {
			break
		}

		args, err := ec.field_Mutation_createJournalRecord_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateJournalRecord(childComplexity, args["input"].(CreateJournalRecordInput)), true

	case "Mutation.deleteJournalRecord":
		if e.complexity.Mutation.DeleteJournalRecord == nil {
			break
		}

		args, err := ec.field_Mutation_deleteJournalRecord_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteJournalRecord(childComplexity, args["id"].(gqlid.Base64ID)), true

	case "Mutation.downloadContent":
		if e.complexity.Mutation.DownloadContent == nil {
			break
		}

		args, err := ec.field_Mutation_downloadContent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DownloadContent(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(DownloadContentInput)), true

	case "Mutation.downloadContentEpisode":
		if e.complexity.Mutation.DownloadContentEpisode == nil {
			break
		}

		args, err := ec.field_Mutation_downloadContentEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DownloadContentEpisode(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(DownloadContentEpisodeInput)), true

	case "Mutation.downloadLesson":
		if e.complexity.Mutation.DownloadLesson == nil {
			break
		}

		args, err := ec.field_Mutation_downloadLesson_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DownloadLesson(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(DownloadLessonInput)), true

	case "Mutation.downloadUnit":
		if e.complexity.Mutation.DownloadUnit == nil {
			break
		}

		args, err := ec.field_Mutation_downloadUnit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DownloadUnit(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(DownloadUnitInput)), true

	case "Mutation.finishContentEpisode":
		if e.complexity.Mutation.FinishContentEpisode == nil {
			break
		}

		args, err := ec.field_Mutation_finishContentEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishContentEpisode(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(FinishContentEpisodeInput)), true

	case "Mutation.finishLesson":
		if e.complexity.Mutation.FinishLesson == nil {
			break
		}

		args, err := ec.field_Mutation_finishLesson_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FinishLesson(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(FinishLessonInput)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_refreshToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshToken(childComplexity, args["input"].(RefreshTokenInput)), true

	case "Mutation.resetContentEpisodeProgress":
		if e.complexity.Mutation.ResetContentEpisodeProgress == nil {
			break
		}

		args, err := ec.field_Mutation_resetContentEpisodeProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetContentEpisodeProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(ResetContentEpisodeProgressInput)), true

	case "Mutation.resetContentProgress":
		if e.complexity.Mutation.ResetContentProgress == nil {
			break
		}

		args, err := ec.field_Mutation_resetContentProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetContentProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(ResetContentProgressInput)), true

	case "Mutation.resetLessonProgress":
		if e.complexity.Mutation.ResetLessonProgress == nil {
			break
		}

		args, err := ec.field_Mutation_resetLessonProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetLessonProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(ResetLessonProgressInput)), true

	case "Mutation.resetUnitProgress":
		if e.complexity.Mutation.ResetUnitProgress == nil {
			break
		}

		args, err := ec.field_Mutation_resetUnitProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetUnitProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(ResetUnitProgressInput)), true

	case "Mutation.saveContentEpisodeProgress":
		if e.complexity.Mutation.SaveContentEpisodeProgress == nil {
			break
		}

		args, err := ec.field_Mutation_saveContentEpisodeProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveContentEpisodeProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(SaveContentEpisodeProgressInput)), true

	case "Mutation.saveLessonProgress":
		if e.complexity.Mutation.SaveLessonProgress == nil {
			break
		}

		args, err := ec.field_Mutation_saveLessonProgress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveLessonProgress(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(SaveLessonProgressInput)), true

	case "Mutation.signInWithEmailAndPassword":
		if e.complexity.Mutation.SignInWithEmailAndPassword == nil {
			break
		}

		args, err := ec.field_Mutation_signInWithEmailAndPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SignInWithEmailAndPassword(childComplexity, args["input"].(SignInWithEmailAndPasswordInput)), true

	case "Mutation.signOut":
		if e.complexity.Mutation.SignOut == nil {
			break
		}

		args, err := ec.field_Mutation_signOut_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SignOut(childComplexity, args["input"].(SignOutInput)), true

	case "Mutation.signUpWithEmailAndPassword":
		if e.complexity.Mutation.SignUpWithEmailAndPassword == nil {
			break
		}

		args, err := ec.field_Mutation_signUpWithEmailAndPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SignUpWithEmailAndPassword(childComplexity, args["input"].(SignUpWithEmailAndPasswordInput)), true

	case "Mutation.updateJournalRecord":
		if e.complexity.Mutation.UpdateJournalRecord == nil {
			break
		}

		args, err := ec.field_Mutation_updateJournalRecord_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateJournalRecord(childComplexity, args["id"].(gqlid.Base64ID), args["input"].(UpdateJournalRecordInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.activeEpisode":
		if e.complexity.Query.ActiveEpisode == nil {
			break
		}

		args, err := ec.field_Query_activeEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ActiveEpisode(childComplexity, args["contentId"].(gqlid.Base64ID)), true

	case "Query.activeEpisodes":
		if e.complexity.Query.ActiveEpisodes == nil {
			break
		}

		return e.complexity.Query.ActiveEpisodes(childComplexity), true

	case "Query.activeLessons":
		if e.complexity.Query.ActiveLessons == nil {
			break
		}

		return e.complexity.Query.ActiveLessons(childComplexity), true

	case "Query.contentEpisodes":
		if e.complexity.Query.ContentEpisodes == nil {
			break
		}

		args, err := ec.field_Query_contentEpisodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ContentEpisodes(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.ContentEpisodeOrder), args["where"].(*ent.ContentEpisodeWhereInput)), true

	case "Query.contents":
		if e.complexity.Query.Contents == nil {
			break
		}

		args, err := ec.field_Query_contents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Contents(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.ContentOrder), args["where"].(*ent.ContentWhereInput)), true

	case "Query.courses":
		if e.complexity.Query.Courses == nil {
			break
		}

		args, err := ec.field_Query_courses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Courses(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.CourseOrder), args["where"].(*ent.CourseWhereInput)), true

	case "Query.journalRecords":
		if e.complexity.Query.JournalRecords == nil {
			break
		}

		args, err := ec.field_Query_journalRecords_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.JournalRecords(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.JournalRecordOrder), args["where"].(*ent.JournalRecordWhereInput)), true

	case "Query.lessons":
		if e.complexity.Query.Lessons == nil {
			break
		}

		args, err := ec.field_Query_lessons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Lessons(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.LessonOrder), args["where"].(*ent.LessonWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.meditationsStats":
		if e.complexity.Query.MeditationsStats == nil {
			break
		}

		args, err := ec.field_Query_meditationsStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MeditationsStats(childComplexity, args["input"].(MeditationsStatsInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(gqlid.Base64ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]*gqlid.Base64ID)), true

	case "Query.techniques":
		if e.complexity.Query.Techniques == nil {
			break
		}

		args, err := ec.field_Query_techniques_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Techniques(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.TechniqueOrder), args["where"].(*ent.TechniqueWhereInput)), true

	case "Query.units":
		if e.complexity.Query.Units == nil {
			break
		}

		args, err := ec.field_Query_units_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Units(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.UnitOrder), args["where"].(*ent.UnitWhereInput)), true

	case "Query.weekStats":
		if e.complexity.Query.WeekStats == nil {
			break
		}

		return e.complexity.Query.WeekStats(childComplexity), true

	case "RefreshTokenResult.accessToken":
		if e.complexity.RefreshTokenResult.AccessToken == nil {
			break
		}

		return e.complexity.RefreshTokenResult.AccessToken(childComplexity), true

	case "RefreshTokenResult.refreshToken":
		if e.complexity.RefreshTokenResult.RefreshToken == nil {
			break
		}

		return e.complexity.RefreshTokenResult.RefreshToken(childComplexity), true

	case "SignInWithEmailAndPasswordResult.accessToken":
		if e.complexity.SignInWithEmailAndPasswordResult.AccessToken == nil {
			break
		}

		return e.complexity.SignInWithEmailAndPasswordResult.AccessToken(childComplexity), true

	case "SignInWithEmailAndPasswordResult.refreshToken":
		if e.complexity.SignInWithEmailAndPasswordResult.RefreshToken == nil {
			break
		}

		return e.complexity.SignInWithEmailAndPasswordResult.RefreshToken(childComplexity), true

	case "SignInWithEmailAndPasswordResult.user":
		if e.complexity.SignInWithEmailAndPasswordResult.User == nil {
			break
		}

		return e.complexity.SignInWithEmailAndPasswordResult.User(childComplexity), true

	case "SignUpWithEmailAndPasswordResult.accessToken":
		if e.complexity.SignUpWithEmailAndPasswordResult.AccessToken == nil {
			break
		}

		return e.complexity.SignUpWithEmailAndPasswordResult.AccessToken(childComplexity), true

	case "SignUpWithEmailAndPasswordResult.refreshToken":
		if e.complexity.SignUpWithEmailAndPasswordResult.RefreshToken == nil {
			break
		}

		return e.complexity.SignUpWithEmailAndPasswordResult.RefreshToken(childComplexity), true

	case "SignUpWithEmailAndPasswordResult.user":
		if e.complexity.SignUpWithEmailAndPasswordResult.User == nil {
			break
		}

		return e.complexity.SignUpWithEmailAndPasswordResult.User(childComplexity), true

	case "Technique.coverimage":
		if e.complexity.Technique.CoverImage == nil {
			break
		}

		return e.complexity.Technique.CoverImage(childComplexity), true

	case "Technique.description":
		if e.complexity.Technique.Description == nil {
			break
		}

		return e.complexity.Technique.Description(childComplexity), true

	case "Technique.id":
		if e.complexity.Technique.ID == nil {
			break
		}

		return e.complexity.Technique.ID(childComplexity), true

	case "Technique.iconimage":
		if e.complexity.Technique.IconImage == nil {
			break
		}

		return e.complexity.Technique.IconImage(childComplexity), true

	case "Technique.lessons":
		if e.complexity.Technique.Lessons == nil {
			break
		}

		return e.complexity.Technique.Lessons(childComplexity), true

	case "Technique.order":
		if e.complexity.Technique.Order == nil {
			break
		}

		return e.complexity.Technique.Order(childComplexity), true

	case "Technique.subtitle":
		if e.complexity.Technique.Subtitle == nil {
			break
		}

		return e.complexity.Technique.Subtitle(childComplexity), true

	case "Technique.techniques":
		if e.complexity.Technique.Techniques == nil {
			break
		}

		return e.complexity.Technique.Techniques(childComplexity), true

	case "Technique.title":
		if e.complexity.Technique.Title == nil {
			break
		}

		return e.complexity.Technique.Title(childComplexity), true

	case "Technique.unit":
		if e.complexity.Technique.Unit == nil {
			break
		}

		return e.complexity.Technique.Unit(childComplexity), true

	case "Technique.unitID":
		if e.complexity.Technique.UnitID == nil {
			break
		}

		return e.complexity.Technique.UnitID(childComplexity), true

	case "TechniqueConnection.edges":
		if e.complexity.TechniqueConnection.Edges == nil {
			break
		}

		return e.complexity.TechniqueConnection.Edges(childComplexity), true

	case "TechniqueConnection.pageInfo":
		if e.complexity.TechniqueConnection.PageInfo == nil {
			break
		}

		return e.complexity.TechniqueConnection.PageInfo(childComplexity), true

	case "TechniqueConnection.totalCount":
		if e.complexity.TechniqueConnection.TotalCount == nil {
			break
		}

		return e.complexity.TechniqueConnection.TotalCount(childComplexity), true

	case "TechniqueEdge.cursor":
		if e.complexity.TechniqueEdge.Cursor == nil {
			break
		}

		return e.complexity.TechniqueEdge.Cursor(childComplexity), true

	case "TechniqueEdge.node":
		if e.complexity.TechniqueEdge.Node == nil {
			break
		}

		return e.complexity.TechniqueEdge.Node(childComplexity), true

	case "Unit.color":
		if e.complexity.Unit.Color == nil {
			break
		}

		return e.complexity.Unit.Color(childComplexity), true

	case "Unit.course":
		if e.complexity.Unit.Course == nil {
			break
		}

		return e.complexity.Unit.Course(childComplexity), true

	case "Unit.courseID":
		if e.complexity.Unit.CourseID == nil {
			break
		}

		return e.complexity.Unit.CourseID(childComplexity), true

	case "Unit.coverimage":
		if e.complexity.Unit.CoverImage == nil {
			break
		}

		return e.complexity.Unit.CoverImage(childComplexity), true

	case "Unit.days":
		if e.complexity.Unit.Days == nil {
			break
		}

		return e.complexity.Unit.Days(childComplexity), true

	case "Unit.description":
		if e.complexity.Unit.Description == nil {
			break
		}

		return e.complexity.Unit.Description(childComplexity), true

	case "Unit.id":
		if e.complexity.Unit.ID == nil {
			break
		}

		return e.complexity.Unit.ID(childComplexity), true

	case "Unit.iconimage":
		if e.complexity.Unit.IconImage == nil {
			break
		}

		return e.complexity.Unit.IconImage(childComplexity), true

	case "Unit.isActive":
		if e.complexity.Unit.IsActive == nil {
			break
		}

		return e.complexity.Unit.IsActive(childComplexity), true

	case "Unit.lessons":
		if e.complexity.Unit.Lessons == nil {
			break
		}

		args, err := ec.field_Unit_lessons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Unit.Lessons(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.LessonOrder), args["where"].(*ent.LessonWhereInput)), true

	case "Unit.lessonsCompleted":
		if e.complexity.Unit.LessonsCompleted == nil {
			break
		}

		return e.complexity.Unit.LessonsCompleted(childComplexity), true

	case "Unit.lessonsTotal":
		if e.complexity.Unit.LessonsTotal == nil {
			break
		}

		return e.complexity.Unit.LessonsTotal(childComplexity), true

	case "Unit.mastering":
		if e.complexity.Unit.Mastering == nil {
			break
		}

		return e.complexity.Unit.Mastering(childComplexity), true

	case "Unit.nextUnit":
		if e.complexity.Unit.NextUnit == nil {
			break
		}

		return e.complexity.Unit.NextUnit(childComplexity), true

	case "Unit.order":
		if e.complexity.Unit.Order == nil {
			break
		}

		return e.complexity.Unit.Order(childComplexity), true

	case "Unit.subtitle":
		if e.complexity.Unit.Subtitle == nil {
			break
		}

		return e.complexity.Unit.Subtitle(childComplexity), true

	case "Unit.techniques":
		if e.complexity.Unit.Techniques == nil {
			break
		}

		return e.complexity.Unit.Techniques(childComplexity), true

	case "Unit.title":
		if e.complexity.Unit.Title == nil {
			break
		}

		return e.complexity.Unit.Title(childComplexity), true

	case "Unit.unitTechniques":
		if e.complexity.Unit.UnitTechniques == nil {
			break
		}

		return e.complexity.Unit.UnitTechniques(childComplexity), true

	case "UnitConnection.edges":
		if e.complexity.UnitConnection.Edges == nil {
			break
		}

		return e.complexity.UnitConnection.Edges(childComplexity), true

	case "UnitConnection.pageInfo":
		if e.complexity.UnitConnection.PageInfo == nil {
			break
		}

		return e.complexity.UnitConnection.PageInfo(childComplexity), true

	case "UnitConnection.totalCount":
		if e.complexity.UnitConnection.TotalCount == nil {
			break
		}

		return e.complexity.UnitConnection.TotalCount(childComplexity), true

	case "UnitEdge.cursor":
		if e.complexity.UnitEdge.Cursor == nil {
			break
		}

		return e.complexity.UnitEdge.Cursor(childComplexity), true

	case "UnitEdge.node":
		if e.complexity.UnitEdge.Node == nil {
			break
		}

		return e.complexity.UnitEdge.Node(childComplexity), true

	case "UnitTechnique.position":
		if e.complexity.UnitTechnique.Position == nil {
			break
		}

		return e.complexity.UnitTechnique.Position(childComplexity), true

	case "UnitTechnique.technique":
		if e.complexity.UnitTechnique.Technique == nil {
			break
		}

		return e.complexity.UnitTechnique.Technique(childComplexity), true

	case "UnitTechnique.techniqueId":
		if e.complexity.UnitTechnique.TechniqueID == nil {
			break
		}

		return e.complexity.UnitTechnique.TechniqueID(childComplexity), true

	case "UnitTechnique.unitId":
		if e.complexity.UnitTechnique.UnitID == nil {
			break
		}

		return e.complexity.UnitTechnique.UnitID(childComplexity), true

	case "User.authMethod":
		if e.complexity.User.AuthMethod == nil {
			break
		}

		return e.complexity.User.AuthMethod(childComplexity), true

	case "User.createdat":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.displayname":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.emailVerified":
		if e.complexity.User.EmailVerified == nil {
			break
		}

		return e.complexity.User.EmailVerified(childComplexity), true

	case "User.firebaseuid":
		if e.complexity.User.FirebaseUid == nil {
			break
		}

		return e.complexity.User.FirebaseUid(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.updatedat":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserProgress.course":
		if e.complexity.UserProgress.Course == nil {
			break
		}

		return e.complexity.UserProgress.Course(childComplexity), true

	case "UserProgress.courseID":
		if e.complexity.UserProgress.CourseID == nil {
			break
		}

		return e.complexity.UserProgress.CourseID(childComplexity), true

	case "UserProgress.createdat":
		if e.complexity.UserProgress.CreatedAt == nil {
			break
		}

		return e.complexity.UserProgress.CreatedAt(childComplexity), true

	case "UserProgress.finishedat":
		if e.complexity.UserProgress.FinishedAt == nil {
			break
		}

		return e.complexity.UserProgress.FinishedAt(childComplexity), true

	case "UserProgress.id":
		if e.complexity.UserProgress.ID == nil {
			break
		}

		return e.complexity.UserProgress.ID(childComplexity), true

	case "UserProgress.islast":
		if e.complexity.UserProgress.IsLast == nil {
			break
		}

		return e.complexity.UserProgress.IsLast(childComplexity), true

	case "UserProgress.isnext":
		if e.complexity.UserProgress.IsNext == nil {
			break
		}

		return e.complexity.UserProgress.IsNext(childComplexity), true

	case "UserProgress.lesson":
		if e.complexity.UserProgress.Lesson == nil {
			break
		}

		return e.complexity.UserProgress.Lesson(childComplexity), true

	case "UserProgress.lessonID":
		if e.complexity.UserProgress.LessonID == nil {
			break
		}

		return e.complexity.UserProgress.LessonID(childComplexity), true

	case "UserProgress.lessonType":
		if e.complexity.UserProgress.LessonType == nil {
			break
		}

		return e.complexity.UserProgress.LessonType(childComplexity), true

	case "UserProgress.progress":
		if e.complexity.UserProgress.Progress == nil {
			break
		}

		return e.complexity.UserProgress.Progress(childComplexity), true

	case "UserProgress.unit":
		if e.complexity.UserProgress.Unit == nil {
			break
		}

		return e.complexity.UserProgress.Unit(childComplexity), true

	case "UserProgress.unitID":
		if e.complexity.UserProgress.UnitID == nil {
			break
		}

		return e.complexity.UserProgress.UnitID(childComplexity), true

	case "UserProgress.updatedat":
		if e.complexity.UserProgress.UpdatedAt == nil {
			break
		}

		return e.complexity.UserProgress.UpdatedAt(childComplexity), true

	case "UserProgress.user":
		if e.complexity.UserProgress.User == nil {
			break
		}

		return e.complexity.UserProgress.User(childComplexity), true

	case "UserProgress.userID":
		if e.complexity.UserProgress.UserID == nil {
			break
		}

		return e.complexity.UserProgress.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputContentEpisodeOrder,
		ec.unmarshalInputContentEpisodeWhereInput,
		ec.unmarshalInputContentOrder,
		ec.unmarshalInputContentProgressWhereInput,
		ec.unmarshalInputContentWhereInput,
		ec.unmarshalInputCourseOrder,
		ec.unmarshalInputCourseWhereInput,
		ec.unmarshalInputCreateJournalRecordInput,
		ec.unmarshalInputDownloadContentEpisodeInput,
		ec.unmarshalInputDownloadContentInput,
		ec.unmarshalInputDownloadLessonInput,
		ec.unmarshalInputDownloadUnitInput,
		ec.unmarshalInputFinishContentEpisodeInput,
		ec.unmarshalInputFinishLessonInput,
		ec.unmarshalInputJournalRecordOrder,
		ec.unmarshalInputJournalRecordWhereInput,
		ec.unmarshalInputLessonAudioOrder,
		ec.unmarshalInputLessonAudioWhereInput,
		ec.unmarshalInputLessonOrder,
		ec.unmarshalInputLessonWhereInput,
		ec.unmarshalInputMeditationsStatsInput,
		ec.unmarshalInputRefreshTokenInput,
		ec.unmarshalInputResetContentEpisodeProgressInput,
		ec.unmarshalInputResetContentProgressInput,
		ec.unmarshalInputResetLessonProgressInput,
		ec.unmarshalInputResetUnitProgressInput,
		ec.unmarshalInputSaveContentEpisodeProgressInput,
		ec.unmarshalInputSaveLessonProgressInput,
		ec.unmarshalInputSignInWithEmailAndPasswordInput,
		ec.unmarshalInputSignOutInput,
		ec.unmarshalInputSignUpWithEmailAndPasswordInput,
		ec.unmarshalInputTechniqueOrder,
		ec.unmarshalInputTechniqueWhereInput,
		ec.unmarshalInputUnitOrder,
		ec.unmarshalInputUnitWhereInput,
		ec.unmarshalInputUpdateJournalRecordInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserProgressOrder,
		ec.unmarshalInputUserProgressWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema/auth.graphql" "schema/content.graphql" "schema/content_episode.graphql" "schema/course.graphql" "schema/directives.graphql" "schema/ent.graphql" "schema/journal_record.graphql" "schema/lesson.graphql" "schema/lesson_technique.graphql" "schema/me.graphql" "schema/schema.graphql" "schema/stats.graphql" "schema/unit.graphql" "schema/unit_technique.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/auth.graphql", Input: sourceData("schema/auth.graphql"), BuiltIn: false},
	{Name: "schema/content.graphql", Input: sourceData("schema/content.graphql"), BuiltIn: false},
	{Name: "schema/content_episode.graphql", Input: sourceData("schema/content_episode.graphql"), BuiltIn: false},
	{Name: "schema/course.graphql", Input: sourceData("schema/course.graphql"), BuiltIn: false},
	{Name: "schema/directives.graphql", Input: sourceData("schema/directives.graphql"), BuiltIn: false},
	{Name: "schema/ent.graphql", Input: sourceData("schema/ent.graphql"), BuiltIn: false},
	{Name: "schema/journal_record.graphql", Input: sourceData("schema/journal_record.graphql"), BuiltIn: false},
	{Name: "schema/lesson.graphql", Input: sourceData("schema/lesson.graphql"), BuiltIn: false},
	{Name: "schema/lesson_technique.graphql", Input: sourceData("schema/lesson_technique.graphql"), BuiltIn: false},
	{Name: "schema/me.graphql", Input: sourceData("schema/me.graphql"), BuiltIn: false},
	{Name: "schema/schema.graphql", Input: sourceData("schema/schema.graphql"), BuiltIn: false},
	{Name: "schema/stats.graphql", Input: sourceData("schema/stats.graphql"), BuiltIn: false},
	{Name: "schema/unit.graphql", Input: sourceData("schema/unit.graphql"), BuiltIn: false},
	{Name: "schema/unit_technique.graphql", Input: sourceData("schema/unit_technique.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasPermissions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["permissions"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["permissions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Content_episodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ContentEpisodeOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOContentEpisodeOrder2githubcomjhanaappjhanaappentContentEpisodeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ContentEpisodeWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Course_units_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.UnitOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOUnitOrder2githubcomjhanaappjhanaappentUnitOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.UnitWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_createJournalRecord_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateJournalRecordInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateJournalRecordInput2githubcomjhanaappjhanaappgqlCreateJournalRecordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteJournalRecord_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_downloadContentEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 DownloadContentEpisodeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNDownloadContentEpisodeInput2githubcomjhanaappjhanaappgqlDownloadContentEpisodeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_downloadContent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 DownloadContentInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNDownloadContentInput2githubcomjhanaappjhanaappgqlDownloadContentInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_downloadLesson_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 DownloadLessonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNDownloadLessonInput2githubcomjhanaappjhanaappgqlDownloadLessonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_downloadUnit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 DownloadUnitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNDownloadUnitInput2githubcomjhanaappjhanaappgqlDownloadUnitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finishContentEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FinishContentEpisodeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNFinishContentEpisodeInput2githubcomjhanaappjhanaappgqlFinishContentEpisodeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_finishLesson_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 FinishLessonInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNFinishLessonInput2githubcomjhanaappjhanaappgqlFinishLessonInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 RefreshTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRefreshTokenInput2githubcomjhanaappjhanaappgqlRefreshTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_resetContentEpisodeProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ResetContentEpisodeProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNResetContentEpisodeProgressInput2githubcomjhanaappjhanaappgqlResetContentEpisodeProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resetContentProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ResetContentProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNResetContentProgressInput2githubcomjhanaappjhanaappgqlResetContentProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resetLessonProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ResetLessonProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNResetLessonProgressInput2githubcomjhanaappjhanaappgqlResetLessonProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_resetUnitProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ResetUnitProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNResetUnitProgressInput2githubcomjhanaappjhanaappgqlResetUnitProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveContentEpisodeProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 SaveContentEpisodeProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNSaveContentEpisodeProgressInput2githubcomjhanaappjhanaappgqlSaveContentEpisodeProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveLessonProgress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 SaveLessonProgressInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNSaveLessonProgressInput2githubcomjhanaappjhanaappgqlSaveLessonProgressInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_signInWithEmailAndPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 SignInWithEmailAndPasswordInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSignInWithEmailAndPasswordInput2githubcomjhanaappjhanaappgqlSignInWithEmailAndPasswordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_signOut_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 SignOutInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSignOutInput2githubcomjhanaappjhanaappgqlSignOutInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_signUpWithEmailAndPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 SignUpWithEmailAndPasswordInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSignUpWithEmailAndPasswordInput2githubcomjhanaappjhanaappgqlSignUpWithEmailAndPasswordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateJournalRecord_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 UpdateJournalRecordInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateJournalRecordInput2githubcomjhanaappjhanaappgqlUpdateJournalRecordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_activeEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["contentId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentId"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contentId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_contentEpisodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ContentEpisodeOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOContentEpisodeOrder2githubcomjhanaappjhanaappentContentEpisodeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ContentEpisodeWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_contents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ContentOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOContentOrder2githubcomjhanaappjhanaappentContentOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ContentWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_courses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.CourseOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOCourseOrder2githubcomjhanaappjhanaappentCourseOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.CourseWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_journalRecords_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.JournalRecordOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOJournalRecordOrder2githubcomjhanaappjhanaappentJournalRecordOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.JournalRecordWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_lessons_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.LessonOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLessonOrder2githubcomjhanaappjhanaappentLessonOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LessonWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_meditationsStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 MeditationsStatsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMeditationsStatsInput2githubcomjhanaappjhanaappgqlMeditationsStatsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlid.Base64ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*gqlid.Base64ID
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_techniques_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.TechniqueOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTechniqueOrder2githubcomjhanaappjhanaappentTechniqueOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TechniqueWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_units_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.UnitOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOUnitOrder2githubcomjhanaappjhanaappentUnitOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.UnitWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Unit_lessons_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.LessonOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLessonOrder2githubcomjhanaappjhanaappentLessonOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LessonWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Content_id(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Content().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_type(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.ContentType)
	fc.Result = res
	return ec.marshalNContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ContentContentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_iconimage(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_iconimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_iconimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_coverimage(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_coverimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_coverimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_title(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_subtitle(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_subtitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_subtitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_description(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_source(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_sourceurl(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_sourceurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_sourceurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_licence(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_licence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Licence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_licence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_licenceurl(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_licenceurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_licenceurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_ishidden(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_ishidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsHidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_ishidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_order(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_episodescount(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_episodescount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EpisodesCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_episodescount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_episodes(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_episodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Episodes(ctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ContentEpisodeOrder), fc.Args["where"].(*ent.ContentEpisodeWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisodeConnection)
	fc.Result = res
	return ec.marshalNContentEpisodeConnection2githubcomjhanaappjhanaappentContentEpisodeConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_episodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ContentEpisodeConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ContentEpisodeConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ContentEpisodeConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisodeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Content_episodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Content_singleEpisode(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_singleEpisode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Content().SingleEpisode(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalOContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_singleEpisode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Content_episodesList(ctx context.Context, field graphql.CollectedField, obj *ent.Content) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Content_episodesList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Content().EpisodesList(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Content_episodesList(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Content",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ContentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ContentEdge)
	fc.Result = res
	return ec.marshalOContentEdge2githubcomjhanaappjhanaappentContentEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ContentEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ContentEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ContentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ContentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Content)
	fc.Result = res
	return ec.marshalOContent2githubcomjhanaappjhanaappentContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Content_id(ctx, field)
			case "type":
				return ec.fieldContext_Content_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Content_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Content_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Content_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Content_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Content_description(ctx, field)
			case "source":
				return ec.fieldContext_Content_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_Content_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_Content_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_Content_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_Content_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_Content_order(ctx, field)
			case "episodescount":
				return ec.fieldContext_Content_episodescount(ctx, field)
			case "episodes":
				return ec.fieldContext_Content_episodes(ctx, field)
			case "singleEpisode":
				return ec.fieldContext_Content_singleEpisode(ctx, field)
			case "episodesList":
				return ec.fieldContext_Content_episodesList(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Content", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_id(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentEpisode().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_contentID(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_contentID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentEpisode().ContentID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_contentID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_type(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.ContentType)
	fc.Result = res
	return ec.marshalNContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ContentEpisodeContentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_title(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_subtitle(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_subtitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_subtitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_description(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_duration(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_streamurl(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_streamurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StreamURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_streamurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_downloadurl(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DownloadURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_downloadurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_source(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_sourceurl(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_sourceurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_licence(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_licence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Licence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_licence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_licenceurl(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenceURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_licenceurl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_ishidden(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_ishidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsHidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_ishidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_order(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_content(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Content)
	fc.Result = res
	return ec.marshalNContent2githubcomjhanaappjhanaappentContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Content_id(ctx, field)
			case "type":
				return ec.fieldContext_Content_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Content_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Content_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Content_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Content_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Content_description(ctx, field)
			case "source":
				return ec.fieldContext_Content_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_Content_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_Content_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_Content_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_Content_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_Content_order(ctx, field)
			case "episodescount":
				return ec.fieldContext_Content_episodescount(ctx, field)
			case "episodes":
				return ec.fieldContext_Content_episodes(ctx, field)
			case "singleEpisode":
				return ec.fieldContext_Content_singleEpisode(ctx, field)
			case "episodesList":
				return ec.fieldContext_Content_episodesList(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Content", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_progress(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentEpisode().Progress(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisode_finishedAt(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentEpisode().FinishedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisode_finishedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisode",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisodeConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisodeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisodeConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ContentEpisodeEdge)
	fc.Result = res
	return ec.marshalOContentEpisodeEdge2githubcomjhanaappjhanaappentContentEpisodeEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisodeConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ContentEpisodeEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ContentEpisodeEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisodeEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisodeConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisodeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisodeConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisodeConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisodeConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisodeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisodeConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisodeConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisodeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisodeEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisodeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisodeEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalOContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisodeEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentEpisodeEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ContentEpisodeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentEpisodeEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentEpisodeEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentEpisodeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_id(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentProgress().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_userID(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentProgress().UserID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_contentID(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_contentID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentProgress().ContentID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_contentID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_episodeID(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_episodeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContentProgress().EpisodeID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_episodeID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_contentType(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_contentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.ContentType)
	fc.Result = res
	return ec.marshalNContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_contentType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ContentProgressContentType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_progress(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_finishedat(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_finishedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_finishedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_createdat(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_createdat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_createdat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_updatedat(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_updatedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_updatedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_user(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_content(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Content)
	fc.Result = res
	return ec.marshalNContent2githubcomjhanaappjhanaappentContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_content(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Content_id(ctx, field)
			case "type":
				return ec.fieldContext_Content_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Content_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Content_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Content_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Content_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Content_description(ctx, field)
			case "source":
				return ec.fieldContext_Content_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_Content_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_Content_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_Content_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_Content_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_Content_order(ctx, field)
			case "episodescount":
				return ec.fieldContext_Content_episodescount(ctx, field)
			case "episodes":
				return ec.fieldContext_Content_episodes(ctx, field)
			case "singleEpisode":
				return ec.fieldContext_Content_singleEpisode(ctx, field)
			case "episodesList":
				return ec.fieldContext_Content_episodesList(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Content", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContentProgress_episode(ctx context.Context, field graphql.CollectedField, obj *ent.ContentProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContentProgress_episode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Episode(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContentProgress_episode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContentProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_id(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Course().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_iconimage(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_iconimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_iconimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_coverimage(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_coverimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_coverimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_title(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_description(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_color(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_active(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_active(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_active(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_order(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Course_units(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units(ctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.UnitOrder), fc.Args["where"].(*ent.UnitWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UnitConnection)
	fc.Result = res
	return ec.marshalNUnitConnection2githubcomjhanaappjhanaappentUnitConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_units(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UnitConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UnitConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UnitConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnitConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Course_units_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Course_isStarted(ctx context.Context, field graphql.CollectedField, obj *ent.Course) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Course_isStarted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Course().IsStarted(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Course_isStarted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Course",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CourseConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.CourseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CourseConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CourseEdge)
	fc.Result = res
	return ec.marshalOCourseEdge2githubcomjhanaappjhanaappentCourseEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CourseConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CourseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_CourseEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_CourseEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CourseEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CourseConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.CourseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CourseConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CourseConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CourseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CourseConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.CourseConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CourseConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CourseConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CourseConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CourseEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.CourseEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CourseEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Course)
	fc.Result = res
	return ec.marshalOCourse2githubcomjhanaappjhanaappentCourse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CourseEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CourseEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Course_id(ctx, field)
			case "iconimage":
				return ec.fieldContext_Course_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Course_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Course_title(ctx, field)
			case "description":
				return ec.fieldContext_Course_description(ctx, field)
			case "color":
				return ec.fieldContext_Course_color(ctx, field)
			case "active":
				return ec.fieldContext_Course_active(ctx, field)
			case "order":
				return ec.fieldContext_Course_order(ctx, field)
			case "units":
				return ec.fieldContext_Course_units(ctx, field)
			case "isStarted":
				return ec.fieldContext_Course_isStarted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Course", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CourseEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.CourseEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CourseEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CourseEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CourseEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadContentEpisodeResult_success(ctx context.Context, field graphql.CollectedField, obj *DownloadContentEpisodeResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DownloadContentEpisodeResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DownloadContentEpisodeResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadContentEpisodeResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadContentResult_success(ctx context.Context, field graphql.CollectedField, obj *DownloadContentResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DownloadContentResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DownloadContentResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadContentResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadLessonResult_success(ctx context.Context, field graphql.CollectedField, obj *DownloadLessonResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DownloadLessonResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DownloadLessonResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadLessonResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadUnitResult_success(ctx context.Context, field graphql.CollectedField, obj *DownloadUnitResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DownloadUnitResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DownloadUnitResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadUnitResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinishContentEpisodeResult_episode(ctx context.Context, field graphql.CollectedField, obj *FinishContentEpisodeResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinishContentEpisodeResult_episode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Episode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinishContentEpisodeResult_episode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinishContentEpisodeResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinishContentEpisodeResult_nextEpisode(ctx context.Context, field graphql.CollectedField, obj *FinishContentEpisodeResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinishContentEpisodeResult_nextEpisode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextEpisode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalOContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinishContentEpisodeResult_nextEpisode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinishContentEpisodeResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinishLessonResult_lesson(ctx context.Context, field graphql.CollectedField, obj *FinishLessonResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinishLessonResult_lesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lesson, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinishLessonResult_lesson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinishLessonResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinishLessonResult_nextLesson(ctx context.Context, field graphql.CollectedField, obj *FinishLessonResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinishLessonResult_nextLesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextLesson, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinishLessonResult_nextLesson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinishLessonResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinishLessonResult_journalRecord(ctx context.Context, field graphql.CollectedField, obj *FinishLessonResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinishLessonResult_journalRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JournalRecord, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecord)
	fc.Result = res
	return ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinishLessonResult_journalRecord(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinishLessonResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_id(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JournalRecord().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_userID(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JournalRecord().UserID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_lessonID(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_lessonID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JournalRecord().LessonID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_lessonID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_datetime(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_datetime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_datetime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_duration(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_note(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_createdat(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_createdat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_createdat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_updatedat(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_updatedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_updatedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_user(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_lesson(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_lesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lesson(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_lesson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecord_unitColor(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecord_unitColor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.JournalRecord().UnitColor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecord_unitColor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecordConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecordConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecordConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.JournalRecordEdge)
	fc.Result = res
	return ec.marshalOJournalRecordEdge2githubcomjhanaappjhanaappentJournalRecordEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecordConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecordConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_JournalRecordEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_JournalRecordEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecordEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecordConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecordConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecordConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecordConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecordConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecordConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecordConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecordConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecordConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecordConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecordEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecordEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecordEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecord)
	fc.Result = res
	return ec.marshalOJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecordEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecordEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JournalRecordEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.JournalRecordEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JournalRecordEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JournalRecordEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JournalRecordEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_id(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_unitID(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_unitID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().UnitID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_unitID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_type(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.LessonType)
	fc.Result = res
	return ec.marshalNLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LessonLessonType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_iconimage(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_iconimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_iconimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_coverimage(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_coverimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_coverimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_title(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_description(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_order(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_unit(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_unit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_unit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_isLast(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_isLast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().IsLast(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_isLast(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_isNext(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_isNext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().IsNext(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_isNext(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_progress(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().Progress(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_finishedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_finishedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().FinishedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_finishedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_techniques(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_techniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().Techniques(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Technique)
	fc.Result = res
	return ec.marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_techniques(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technique_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Technique_unitID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Technique_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Technique_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Technique_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Technique_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Technique_description(ctx, field)
			case "order":
				return ec.fieldContext_Technique_order(ctx, field)
			case "unit":
				return ec.fieldContext_Technique_unit(ctx, field)
			case "lessons":
				return ec.fieldContext_Technique_lessons(ctx, field)
			case "techniques":
				return ec.fieldContext_Technique_techniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_lessonTechniques(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_lessonTechniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().LessonTechniques(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.LessonTechnique)
	fc.Result = res
	return ec.marshalNLessonTechnique2githubcomjhanaappjhanaappentLessonTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_lessonTechniques(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lessonId":
				return ec.fieldContext_LessonTechnique_lessonId(ctx, field)
			case "techniqueId":
				return ec.fieldContext_LessonTechnique_techniqueId(ctx, field)
			case "technique":
				return ec.fieldContext_LessonTechnique_technique(ctx, field)
			case "order":
				return ec.fieldContext_LessonTechnique_order(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LessonTechnique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lesson_audios(ctx context.Context, field graphql.CollectedField, obj *ent.Lesson) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lesson_audios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Lesson().Audios(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.LessonAudio)
	fc.Result = res
	return ec.marshalNLessonAudio2githubcomjhanaappjhanaappentLessonAudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lesson_audios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lesson",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LessonAudio_id(ctx, field)
			case "lessonID":
				return ec.fieldContext_LessonAudio_lessonID(ctx, field)
			case "audiourl":
				return ec.fieldContext_LessonAudio_audiourl(ctx, field)
			case "duration":
				return ec.fieldContext_LessonAudio_duration(ctx, field)
			case "lesson":
				return ec.fieldContext_LessonAudio_lesson(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LessonAudio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonAudio_id(ctx context.Context, field graphql.CollectedField, obj *ent.LessonAudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonAudio_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LessonAudio().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonAudio_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonAudio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonAudio_lessonID(ctx context.Context, field graphql.CollectedField, obj *ent.LessonAudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonAudio_lessonID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LessonAudio().LessonID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonAudio_lessonID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonAudio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonAudio_audiourl(ctx context.Context, field graphql.CollectedField, obj *ent.LessonAudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonAudio_audiourl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AudioURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonAudio_audiourl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonAudio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonAudio_duration(ctx context.Context, field graphql.CollectedField, obj *ent.LessonAudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonAudio_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonAudio_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonAudio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonAudio_lesson(ctx context.Context, field graphql.CollectedField, obj *ent.LessonAudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonAudio_lesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lesson(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonAudio_lesson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonAudio",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.LessonConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.LessonEdge)
	fc.Result = res
	return ec.marshalOLessonEdge2githubcomjhanaappjhanaappentLessonEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LessonEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LessonEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LessonEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.LessonConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.LessonConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.LessonEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.LessonEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonTechnique_lessonId(ctx context.Context, field graphql.CollectedField, obj *ent.LessonTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonTechnique_lessonId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LessonTechnique().LessonID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonTechnique_lessonId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonTechnique_techniqueId(ctx context.Context, field graphql.CollectedField, obj *ent.LessonTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonTechnique_techniqueId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LessonTechnique().TechniqueID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonTechnique_techniqueId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonTechnique_technique(ctx context.Context, field graphql.CollectedField, obj *ent.LessonTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonTechnique_technique(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LessonTechnique().Technique(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technique)
	fc.Result = res
	return ec.marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonTechnique_technique(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technique_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Technique_unitID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Technique_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Technique_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Technique_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Technique_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Technique_description(ctx, field)
			case "order":
				return ec.fieldContext_Technique_order(ctx, field)
			case "unit":
				return ec.fieldContext_Technique_unit(ctx, field)
			case "lessons":
				return ec.fieldContext_Technique_lessons(ctx, field)
			case "techniques":
				return ec.fieldContext_Technique_techniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LessonTechnique_order(ctx context.Context, field graphql.CollectedField, obj *ent.LessonTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LessonTechnique_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LessonTechnique_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LessonTechnique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MeditationsStats_hoursTotal(ctx context.Context, field graphql.CollectedField, obj *MeditationsStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MeditationsStats_hoursTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoursTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MeditationsStats_hoursTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MeditationsStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MeditationsStats_sessionsTotal(ctx context.Context, field graphql.CollectedField, obj *MeditationsStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MeditationsStats_sessionsTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SessionsTotal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MeditationsStats_sessionsTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MeditationsStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MeditationsStats_currentStrike(ctx context.Context, field graphql.CollectedField, obj *MeditationsStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MeditationsStats_currentStrike(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStrike, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MeditationsStats_currentStrike(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MeditationsStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MeditationsStats_lastMeditationDate(ctx context.Context, field graphql.CollectedField, obj *MeditationsStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MeditationsStats_lastMeditationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastMeditationDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MeditationsStats_lastMeditationDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MeditationsStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_signInWithEmailAndPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_signInWithEmailAndPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SignInWithEmailAndPassword(rctx, fc.Args["input"].(SignInWithEmailAndPasswordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SignInWithEmailAndPasswordResult)
	fc.Result = res
	return ec.marshalNSignInWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignInWithEmailAndPasswordResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_signInWithEmailAndPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accessToken":
				return ec.fieldContext_SignInWithEmailAndPasswordResult_accessToken(ctx, field)
			case "refreshToken":
				return ec.fieldContext_SignInWithEmailAndPasswordResult_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_SignInWithEmailAndPasswordResult_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignInWithEmailAndPasswordResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_signInWithEmailAndPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_signUpWithEmailAndPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_signUpWithEmailAndPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SignUpWithEmailAndPassword(rctx, fc.Args["input"].(SignUpWithEmailAndPasswordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SignUpWithEmailAndPasswordResult)
	fc.Result = res
	return ec.marshalNSignUpWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignUpWithEmailAndPasswordResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_signUpWithEmailAndPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accessToken":
				return ec.fieldContext_SignUpWithEmailAndPasswordResult_accessToken(ctx, field)
			case "refreshToken":
				return ec.fieldContext_SignUpWithEmailAndPasswordResult_refreshToken(ctx, field)
			case "user":
				return ec.fieldContext_SignUpWithEmailAndPasswordResult_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SignUpWithEmailAndPasswordResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_signUpWithEmailAndPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshToken(rctx, fc.Args["input"].(RefreshTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RefreshTokenResult)
	fc.Result = res
	return ec.marshalNRefreshTokenResult2githubcomjhanaappjhanaappgqlRefreshTokenResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accessToken":
				return ec.fieldContext_RefreshTokenResult_accessToken(ctx, field)
			case "refreshToken":
				return ec.fieldContext_RefreshTokenResult_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RefreshTokenResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_signOut(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_signOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SignOut(rctx, fc.Args["input"].(SignOutInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_signOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_signOut_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_downloadUnit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_downloadUnit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DownloadUnit(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(DownloadUnitInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DownloadUnitResult)
	fc.Result = res
	return ec.marshalNDownloadUnitResult2githubcomjhanaappjhanaappgqlDownloadUnitResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_downloadUnit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DownloadUnitResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DownloadUnitResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_downloadUnit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetUnitProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetUnitProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetUnitProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(ResetUnitProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetUnitProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetUnitProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveLessonProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveLessonProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveLessonProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(SaveLessonProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveLessonProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveLessonProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_downloadLesson(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_downloadLesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DownloadLesson(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(DownloadLessonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DownloadLessonResult)
	fc.Result = res
	return ec.marshalNDownloadLessonResult2githubcomjhanaappjhanaappgqlDownloadLessonResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_downloadLesson(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DownloadLessonResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DownloadLessonResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_downloadLesson_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetLessonProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetLessonProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetLessonProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(ResetLessonProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetLessonProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetLessonProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishLesson(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishLesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishLesson(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(FinishLessonInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FinishLessonResult)
	fc.Result = res
	return ec.marshalNFinishLessonResult2githubcomjhanaappjhanaappgqlFinishLessonResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishLesson(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lesson":
				return ec.fieldContext_FinishLessonResult_lesson(ctx, field)
			case "nextLesson":
				return ec.fieldContext_FinishLessonResult_nextLesson(ctx, field)
			case "journalRecord":
				return ec.fieldContext_FinishLessonResult_journalRecord(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinishLessonResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishLesson_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_downloadContent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_downloadContent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DownloadContent(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(DownloadContentInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DownloadContentResult)
	fc.Result = res
	return ec.marshalNDownloadContentResult2githubcomjhanaappjhanaappgqlDownloadContentResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_downloadContent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DownloadContentResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DownloadContentResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_downloadContent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetContentProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetContentProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetContentProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(ResetContentProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Content)
	fc.Result = res
	return ec.marshalNContent2githubcomjhanaappjhanaappentContent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetContentProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Content_id(ctx, field)
			case "type":
				return ec.fieldContext_Content_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Content_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Content_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Content_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Content_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Content_description(ctx, field)
			case "source":
				return ec.fieldContext_Content_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_Content_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_Content_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_Content_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_Content_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_Content_order(ctx, field)
			case "episodescount":
				return ec.fieldContext_Content_episodescount(ctx, field)
			case "episodes":
				return ec.fieldContext_Content_episodes(ctx, field)
			case "singleEpisode":
				return ec.fieldContext_Content_singleEpisode(ctx, field)
			case "episodesList":
				return ec.fieldContext_Content_episodesList(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Content", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetContentProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveContentEpisodeProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveContentEpisodeProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveContentEpisodeProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(SaveContentEpisodeProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveContentEpisodeProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveContentEpisodeProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_downloadContentEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_downloadContentEpisode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DownloadContentEpisode(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(DownloadContentEpisodeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DownloadContentEpisodeResult)
	fc.Result = res
	return ec.marshalNDownloadContentEpisodeResult2githubcomjhanaappjhanaappgqlDownloadContentEpisodeResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_downloadContentEpisode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_DownloadContentEpisodeResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DownloadContentEpisodeResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_downloadContentEpisode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetContentEpisodeProgress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetContentEpisodeProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetContentEpisodeProgress(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(ResetContentEpisodeProgressInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetContentEpisodeProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetContentEpisodeProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_finishContentEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_finishContentEpisode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FinishContentEpisode(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(FinishContentEpisodeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*FinishContentEpisodeResult)
	fc.Result = res
	return ec.marshalNFinishContentEpisodeResult2githubcomjhanaappjhanaappgqlFinishContentEpisodeResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_finishContentEpisode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "episode":
				return ec.fieldContext_FinishContentEpisodeResult_episode(ctx, field)
			case "nextEpisode":
				return ec.fieldContext_FinishContentEpisodeResult_nextEpisode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinishContentEpisodeResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_finishContentEpisode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createJournalRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createJournalRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateJournalRecord(rctx, fc.Args["input"].(CreateJournalRecordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecord)
	fc.Result = res
	return ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createJournalRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createJournalRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateJournalRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateJournalRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateJournalRecord(rctx, fc.Args["id"].(gqlid.Base64ID), fc.Args["input"].(UpdateJournalRecordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecord)
	fc.Result = res
	return ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateJournalRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateJournalRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteJournalRecord(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteJournalRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteJournalRecord(rctx, fc.Args["id"].(gqlid.Base64ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecord)
	fc.Result = res
	return ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteJournalRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteJournalRecord_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(gqlid.Base64ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomjhanaappjhanaappentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]*gqlid.Base64ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2githubcomjhanaappjhanaappentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_contents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Contents(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ContentOrder), fc.Args["where"].(*ent.ContentWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentConnection)
	fc.Result = res
	return ec.marshalNContentConnection2githubcomjhanaappjhanaappentContentConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ContentConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ContentConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ContentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_contents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_contentEpisodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_contentEpisodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ContentEpisodes(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ContentEpisodeOrder), fc.Args["where"].(*ent.ContentEpisodeWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisodeConnection)
	fc.Result = res
	return ec.marshalNContentEpisodeConnection2githubcomjhanaappjhanaappentContentEpisodeConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_contentEpisodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ContentEpisodeConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ContentEpisodeConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ContentEpisodeConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisodeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_contentEpisodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_courses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_courses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Courses(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.CourseOrder), fc.Args["where"].(*ent.CourseWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.CourseConnection)
	fc.Result = res
	return ec.marshalNCourseConnection2githubcomjhanaappjhanaappentCourseConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_courses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CourseConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CourseConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CourseConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CourseConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_courses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_journalRecords(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_journalRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().JournalRecords(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.JournalRecordOrder), fc.Args["where"].(*ent.JournalRecordWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.JournalRecordConnection)
	fc.Result = res
	return ec.marshalNJournalRecordConnection2githubcomjhanaappjhanaappentJournalRecordConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_journalRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_JournalRecordConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_JournalRecordConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_JournalRecordConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecordConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_journalRecords_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_lessons(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_lessons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Lessons(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.LessonOrder), fc.Args["where"].(*ent.LessonWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LessonConnection)
	fc.Result = res
	return ec.marshalNLessonConnection2githubcomjhanaappjhanaappentLessonConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_lessons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LessonConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LessonConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LessonConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LessonConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_lessons_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_techniques(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_techniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Techniques(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.TechniqueOrder), fc.Args["where"].(*ent.TechniqueWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TechniqueConnection)
	fc.Result = res
	return ec.marshalNTechniqueConnection2githubcomjhanaappjhanaappentTechniqueConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_techniques(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TechniqueConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TechniqueConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TechniqueConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechniqueConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_techniques_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_units(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Units(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.UnitOrder), fc.Args["where"].(*ent.UnitWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UnitConnection)
	fc.Result = res
	return ec.marshalNUnitConnection2githubcomjhanaappjhanaappentUnitConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_units(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UnitConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UnitConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UnitConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnitConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_units_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeEpisodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeEpisodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveEpisodes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeEpisodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeEpisode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveEpisode(rctx, fc.Args["contentId"].(gqlid.Base64ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ContentEpisode)
	fc.Result = res
	return ec.marshalOContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeEpisode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContentEpisode_id(ctx, field)
			case "contentID":
				return ec.fieldContext_ContentEpisode_contentID(ctx, field)
			case "type":
				return ec.fieldContext_ContentEpisode_type(ctx, field)
			case "title":
				return ec.fieldContext_ContentEpisode_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_ContentEpisode_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_ContentEpisode_description(ctx, field)
			case "duration":
				return ec.fieldContext_ContentEpisode_duration(ctx, field)
			case "streamurl":
				return ec.fieldContext_ContentEpisode_streamurl(ctx, field)
			case "downloadurl":
				return ec.fieldContext_ContentEpisode_downloadurl(ctx, field)
			case "source":
				return ec.fieldContext_ContentEpisode_source(ctx, field)
			case "sourceurl":
				return ec.fieldContext_ContentEpisode_sourceurl(ctx, field)
			case "licence":
				return ec.fieldContext_ContentEpisode_licence(ctx, field)
			case "licenceurl":
				return ec.fieldContext_ContentEpisode_licenceurl(ctx, field)
			case "ishidden":
				return ec.fieldContext_ContentEpisode_ishidden(ctx, field)
			case "order":
				return ec.fieldContext_ContentEpisode_order(ctx, field)
			case "content":
				return ec.fieldContext_ContentEpisode_content(ctx, field)
			case "progress":
				return ec.fieldContext_ContentEpisode_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_ContentEpisode_finishedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContentEpisode", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_activeEpisode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_weekStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_weekStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WeekStats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.JournalRecord)
	fc.Result = res
	return ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_weekStats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JournalRecord_id(ctx, field)
			case "userID":
				return ec.fieldContext_JournalRecord_userID(ctx, field)
			case "lessonID":
				return ec.fieldContext_JournalRecord_lessonID(ctx, field)
			case "datetime":
				return ec.fieldContext_JournalRecord_datetime(ctx, field)
			case "duration":
				return ec.fieldContext_JournalRecord_duration(ctx, field)
			case "note":
				return ec.fieldContext_JournalRecord_note(ctx, field)
			case "createdat":
				return ec.fieldContext_JournalRecord_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_JournalRecord_updatedat(ctx, field)
			case "user":
				return ec.fieldContext_JournalRecord_user(ctx, field)
			case "lesson":
				return ec.fieldContext_JournalRecord_lesson(ctx, field)
			case "unitColor":
				return ec.fieldContext_JournalRecord_unitColor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JournalRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_activeLessons(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_activeLessons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ActiveLessons(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Lesson)
	fc.Result = res
	return ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_activeLessons(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_meditationsStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_meditationsStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MeditationsStats(rctx, fc.Args["input"].(MeditationsStatsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*MeditationsStats)
	fc.Result = res
	return ec.marshalNMeditationsStats2githubcomjhanaappjhanaappgqlMeditationsStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_meditationsStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hoursTotal":
				return ec.fieldContext_MeditationsStats_hoursTotal(ctx, field)
			case "sessionsTotal":
				return ec.fieldContext_MeditationsStats_sessionsTotal(ctx, field)
			case "currentStrike":
				return ec.fieldContext_MeditationsStats_currentStrike(ctx, field)
			case "lastMeditationDate":
				return ec.fieldContext_MeditationsStats_lastMeditationDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MeditationsStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_meditationsStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshTokenResult_accessToken(ctx context.Context, field graphql.CollectedField, obj *RefreshTokenResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshTokenResult_accessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshTokenResult_accessToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshTokenResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshTokenResult_refreshToken(ctx context.Context, field graphql.CollectedField, obj *RefreshTokenResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshTokenResult_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshTokenResult_refreshToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshTokenResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignInWithEmailAndPasswordResult_accessToken(ctx context.Context, field graphql.CollectedField, obj *SignInWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignInWithEmailAndPasswordResult_accessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignInWithEmailAndPasswordResult_accessToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignInWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignInWithEmailAndPasswordResult_refreshToken(ctx context.Context, field graphql.CollectedField, obj *SignInWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignInWithEmailAndPasswordResult_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignInWithEmailAndPasswordResult_refreshToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignInWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignInWithEmailAndPasswordResult_user(ctx context.Context, field graphql.CollectedField, obj *SignInWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignInWithEmailAndPasswordResult_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignInWithEmailAndPasswordResult_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignInWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignUpWithEmailAndPasswordResult_accessToken(ctx context.Context, field graphql.CollectedField, obj *SignUpWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignUpWithEmailAndPasswordResult_accessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignUpWithEmailAndPasswordResult_accessToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignUpWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignUpWithEmailAndPasswordResult_refreshToken(ctx context.Context, field graphql.CollectedField, obj *SignUpWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignUpWithEmailAndPasswordResult_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignUpWithEmailAndPasswordResult_refreshToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignUpWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SignUpWithEmailAndPasswordResult_user(ctx context.Context, field graphql.CollectedField, obj *SignUpWithEmailAndPasswordResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SignUpWithEmailAndPasswordResult_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SignUpWithEmailAndPasswordResult_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SignUpWithEmailAndPasswordResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_id(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Technique().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_unitID(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_unitID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Technique().UnitID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_unitID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_iconimage(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_iconimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_iconimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_coverimage(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_coverimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_coverimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_title(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_subtitle(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_subtitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_subtitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_description(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_order(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_unit(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_unit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_unit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_lessons(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_lessons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lessons(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Lesson)
	fc.Result = res
	return ec.marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_lessons(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Technique_techniques(ctx context.Context, field graphql.CollectedField, obj *ent.Technique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Technique_techniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Techniques(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Unit)
	fc.Result = res
	return ec.marshalOUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Technique_techniques(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Technique",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechniqueConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TechniqueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechniqueConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TechniqueEdge)
	fc.Result = res
	return ec.marshalOTechniqueEdge2githubcomjhanaappjhanaappentTechniqueEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechniqueConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechniqueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TechniqueEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TechniqueEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TechniqueEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechniqueConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TechniqueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechniqueConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechniqueConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechniqueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechniqueConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TechniqueConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechniqueConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechniqueConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechniqueConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechniqueEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TechniqueEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechniqueEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Technique)
	fc.Result = res
	return ec.marshalOTechnique2githubcomjhanaappjhanaappentTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechniqueEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechniqueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technique_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Technique_unitID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Technique_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Technique_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Technique_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Technique_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Technique_description(ctx, field)
			case "order":
				return ec.fieldContext_Technique_order(ctx, field)
			case "unit":
				return ec.fieldContext_Technique_unit(ctx, field)
			case "lessons":
				return ec.fieldContext_Technique_lessons(ctx, field)
			case "techniques":
				return ec.fieldContext_Technique_techniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TechniqueEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TechniqueEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TechniqueEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TechniqueEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TechniqueEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_id(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_courseID(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_courseID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().CourseID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_courseID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_iconimage(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_iconimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_iconimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_coverimage(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_coverimage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoverImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_coverimage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_title(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_subtitle(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_subtitle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_subtitle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_description(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_mastering(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_mastering(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mastering, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_mastering(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_days(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_days(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Days, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_days(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_color(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_order(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_course(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_course(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Course(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Course)
	fc.Result = res
	return ec.marshalNCourse2githubcomjhanaappjhanaappentCourse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_course(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Course_id(ctx, field)
			case "iconimage":
				return ec.fieldContext_Course_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Course_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Course_title(ctx, field)
			case "description":
				return ec.fieldContext_Course_description(ctx, field)
			case "color":
				return ec.fieldContext_Course_color(ctx, field)
			case "active":
				return ec.fieldContext_Course_active(ctx, field)
			case "order":
				return ec.fieldContext_Course_order(ctx, field)
			case "units":
				return ec.fieldContext_Course_units(ctx, field)
			case "isStarted":
				return ec.fieldContext_Course_isStarted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Course", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_lessons(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_lessons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lessons(ctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.LessonOrder), fc.Args["where"].(*ent.LessonWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LessonConnection)
	fc.Result = res
	return ec.marshalNLessonConnection2githubcomjhanaappjhanaappentLessonConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_lessons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LessonConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LessonConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LessonConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LessonConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Unit_lessons_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Unit_lessonsTotal(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_lessonsTotal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().LessonsTotal(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_lessonsTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_lessonsCompleted(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_lessonsCompleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().LessonsCompleted(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_lessonsCompleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_isActive(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().IsActive(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_isActive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_nextUnit(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_nextUnit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().NextUnit(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalOUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_nextUnit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_techniques(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_techniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().Techniques(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Technique)
	fc.Result = res
	return ec.marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_techniques(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technique_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Technique_unitID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Technique_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Technique_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Technique_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Technique_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Technique_description(ctx, field)
			case "order":
				return ec.fieldContext_Technique_order(ctx, field)
			case "unit":
				return ec.fieldContext_Technique_unit(ctx, field)
			case "lessons":
				return ec.fieldContext_Technique_lessons(ctx, field)
			case "techniques":
				return ec.fieldContext_Technique_techniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Unit_unitTechniques(ctx context.Context, field graphql.CollectedField, obj *ent.Unit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Unit_unitTechniques(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Unit().UnitTechniques(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.UnitTechnique)
	fc.Result = res
	return ec.marshalNUnitTechnique2githubcomjhanaappjhanaappentUnitTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Unit_unitTechniques(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Unit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unitId":
				return ec.fieldContext_UnitTechnique_unitId(ctx, field)
			case "techniqueId":
				return ec.fieldContext_UnitTechnique_techniqueId(ctx, field)
			case "technique":
				return ec.fieldContext_UnitTechnique_technique(ctx, field)
			case "position":
				return ec.fieldContext_UnitTechnique_position(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnitTechnique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.UnitConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.UnitEdge)
	fc.Result = res
	return ec.marshalOUnitEdge2githubcomjhanaappjhanaappentUnitEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UnitEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UnitEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UnitEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.UnitConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.UnitConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.UnitEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalOUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.UnitEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitTechnique_unitId(ctx context.Context, field graphql.CollectedField, obj *ent.UnitTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitTechnique_unitId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnitTechnique().UnitID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitTechnique_unitId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitTechnique_techniqueId(ctx context.Context, field graphql.CollectedField, obj *ent.UnitTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitTechnique_techniqueId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnitTechnique().TechniqueID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitTechnique_techniqueId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitTechnique_technique(ctx context.Context, field graphql.CollectedField, obj *ent.UnitTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitTechnique_technique(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnitTechnique().Technique(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Technique)
	fc.Result = res
	return ec.marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitTechnique_technique(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitTechnique",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Technique_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Technique_unitID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Technique_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Technique_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Technique_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Technique_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Technique_description(ctx, field)
			case "order":
				return ec.fieldContext_Technique_order(ctx, field)
			case "unit":
				return ec.fieldContext_Technique_unit(ctx, field)
			case "lessons":
				return ec.fieldContext_Technique_lessons(ctx, field)
			case "techniques":
				return ec.fieldContext_Technique_techniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Technique", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnitTechnique_position(ctx context.Context, field graphql.CollectedField, obj *ent.UnitTechnique) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnitTechnique_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnitTechnique_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnitTechnique",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_firebaseuid(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_firebaseuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirebaseUid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_firebaseuid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayname(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdat(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedat(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_authMethod(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_authMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.AuthMethod)
	fc.Result = res
	return ec.marshalNUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_authMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserAuthMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailVerified(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_emailVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_emailVerified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserProgress().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_userID(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserProgress().UserID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_courseID(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_courseID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserProgress().CourseID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_courseID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_unitID(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_unitID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserProgress().UnitID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_unitID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_lessonID(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_lessonID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserProgress().LessonID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlid.Base64ID)
	fc.Result = res
	return ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_lessonID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_lessonType(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_lessonType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LessonType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(property.LessonType)
	fc.Result = res
	return ec.marshalNUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_lessonType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserProgressLessonType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_islast(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_islast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLast, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_islast(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_isnext(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_isnext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsNext, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_isnext(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_progress(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_finishedat(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_finishedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_finishedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_createdat(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_createdat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_createdat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_updatedat(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_updatedat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_updatedat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomjhanaappjhanaappentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firebaseuid":
				return ec.fieldContext_User_firebaseuid(ctx, field)
			case "displayname":
				return ec.fieldContext_User_displayname(ctx, field)
			case "createdat":
				return ec.fieldContext_User_createdat(ctx, field)
			case "updatedat":
				return ec.fieldContext_User_updatedat(ctx, field)
			case "authMethod":
				return ec.fieldContext_User_authMethod(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "emailVerified":
				return ec.fieldContext_User_emailVerified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_course(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_course(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Course(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Course)
	fc.Result = res
	return ec.marshalNCourse2githubcomjhanaappjhanaappentCourse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_course(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Course_id(ctx, field)
			case "iconimage":
				return ec.fieldContext_Course_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Course_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Course_title(ctx, field)
			case "description":
				return ec.fieldContext_Course_description(ctx, field)
			case "color":
				return ec.fieldContext_Course_color(ctx, field)
			case "active":
				return ec.fieldContext_Course_active(ctx, field)
			case "order":
				return ec.fieldContext_Course_order(ctx, field)
			case "units":
				return ec.fieldContext_Course_units(ctx, field)
			case "isStarted":
				return ec.fieldContext_Course_isStarted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Course", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_unit(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_unit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Unit)
	fc.Result = res
	return ec.marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_unit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Unit_id(ctx, field)
			case "courseID":
				return ec.fieldContext_Unit_courseID(ctx, field)
			case "iconimage":
				return ec.fieldContext_Unit_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Unit_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Unit_title(ctx, field)
			case "subtitle":
				return ec.fieldContext_Unit_subtitle(ctx, field)
			case "description":
				return ec.fieldContext_Unit_description(ctx, field)
			case "mastering":
				return ec.fieldContext_Unit_mastering(ctx, field)
			case "days":
				return ec.fieldContext_Unit_days(ctx, field)
			case "color":
				return ec.fieldContext_Unit_color(ctx, field)
			case "order":
				return ec.fieldContext_Unit_order(ctx, field)
			case "course":
				return ec.fieldContext_Unit_course(ctx, field)
			case "lessons":
				return ec.fieldContext_Unit_lessons(ctx, field)
			case "lessonsTotal":
				return ec.fieldContext_Unit_lessonsTotal(ctx, field)
			case "lessonsCompleted":
				return ec.fieldContext_Unit_lessonsCompleted(ctx, field)
			case "isActive":
				return ec.fieldContext_Unit_isActive(ctx, field)
			case "nextUnit":
				return ec.fieldContext_Unit_nextUnit(ctx, field)
			case "techniques":
				return ec.fieldContext_Unit_techniques(ctx, field)
			case "unitTechniques":
				return ec.fieldContext_Unit_unitTechniques(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Unit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserProgress_lesson(ctx context.Context, field graphql.CollectedField, obj *ent.UserProgress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserProgress_lesson(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lesson(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Lesson)
	fc.Result = res
	return ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserProgress_lesson(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserProgress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Lesson_id(ctx, field)
			case "unitID":
				return ec.fieldContext_Lesson_unitID(ctx, field)
			case "type":
				return ec.fieldContext_Lesson_type(ctx, field)
			case "iconimage":
				return ec.fieldContext_Lesson_iconimage(ctx, field)
			case "coverimage":
				return ec.fieldContext_Lesson_coverimage(ctx, field)
			case "title":
				return ec.fieldContext_Lesson_title(ctx, field)
			case "description":
				return ec.fieldContext_Lesson_description(ctx, field)
			case "order":
				return ec.fieldContext_Lesson_order(ctx, field)
			case "unit":
				return ec.fieldContext_Lesson_unit(ctx, field)
			case "isLast":
				return ec.fieldContext_Lesson_isLast(ctx, field)
			case "isNext":
				return ec.fieldContext_Lesson_isNext(ctx, field)
			case "progress":
				return ec.fieldContext_Lesson_progress(ctx, field)
			case "finishedAt":
				return ec.fieldContext_Lesson_finishedAt(ctx, field)
			case "techniques":
				return ec.fieldContext_Lesson_techniques(ctx, field)
			case "lessonTechniques":
				return ec.fieldContext_Lesson_lessonTechniques(ctx, field)
			case "audios":
				return ec.fieldContext_Lesson_audios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lesson", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputContentEpisodeOrder(ctx context.Context, obj interface{}) (ent.ContentEpisodeOrder, error) {
	var it ent.ContentEpisodeOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNContentEpisodeOrderField2githubcomjhanaappjhanaappentContentEpisodeOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContentEpisodeWhereInput(ctx context.Context, obj interface{}) (ent.ContentEpisodeWhereInput, error) {
	var it ent.ContentEpisodeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "contentID", "contentIDNEQ", "contentIDIn", "contentIDNotIn", "type", "typeNEQ", "typeIn", "typeNotIn", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "subtitle", "subtitleNEQ", "subtitleIn", "subtitleNotIn", "subtitleGT", "subtitleGTE", "subtitleLT", "subtitleLTE", "subtitleContains", "subtitleHasPrefix", "subtitleHasSuffix", "subtitleEqualFold", "subtitleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "duration", "durationNEQ", "durationIn", "durationNotIn", "durationGT", "durationGTE", "durationLT", "durationLTE", "streamurl", "streamurlNEQ", "streamurlIn", "streamurlNotIn", "streamurlGT", "streamurlGTE", "streamurlLT", "streamurlLTE", "streamurlContains", "streamurlHasPrefix", "streamurlHasSuffix", "streamurlEqualFold", "streamurlContainsFold", "downloadurl", "downloadurlNEQ", "downloadurlIn", "downloadurlNotIn", "downloadurlGT", "downloadurlGTE", "downloadurlLT", "downloadurlLTE", "downloadurlContains", "downloadurlHasPrefix", "downloadurlHasSuffix", "downloadurlEqualFold", "downloadurlContainsFold", "source", "sourceNEQ", "sourceIn", "sourceNotIn", "sourceGT", "sourceGTE", "sourceLT", "sourceLTE", "sourceContains", "sourceHasPrefix", "sourceHasSuffix", "sourceEqualFold", "sourceContainsFold", "sourceurl", "sourceurlNEQ", "sourceurlIn", "sourceurlNotIn", "sourceurlGT", "sourceurlGTE", "sourceurlLT", "sourceurlLTE", "sourceurlContains", "sourceurlHasPrefix", "sourceurlHasSuffix", "sourceurlEqualFold", "sourceurlContainsFold", "licence", "licenceNEQ", "licenceIn", "licenceNotIn", "licenceGT", "licenceGTE", "licenceLT", "licenceLTE", "licenceContains", "licenceHasPrefix", "licenceHasSuffix", "licenceEqualFold", "licenceContainsFold", "licenceurl", "licenceurlNEQ", "licenceurlIn", "licenceurlNotIn", "licenceurlGT", "licenceurlGTE", "licenceurlLT", "licenceurlLTE", "licenceurlContains", "licenceurlHasPrefix", "licenceurlHasSuffix", "licenceurlEqualFold", "licenceurlContainsFold", "ishidden", "ishiddenNEQ", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "hasContent", "hasContentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().ContentID(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().ContentIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().ContentIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentEpisodeWhereInput().ContentIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "subtitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtitle = data
		case "subtitleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNEQ = data
		case "subtitleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleIn = data
		case "subtitleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNotIn = data
		case "subtitleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGT = data
		case "subtitleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGTE = data
		case "subtitleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLT = data
		case "subtitleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLTE = data
		case "subtitleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContains = data
		case "subtitleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasPrefix = data
		case "subtitleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasSuffix = data
		case "subtitleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleEqualFold = data
		case "subtitleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "durationNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNEQ = data
		case "durationIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationIn = data
		case "durationNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNotIn = data
		case "durationGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGT = data
		case "durationGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGTE = data
		case "durationLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLT = data
		case "durationLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLTE = data
		case "streamurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURL = data
		case "streamurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLNEQ = data
		case "streamurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLIn = data
		case "streamurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLNotIn = data
		case "streamurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLGT = data
		case "streamurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLGTE = data
		case "streamurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLLT = data
		case "streamurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLLTE = data
		case "streamurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLContains = data
		case "streamurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLHasPrefix = data
		case "streamurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLHasSuffix = data
		case "streamurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLEqualFold = data
		case "streamurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("streamurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StreamURLContainsFold = data
		case "downloadurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURL = data
		case "downloadurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLNEQ = data
		case "downloadurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLIn = data
		case "downloadurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLNotIn = data
		case "downloadurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLGT = data
		case "downloadurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLGTE = data
		case "downloadurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLLT = data
		case "downloadurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLLTE = data
		case "downloadurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLContains = data
		case "downloadurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLHasPrefix = data
		case "downloadurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLHasSuffix = data
		case "downloadurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLEqualFold = data
		case "downloadurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadURLContainsFold = data
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "sourceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceNEQ = data
		case "sourceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceIn = data
		case "sourceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceNotIn = data
		case "sourceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceGT = data
		case "sourceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceGTE = data
		case "sourceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLT = data
		case "sourceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLTE = data
		case "sourceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceContains = data
		case "sourceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceHasPrefix = data
		case "sourceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceHasSuffix = data
		case "sourceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceEqualFold = data
		case "sourceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceContainsFold = data
		case "sourceurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "sourceurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLNEQ = data
		case "sourceurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLIn = data
		case "sourceurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLNotIn = data
		case "sourceurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLGT = data
		case "sourceurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLGTE = data
		case "sourceurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLLT = data
		case "sourceurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLLTE = data
		case "sourceurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLContains = data
		case "sourceurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLHasPrefix = data
		case "sourceurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLHasSuffix = data
		case "sourceurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLEqualFold = data
		case "sourceurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLContainsFold = data
		case "licence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licence"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Licence = data
		case "licenceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceNEQ = data
		case "licenceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceIn = data
		case "licenceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceNotIn = data
		case "licenceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceGT = data
		case "licenceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceGTE = data
		case "licenceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceLT = data
		case "licenceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceLTE = data
		case "licenceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceContains = data
		case "licenceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceHasPrefix = data
		case "licenceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceHasSuffix = data
		case "licenceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceEqualFold = data
		case "licenceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceContainsFold = data
		case "licenceurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURL = data
		case "licenceurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLNEQ = data
		case "licenceurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLIn = data
		case "licenceurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLNotIn = data
		case "licenceurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLGT = data
		case "licenceurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLGTE = data
		case "licenceurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLLT = data
		case "licenceurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLLTE = data
		case "licenceurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLContains = data
		case "licenceurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLHasPrefix = data
		case "licenceurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLHasSuffix = data
		case "licenceurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLEqualFold = data
		case "licenceurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLContainsFold = data
		case "ishidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ishidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHidden = data
		case "ishiddenNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ishiddenNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHiddenNEQ = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "hasContent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContent"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasContent = data
		case "hasContentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContentWith"))
			data, err := ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasContentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContentOrder(ctx context.Context, obj interface{}) (ent.ContentOrder, error) {
	var it ent.ContentOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNContentOrderField2githubcomjhanaappjhanaappentContentOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContentProgressWhereInput(ctx context.Context, obj interface{}) (ent.ContentProgressWhereInput, error) {
	var it ent.ContentProgressWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "contentID", "contentIDNEQ", "contentIDIn", "contentIDNotIn", "episodeID", "episodeIDNEQ", "episodeIDIn", "episodeIDNotIn", "contentType", "contentTypeNEQ", "contentTypeIn", "contentTypeNotIn", "progress", "progressNEQ", "progressIn", "progressNotIn", "progressGT", "progressGTE", "progressLT", "progressLTE", "finishedat", "finishedatNEQ", "finishedatIn", "finishedatNotIn", "finishedatGT", "finishedatGTE", "finishedatLT", "finishedatLTE", "finishedatIsNil", "finishedatNotNil", "createdat", "createdatNEQ", "createdatIn", "createdatNotIn", "createdatGT", "createdatGTE", "createdatLT", "createdatLTE", "updatedat", "updatedatNEQ", "updatedatIn", "updatedatNotIn", "updatedatGT", "updatedatGTE", "updatedatLT", "updatedatLTE", "hasUser", "hasUserWith", "hasContent", "hasContentWith", "hasEpisode", "hasEpisodeWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().UserID(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().UserIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().UserIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().UserIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().ContentID(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().ContentIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().ContentIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().ContentIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "episodeID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodeID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().EpisodeID(ctx, &it, data); err != nil {
				return it, err
			}
		case "episodeIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodeIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().EpisodeIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "episodeIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodeIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().EpisodeIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "episodeIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodeIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentProgressWhereInput().EpisodeIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "contentType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentType"))
			data, err := ec.unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentType = data
		case "contentTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeNEQ"))
			data, err := ec.unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentTypeNEQ = data
		case "contentTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeIn"))
			data, err := ec.unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentTypeIn = data
		case "contentTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentTypeNotIn"))
			data, err := ec.unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContentTypeNotIn = data
		case "progress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progress"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Progress = data
		case "progressNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNEQ = data
		case "progressIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressIn = data
		case "progressNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNotIn = data
		case "progressGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGT = data
		case "progressGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGTE = data
		case "progressLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLT = data
		case "progressLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLTE = data
		case "finishedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAt = data
		case "finishedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNEQ = data
		case "finishedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtIn = data
		case "finishedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNotIn = data
		case "finishedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtGT = data
		case "finishedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtGTE = data
		case "finishedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtLT = data
		case "finishedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtLTE = data
		case "finishedatIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtIsNil = data
		case "finishedatNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNotNil = data
		case "createdat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasContent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContent"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasContent = data
		case "hasContentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasContentWith"))
			data, err := ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasContentWith = data
		case "hasEpisode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEpisode"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEpisode = data
		case "hasEpisodeWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEpisodeWith"))
			data, err := ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEpisodeWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContentWhereInput(ctx context.Context, obj interface{}) (ent.ContentWhereInput, error) {
	var it ent.ContentWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "iconimage", "iconimageNEQ", "iconimageIn", "iconimageNotIn", "iconimageGT", "iconimageGTE", "iconimageLT", "iconimageLTE", "iconimageContains", "iconimageHasPrefix", "iconimageHasSuffix", "iconimageEqualFold", "iconimageContainsFold", "coverimage", "coverimageNEQ", "coverimageIn", "coverimageNotIn", "coverimageGT", "coverimageGTE", "coverimageLT", "coverimageLTE", "coverimageContains", "coverimageHasPrefix", "coverimageHasSuffix", "coverimageEqualFold", "coverimageContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "subtitle", "subtitleNEQ", "subtitleIn", "subtitleNotIn", "subtitleGT", "subtitleGTE", "subtitleLT", "subtitleLTE", "subtitleContains", "subtitleHasPrefix", "subtitleHasSuffix", "subtitleEqualFold", "subtitleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "source", "sourceNEQ", "sourceIn", "sourceNotIn", "sourceGT", "sourceGTE", "sourceLT", "sourceLTE", "sourceContains", "sourceHasPrefix", "sourceHasSuffix", "sourceEqualFold", "sourceContainsFold", "sourceurl", "sourceurlNEQ", "sourceurlIn", "sourceurlNotIn", "sourceurlGT", "sourceurlGTE", "sourceurlLT", "sourceurlLTE", "sourceurlContains", "sourceurlHasPrefix", "sourceurlHasSuffix", "sourceurlEqualFold", "sourceurlContainsFold", "licence", "licenceNEQ", "licenceIn", "licenceNotIn", "licenceGT", "licenceGTE", "licenceLT", "licenceLTE", "licenceContains", "licenceHasPrefix", "licenceHasSuffix", "licenceEqualFold", "licenceContainsFold", "licenceurl", "licenceurlNEQ", "licenceurlIn", "licenceurlNotIn", "licenceurlGT", "licenceurlGTE", "licenceurlLT", "licenceurlLTE", "licenceurlContains", "licenceurlHasPrefix", "licenceurlHasSuffix", "licenceurlEqualFold", "licenceurlContainsFold", "ishidden", "ishiddenNEQ", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "episodescount", "episodescountNEQ", "episodescountIn", "episodescountNotIn", "episodescountGT", "episodescountGTE", "episodescountLT", "episodescountLTE", "hasEpisodes", "hasEpisodesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContentWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "iconimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImage = data
		case "iconimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNEQ = data
		case "iconimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageIn = data
		case "iconimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNotIn = data
		case "iconimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGT = data
		case "iconimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGTE = data
		case "iconimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLT = data
		case "iconimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLTE = data
		case "iconimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContains = data
		case "iconimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasPrefix = data
		case "iconimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasSuffix = data
		case "iconimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageEqualFold = data
		case "iconimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContainsFold = data
		case "coverimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImage = data
		case "coverimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNEQ = data
		case "coverimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageIn = data
		case "coverimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNotIn = data
		case "coverimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGT = data
		case "coverimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGTE = data
		case "coverimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLT = data
		case "coverimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLTE = data
		case "coverimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContains = data
		case "coverimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasPrefix = data
		case "coverimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasSuffix = data
		case "coverimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageEqualFold = data
		case "coverimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "subtitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtitle = data
		case "subtitleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNEQ = data
		case "subtitleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleIn = data
		case "subtitleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNotIn = data
		case "subtitleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGT = data
		case "subtitleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGTE = data
		case "subtitleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLT = data
		case "subtitleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLTE = data
		case "subtitleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContains = data
		case "subtitleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasPrefix = data
		case "subtitleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasSuffix = data
		case "subtitleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleEqualFold = data
		case "subtitleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "sourceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceNEQ = data
		case "sourceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceIn = data
		case "sourceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceNotIn = data
		case "sourceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceGT = data
		case "sourceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceGTE = data
		case "sourceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLT = data
		case "sourceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceLTE = data
		case "sourceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceContains = data
		case "sourceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceHasPrefix = data
		case "sourceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceHasSuffix = data
		case "sourceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceEqualFold = data
		case "sourceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceContainsFold = data
		case "sourceurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "sourceurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLNEQ = data
		case "sourceurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLIn = data
		case "sourceurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLNotIn = data
		case "sourceurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLGT = data
		case "sourceurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLGTE = data
		case "sourceurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLLT = data
		case "sourceurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLLTE = data
		case "sourceurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLContains = data
		case "sourceurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLHasPrefix = data
		case "sourceurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLHasSuffix = data
		case "sourceurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLEqualFold = data
		case "sourceurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURLContainsFold = data
		case "licence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licence"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Licence = data
		case "licenceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceNEQ = data
		case "licenceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceIn = data
		case "licenceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceNotIn = data
		case "licenceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceGT = data
		case "licenceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceGTE = data
		case "licenceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceLT = data
		case "licenceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceLTE = data
		case "licenceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceContains = data
		case "licenceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceHasPrefix = data
		case "licenceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceHasSuffix = data
		case "licenceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceEqualFold = data
		case "licenceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceContainsFold = data
		case "licenceurl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURL = data
		case "licenceurlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLNEQ = data
		case "licenceurlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLIn = data
		case "licenceurlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLNotIn = data
		case "licenceurlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLGT = data
		case "licenceurlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLGTE = data
		case "licenceurlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLLT = data
		case "licenceurlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLLTE = data
		case "licenceurlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLContains = data
		case "licenceurlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLHasPrefix = data
		case "licenceurlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLHasSuffix = data
		case "licenceurlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLEqualFold = data
		case "licenceurlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("licenceurlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LicenceURLContainsFold = data
		case "ishidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ishidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHidden = data
		case "ishiddenNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ishiddenNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHiddenNEQ = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "episodescount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescount"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCount = data
		case "episodescountNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountNEQ = data
		case "episodescountIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountIn = data
		case "episodescountNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountNotIn = data
		case "episodescountGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountGT = data
		case "episodescountGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountGTE = data
		case "episodescountLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountLT = data
		case "episodescountLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("episodescountLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EpisodesCountLTE = data
		case "hasEpisodes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEpisodes"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEpisodes = data
		case "hasEpisodesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEpisodesWith"))
			data, err := ec.unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEpisodesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCourseOrder(ctx context.Context, obj interface{}) (ent.CourseOrder, error) {
	var it ent.CourseOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNCourseOrderField2githubcomjhanaappjhanaappentCourseOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCourseWhereInput(ctx context.Context, obj interface{}) (ent.CourseWhereInput, error) {
	var it ent.CourseWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "iconimage", "iconimageNEQ", "iconimageIn", "iconimageNotIn", "iconimageGT", "iconimageGTE", "iconimageLT", "iconimageLTE", "iconimageContains", "iconimageHasPrefix", "iconimageHasSuffix", "iconimageEqualFold", "iconimageContainsFold", "coverimage", "coverimageNEQ", "coverimageIn", "coverimageNotIn", "coverimageGT", "coverimageGTE", "coverimageLT", "coverimageLTE", "coverimageContains", "coverimageHasPrefix", "coverimageHasSuffix", "coverimageEqualFold", "coverimageContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "color", "colorNEQ", "colorIn", "colorNotIn", "colorGT", "colorGTE", "colorLT", "colorLTE", "colorContains", "colorHasPrefix", "colorHasSuffix", "colorEqualFold", "colorContainsFold", "active", "activeNEQ", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "hasUnits", "hasUnitsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CourseWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "iconimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImage = data
		case "iconimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNEQ = data
		case "iconimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageIn = data
		case "iconimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNotIn = data
		case "iconimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGT = data
		case "iconimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGTE = data
		case "iconimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLT = data
		case "iconimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLTE = data
		case "iconimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContains = data
		case "iconimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasPrefix = data
		case "iconimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasSuffix = data
		case "iconimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageEqualFold = data
		case "iconimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContainsFold = data
		case "coverimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImage = data
		case "coverimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNEQ = data
		case "coverimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageIn = data
		case "coverimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNotIn = data
		case "coverimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGT = data
		case "coverimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGTE = data
		case "coverimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLT = data
		case "coverimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLTE = data
		case "coverimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContains = data
		case "coverimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasPrefix = data
		case "coverimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasSuffix = data
		case "coverimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageEqualFold = data
		case "coverimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "colorNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNEQ = data
		case "colorIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorIn = data
		case "colorNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNotIn = data
		case "colorGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGT = data
		case "colorGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGTE = data
		case "colorLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLT = data
		case "colorLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLTE = data
		case "colorContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContains = data
		case "colorHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasPrefix = data
		case "colorHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasSuffix = data
		case "colorEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorEqualFold = data
		case "colorContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContainsFold = data
		case "active":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Active = data
		case "activeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("activeNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ActiveNEQ = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "hasUnits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnits"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnits = data
		case "hasUnitsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnitsWith"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnitsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateJournalRecordInput(ctx context.Context, obj interface{}) (CreateJournalRecordInput, error) {
	var it CreateJournalRecordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"datetime", "duration", "note"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTime = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDownloadContentEpisodeInput(ctx context.Context, obj interface{}) (DownloadContentEpisodeInput, error) {
	var it DownloadContentEpisodeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"finished"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "finished":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finished"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Finished = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDownloadContentInput(ctx context.Context, obj interface{}) (DownloadContentInput, error) {
	var it DownloadContentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"finished"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "finished":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finished"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Finished = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDownloadLessonInput(ctx context.Context, obj interface{}) (DownloadLessonInput, error) {
	var it DownloadLessonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"finished"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "finished":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finished"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Finished = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDownloadUnitInput(ctx context.Context, obj interface{}) (DownloadUnitInput, error) {
	var it DownloadUnitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"finished"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "finished":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finished"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Finished = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinishContentEpisodeInput(ctx context.Context, obj interface{}) (FinishContentEpisodeInput, error) {
	var it FinishContentEpisodeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"datetime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinishLessonInput(ctx context.Context, obj interface{}) (FinishLessonInput, error) {
	var it FinishLessonInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"datetime", "duration", "note"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTime = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJournalRecordOrder(ctx context.Context, obj interface{}) (ent.JournalRecordOrder, error) {
	var it ent.JournalRecordOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNJournalRecordOrderField2githubcomjhanaappjhanaappentJournalRecordOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJournalRecordWhereInput(ctx context.Context, obj interface{}) (ent.JournalRecordWhereInput, error) {
	var it ent.JournalRecordWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "lessonID", "lessonIDNEQ", "lessonIDIn", "lessonIDNotIn", "lessonIDIsNil", "lessonIDNotNil", "datetime", "datetimeNEQ", "datetimeIn", "datetimeNotIn", "datetimeGT", "datetimeGTE", "datetimeLT", "datetimeLTE", "duration", "durationNEQ", "durationIn", "durationNotIn", "durationGT", "durationGTE", "durationLT", "durationLTE", "note", "noteNEQ", "noteIn", "noteNotIn", "noteGT", "noteGTE", "noteLT", "noteLTE", "noteContains", "noteHasPrefix", "noteHasSuffix", "noteEqualFold", "noteContainsFold", "createdat", "createdatNEQ", "createdatIn", "createdatNotIn", "createdatGT", "createdatGTE", "createdatLT", "createdatLTE", "updatedat", "updatedatNEQ", "updatedatIn", "updatedatNotIn", "updatedatGT", "updatedatGTE", "updatedatLT", "updatedatLTE", "hasUser", "hasUserWith", "hasLesson", "hasLessonWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().UserID(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().UserIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().UserIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().UserIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().LessonID(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().LessonIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().LessonIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JournalRecordWhereInput().LessonIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonIDIsNil = data
		case "lessonIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonIDNotNil = data
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTime = data
		case "datetimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeNEQ = data
		case "datetimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeIn = data
		case "datetimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeNotIn = data
		case "datetimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeGT = data
		case "datetimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeGTE = data
		case "datetimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeLT = data
		case "datetimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTimeLTE = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "durationNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNEQ = data
		case "durationIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationIn = data
		case "durationNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNotIn = data
		case "durationGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGT = data
		case "durationGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGTE = data
		case "durationLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLT = data
		case "durationLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLTE = data
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		case "noteNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteNEQ = data
		case "noteIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteIn = data
		case "noteNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteNotIn = data
		case "noteGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteGT = data
		case "noteGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteGTE = data
		case "noteLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteLT = data
		case "noteLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteLTE = data
		case "noteContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteContains = data
		case "noteHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteHasPrefix = data
		case "noteHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteHasSuffix = data
		case "noteEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteEqualFold = data
		case "noteContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noteContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoteContainsFold = data
		case "createdat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasLesson":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLesson"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLesson = data
		case "hasLessonWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessonWith"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessonWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLessonAudioOrder(ctx context.Context, obj interface{}) (ent.LessonAudioOrder, error) {
	var it ent.LessonAudioOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNLessonAudioOrderField2githubcomjhanaappjhanaappentLessonAudioOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLessonAudioWhereInput(ctx context.Context, obj interface{}) (ent.LessonAudioWhereInput, error) {
	var it ent.LessonAudioWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "lessonID", "lessonIDNEQ", "lessonIDIn", "lessonIDNotIn", "audiourl", "audiourlNEQ", "audiourlIn", "audiourlNotIn", "audiourlGT", "audiourlGTE", "audiourlLT", "audiourlLTE", "audiourlContains", "audiourlHasPrefix", "audiourlHasSuffix", "audiourlEqualFold", "audiourlContainsFold", "duration", "durationNEQ", "durationIn", "durationNotIn", "durationGT", "durationGTE", "durationLT", "durationLTE", "hasLesson", "hasLessonWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().LessonID(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().LessonIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().LessonIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonAudioWhereInput().LessonIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "audiourl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURL = data
		case "audiourlNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLNEQ = data
		case "audiourlIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLIn = data
		case "audiourlNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLNotIn = data
		case "audiourlGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLGT = data
		case "audiourlGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLGTE = data
		case "audiourlLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLLT = data
		case "audiourlLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLLTE = data
		case "audiourlContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLContains = data
		case "audiourlHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLHasPrefix = data
		case "audiourlHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLHasSuffix = data
		case "audiourlEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLEqualFold = data
		case "audiourlContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audiourlContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AudioURLContainsFold = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "durationNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNEQ = data
		case "durationIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationIn = data
		case "durationNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationNotIn = data
		case "durationGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGT = data
		case "durationGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationGTE = data
		case "durationLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLT = data
		case "durationLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationLTE = data
		case "hasLesson":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLesson"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLesson = data
		case "hasLessonWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessonWith"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessonWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLessonOrder(ctx context.Context, obj interface{}) (ent.LessonOrder, error) {
	var it ent.LessonOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNLessonOrderField2githubcomjhanaappjhanaappentLessonOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLessonWhereInput(ctx context.Context, obj interface{}) (ent.LessonWhereInput, error) {
	var it ent.LessonWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "unitID", "unitIDNEQ", "unitIDIn", "unitIDNotIn", "type", "typeNEQ", "typeIn", "typeNotIn", "iconimage", "iconimageNEQ", "iconimageIn", "iconimageNotIn", "iconimageGT", "iconimageGTE", "iconimageLT", "iconimageLTE", "iconimageContains", "iconimageHasPrefix", "iconimageHasSuffix", "iconimageEqualFold", "iconimageContainsFold", "coverimage", "coverimageNEQ", "coverimageIn", "coverimageNotIn", "coverimageGT", "coverimageGTE", "coverimageLT", "coverimageLTE", "coverimageContains", "coverimageHasPrefix", "coverimageHasSuffix", "coverimageEqualFold", "coverimageContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "hasUnit", "hasUnitWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().UnitID(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().UnitIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().UnitIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.LessonWhereInput().UnitIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "iconimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImage = data
		case "iconimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNEQ = data
		case "iconimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageIn = data
		case "iconimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNotIn = data
		case "iconimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGT = data
		case "iconimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGTE = data
		case "iconimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLT = data
		case "iconimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLTE = data
		case "iconimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContains = data
		case "iconimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasPrefix = data
		case "iconimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasSuffix = data
		case "iconimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageEqualFold = data
		case "iconimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContainsFold = data
		case "coverimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImage = data
		case "coverimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNEQ = data
		case "coverimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageIn = data
		case "coverimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNotIn = data
		case "coverimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGT = data
		case "coverimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGTE = data
		case "coverimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLT = data
		case "coverimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLTE = data
		case "coverimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContains = data
		case "coverimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasPrefix = data
		case "coverimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasSuffix = data
		case "coverimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageEqualFold = data
		case "coverimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "hasUnit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnit"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnit = data
		case "hasUnitWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnitWith"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnitWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMeditationsStatsInput(ctx context.Context, obj interface{}) (MeditationsStatsInput, error) {
	var it MeditationsStatsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userTimezone"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "userTimezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userTimezone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserTimezone = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefreshTokenInput(ctx context.Context, obj interface{}) (RefreshTokenInput, error) {
	var it RefreshTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"refreshToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "refreshToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("refreshToken"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RefreshToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResetContentEpisodeProgressInput(ctx context.Context, obj interface{}) (ResetContentEpisodeProgressInput, error) {
	var it ResetContentEpisodeProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confirm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confirm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Confirm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResetContentProgressInput(ctx context.Context, obj interface{}) (ResetContentProgressInput, error) {
	var it ResetContentProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confirm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confirm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Confirm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResetLessonProgressInput(ctx context.Context, obj interface{}) (ResetLessonProgressInput, error) {
	var it ResetLessonProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confirm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confirm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Confirm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResetUnitProgressInput(ctx context.Context, obj interface{}) (ResetUnitProgressInput, error) {
	var it ResetUnitProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confirm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confirm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confirm"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Confirm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveContentEpisodeProgressInput(ctx context.Context, obj interface{}) (SaveContentEpisodeProgressInput, error) {
	var it SaveContentEpisodeProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"progress"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "progress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progress"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Progress = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveLessonProgressInput(ctx context.Context, obj interface{}) (SaveLessonProgressInput, error) {
	var it SaveLessonProgressInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"progress"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "progress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progress"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Progress = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSignInWithEmailAndPasswordInput(ctx context.Context, obj interface{}) (SignInWithEmailAndPasswordInput, error) {
	var it SignInWithEmailAndPasswordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSignOutInput(ctx context.Context, obj interface{}) (SignOutInput, error) {
	var it SignOutInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"refreshToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "refreshToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("refreshToken"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RefreshToken = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSignUpWithEmailAndPasswordInput(ctx context.Context, obj interface{}) (SignUpWithEmailAndPasswordInput, error) {
	var it SignUpWithEmailAndPasswordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "password", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechniqueOrder(ctx context.Context, obj interface{}) (ent.TechniqueOrder, error) {
	var it ent.TechniqueOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTechniqueOrderField2githubcomjhanaappjhanaappentTechniqueOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTechniqueWhereInput(ctx context.Context, obj interface{}) (ent.TechniqueWhereInput, error) {
	var it ent.TechniqueWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "unitID", "unitIDNEQ", "unitIDIn", "unitIDNotIn", "iconimage", "iconimageNEQ", "iconimageIn", "iconimageNotIn", "iconimageGT", "iconimageGTE", "iconimageLT", "iconimageLTE", "iconimageContains", "iconimageHasPrefix", "iconimageHasSuffix", "iconimageEqualFold", "iconimageContainsFold", "coverimage", "coverimageNEQ", "coverimageIn", "coverimageNotIn", "coverimageGT", "coverimageGTE", "coverimageLT", "coverimageLTE", "coverimageContains", "coverimageHasPrefix", "coverimageHasSuffix", "coverimageEqualFold", "coverimageContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "subtitle", "subtitleNEQ", "subtitleIn", "subtitleNotIn", "subtitleGT", "subtitleGTE", "subtitleLT", "subtitleLTE", "subtitleContains", "subtitleHasPrefix", "subtitleHasSuffix", "subtitleEqualFold", "subtitleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "hasUnit", "hasUnitWith", "hasLessons", "hasLessonsWith", "hasTechniques", "hasTechniquesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().UnitID(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().UnitIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().UnitIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.TechniqueWhereInput().UnitIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "iconimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImage = data
		case "iconimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNEQ = data
		case "iconimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageIn = data
		case "iconimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNotIn = data
		case "iconimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGT = data
		case "iconimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGTE = data
		case "iconimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLT = data
		case "iconimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLTE = data
		case "iconimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContains = data
		case "iconimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasPrefix = data
		case "iconimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasSuffix = data
		case "iconimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageEqualFold = data
		case "iconimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContainsFold = data
		case "coverimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImage = data
		case "coverimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNEQ = data
		case "coverimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageIn = data
		case "coverimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNotIn = data
		case "coverimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGT = data
		case "coverimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGTE = data
		case "coverimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLT = data
		case "coverimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLTE = data
		case "coverimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContains = data
		case "coverimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasPrefix = data
		case "coverimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasSuffix = data
		case "coverimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageEqualFold = data
		case "coverimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "subtitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtitle = data
		case "subtitleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNEQ = data
		case "subtitleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleIn = data
		case "subtitleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNotIn = data
		case "subtitleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGT = data
		case "subtitleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGTE = data
		case "subtitleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLT = data
		case "subtitleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLTE = data
		case "subtitleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContains = data
		case "subtitleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasPrefix = data
		case "subtitleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasSuffix = data
		case "subtitleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleEqualFold = data
		case "subtitleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "hasUnit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnit"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnit = data
		case "hasUnitWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnitWith"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnitWith = data
		case "hasLessons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessons"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessons = data
		case "hasLessonsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessonsWith"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessonsWith = data
		case "hasTechniques":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechniques"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTechniques = data
		case "hasTechniquesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTechniquesWith"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTechniquesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnitOrder(ctx context.Context, obj interface{}) (ent.UnitOrder, error) {
	var it ent.UnitOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUnitOrderField2githubcomjhanaappjhanaappentUnitOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnitWhereInput(ctx context.Context, obj interface{}) (ent.UnitWhereInput, error) {
	var it ent.UnitWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "courseID", "courseIDNEQ", "courseIDIn", "courseIDNotIn", "iconimage", "iconimageNEQ", "iconimageIn", "iconimageNotIn", "iconimageGT", "iconimageGTE", "iconimageLT", "iconimageLTE", "iconimageContains", "iconimageHasPrefix", "iconimageHasSuffix", "iconimageEqualFold", "iconimageContainsFold", "coverimage", "coverimageNEQ", "coverimageIn", "coverimageNotIn", "coverimageGT", "coverimageGTE", "coverimageLT", "coverimageLTE", "coverimageContains", "coverimageHasPrefix", "coverimageHasSuffix", "coverimageEqualFold", "coverimageContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "subtitle", "subtitleNEQ", "subtitleIn", "subtitleNotIn", "subtitleGT", "subtitleGTE", "subtitleLT", "subtitleLTE", "subtitleContains", "subtitleHasPrefix", "subtitleHasSuffix", "subtitleEqualFold", "subtitleContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionEqualFold", "descriptionContainsFold", "mastering", "masteringNEQ", "masteringIn", "masteringNotIn", "masteringGT", "masteringGTE", "masteringLT", "masteringLTE", "masteringContains", "masteringHasPrefix", "masteringHasSuffix", "masteringEqualFold", "masteringContainsFold", "days", "daysNEQ", "daysIn", "daysNotIn", "daysGT", "daysGTE", "daysLT", "daysLTE", "color", "colorNEQ", "colorIn", "colorNotIn", "colorGT", "colorGTE", "colorLT", "colorLTE", "colorContains", "colorHasPrefix", "colorHasSuffix", "colorEqualFold", "colorContainsFold", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "hasCourse", "hasCourseWith", "hasLessons", "hasLessonsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().CourseID(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().CourseIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().CourseIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UnitWhereInput().CourseIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "iconimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImage = data
		case "iconimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNEQ = data
		case "iconimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageIn = data
		case "iconimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageNotIn = data
		case "iconimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGT = data
		case "iconimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageGTE = data
		case "iconimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLT = data
		case "iconimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageLTE = data
		case "iconimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContains = data
		case "iconimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasPrefix = data
		case "iconimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageHasSuffix = data
		case "iconimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageEqualFold = data
		case "iconimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iconimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IconImageContainsFold = data
		case "coverimage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimage"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImage = data
		case "coverimageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNEQ = data
		case "coverimageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageIn = data
		case "coverimageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageNotIn = data
		case "coverimageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGT = data
		case "coverimageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageGTE = data
		case "coverimageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLT = data
		case "coverimageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageLTE = data
		case "coverimageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContains = data
		case "coverimageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasPrefix = data
		case "coverimageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageHasSuffix = data
		case "coverimageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageEqualFold = data
		case "coverimageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coverimageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CoverImageContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "subtitle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitle"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtitle = data
		case "subtitleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNEQ = data
		case "subtitleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleIn = data
		case "subtitleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleNotIn = data
		case "subtitleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGT = data
		case "subtitleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleGTE = data
		case "subtitleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLT = data
		case "subtitleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleLTE = data
		case "subtitleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContains = data
		case "subtitleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasPrefix = data
		case "subtitleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleHasSuffix = data
		case "subtitleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleEqualFold = data
		case "subtitleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtitleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubtitleContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "mastering":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mastering"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mastering = data
		case "masteringNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringNEQ = data
		case "masteringIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringIn = data
		case "masteringNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringNotIn = data
		case "masteringGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringGT = data
		case "masteringGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringGTE = data
		case "masteringLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringLT = data
		case "masteringLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringLTE = data
		case "masteringContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringContains = data
		case "masteringHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringHasPrefix = data
		case "masteringHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringHasSuffix = data
		case "masteringEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringEqualFold = data
		case "masteringContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("masteringContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MasteringContainsFold = data
		case "days":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("days"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Days = data
		case "daysNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysNEQ = data
		case "daysIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysIn = data
		case "daysNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysNotIn = data
		case "daysGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysGT = data
		case "daysGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysGTE = data
		case "daysLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysLT = data
		case "daysLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("daysLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DaysLTE = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "colorNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNEQ = data
		case "colorIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorIn = data
		case "colorNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNotIn = data
		case "colorGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGT = data
		case "colorGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGTE = data
		case "colorLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLT = data
		case "colorLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLTE = data
		case "colorContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContains = data
		case "colorHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasPrefix = data
		case "colorHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasSuffix = data
		case "colorEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorEqualFold = data
		case "colorContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContainsFold = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "hasCourse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCourse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCourse = data
		case "hasCourseWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCourseWith"))
			data, err := ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCourseWith = data
		case "hasLessons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessons"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessons = data
		case "hasLessonsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessonsWith"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessonsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateJournalRecordInput(ctx context.Context, obj interface{}) (UpdateJournalRecordInput, error) {
	var it UpdateJournalRecordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"datetime", "duration", "note"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "datetime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("datetime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateTime = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (ent.UserOrder, error) {
	var it ent.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserOrderField2githubcomjhanaappjhanaappentUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserProgressOrder(ctx context.Context, obj interface{}) (ent.UserProgressOrder, error) {
	var it ent.UserProgressOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserProgressOrderField2githubcomjhanaappjhanaappentUserProgressOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserProgressWhereInput(ctx context.Context, obj interface{}) (ent.UserProgressWhereInput, error) {
	var it ent.UserProgressWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "courseID", "courseIDNEQ", "courseIDIn", "courseIDNotIn", "unitID", "unitIDNEQ", "unitIDIn", "unitIDNotIn", "lessonID", "lessonIDNEQ", "lessonIDIn", "lessonIDNotIn", "lessonType", "lessonTypeNEQ", "lessonTypeIn", "lessonTypeNotIn", "islast", "islastNEQ", "isnext", "isnextNEQ", "progress", "progressNEQ", "progressIn", "progressNotIn", "progressGT", "progressGTE", "progressLT", "progressLTE", "finishedat", "finishedatNEQ", "finishedatIn", "finishedatNotIn", "finishedatGT", "finishedatGTE", "finishedatLT", "finishedatLTE", "finishedatIsNil", "finishedatNotNil", "createdat", "createdatNEQ", "createdatIn", "createdatNotIn", "createdatGT", "createdatGTE", "createdatLT", "createdatLTE", "updatedat", "updatedatNEQ", "updatedatIn", "updatedatNotIn", "updatedatGT", "updatedatGTE", "updatedatLT", "updatedatLTE", "hasUser", "hasUserWith", "hasCourse", "hasCourseWith", "hasUnit", "hasUnitWith", "hasLesson", "hasLessonWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UserID(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UserIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UserIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UserIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().CourseID(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().CourseIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().CourseIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "courseIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("courseIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().CourseIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UnitID(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UnitIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UnitIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "unitIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unitIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().UnitIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonID"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().LessonID(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().LessonIDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().LessonIDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonIDNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserProgressWhereInput().LessonIDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "lessonType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonType"))
			data, err := ec.unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonType = data
		case "lessonTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonTypeNEQ"))
			data, err := ec.unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonTypeNEQ = data
		case "lessonTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonTypeIn"))
			data, err := ec.unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonTypeIn = data
		case "lessonTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lessonTypeNotIn"))
			data, err := ec.unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LessonTypeNotIn = data
		case "islast":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("islast"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsLast = data
		case "islastNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("islastNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsLastNEQ = data
		case "isnext":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isnext"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNext = data
		case "isnextNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isnextNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNextNEQ = data
		case "progress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progress"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Progress = data
		case "progressNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNEQ = data
		case "progressIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressIn = data
		case "progressNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNotIn = data
		case "progressGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGT = data
		case "progressGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGTE = data
		case "progressLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLT = data
		case "progressLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLTE = data
		case "finishedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAt = data
		case "finishedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNEQ = data
		case "finishedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtIn = data
		case "finishedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNotIn = data
		case "finishedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtGT = data
		case "finishedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtGTE = data
		case "finishedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtLT = data
		case "finishedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtLTE = data
		case "finishedatIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtIsNil = data
		case "finishedatNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finishedatNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinishedAtNotNil = data
		case "createdat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasCourse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCourse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCourse = data
		case "hasCourseWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCourseWith"))
			data, err := ec.unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCourseWith = data
		case "hasUnit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnit"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnit = data
		case "hasUnitWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUnitWith"))
			data, err := ec.unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUnitWith = data
		case "hasLesson":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLesson"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLesson = data
		case "hasLessonWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLessonWith"))
			data, err := ec.unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLessonWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "firebaseuid", "firebaseuidNEQ", "firebaseuidIn", "firebaseuidNotIn", "firebaseuidGT", "firebaseuidGTE", "firebaseuidLT", "firebaseuidLTE", "firebaseuidContains", "firebaseuidHasPrefix", "firebaseuidHasSuffix", "firebaseuidIsNil", "firebaseuidNotNil", "firebaseuidEqualFold", "firebaseuidContainsFold", "displayname", "displaynameNEQ", "displaynameIn", "displaynameNotIn", "displaynameGT", "displaynameGTE", "displaynameLT", "displaynameLTE", "displaynameContains", "displaynameHasPrefix", "displaynameHasSuffix", "displaynameEqualFold", "displaynameContainsFold", "createdat", "createdatNEQ", "createdatIn", "createdatNotIn", "createdatGT", "createdatGTE", "createdatLT", "createdatLTE", "updatedat", "updatedatNEQ", "updatedatIn", "updatedatNotIn", "updatedatGT", "updatedatGTE", "updatedatLT", "updatedatLTE", "authMethod", "authMethodNEQ", "authMethodIn", "authMethodNotIn", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailIsNil", "emailNotNil", "emailEqualFold", "emailContainsFold", "emailVerified", "emailVerifiedNEQ"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().ID(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserWhereInput().IDLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "firebaseuid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuid"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUid = data
		case "firebaseuidNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidNEQ = data
		case "firebaseuidIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidIn = data
		case "firebaseuidNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidNotIn = data
		case "firebaseuidGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidGT = data
		case "firebaseuidGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidGTE = data
		case "firebaseuidLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidLT = data
		case "firebaseuidLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidLTE = data
		case "firebaseuidContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidContains = data
		case "firebaseuidHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidHasPrefix = data
		case "firebaseuidHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidHasSuffix = data
		case "firebaseuidIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidIsNil = data
		case "firebaseuidNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidNotNil = data
		case "firebaseuidEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidEqualFold = data
		case "firebaseuidContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firebaseuidContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirebaseUidContainsFold = data
		case "displayname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayname"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "displaynameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNEQ = data
		case "displaynameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameIn = data
		case "displaynameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNotIn = data
		case "displaynameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGT = data
		case "displaynameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGTE = data
		case "displaynameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLT = data
		case "displaynameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLTE = data
		case "displaynameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContains = data
		case "displaynameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasPrefix = data
		case "displaynameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasSuffix = data
		case "displaynameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameEqualFold = data
		case "displaynameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displaynameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContainsFold = data
		case "createdat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedat"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedatGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedatGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedatLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedatLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedatLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "authMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMethod"))
			data, err := ec.unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthMethod = data
		case "authMethodNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMethodNEQ"))
			data, err := ec.unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthMethodNEQ = data
		case "authMethodIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMethodIn"))
			data, err := ec.unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthMethodIn = data
		case "authMethodNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMethodNotIn"))
			data, err := ec.unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthMethodNotIn = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "emailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNEQ = data
		case "emailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIn = data
		case "emailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotIn = data
		case "emailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGT = data
		case "emailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGTE = data
		case "emailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLT = data
		case "emailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLTE = data
		case "emailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContains = data
		case "emailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasPrefix = data
		case "emailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasSuffix = data
		case "emailIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIsNil = data
		case "emailNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotNil = data
		case "emailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailEqualFold = data
		case "emailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContainsFold = data
		case "emailVerified":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailVerified"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailVerified = data
		case "emailVerifiedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailVerifiedNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailVerifiedNEQ = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Content:
		if obj == nil {
			return graphql.Null
		}
		return ec._Content(ctx, sel, obj)
	case *ent.ContentEpisode:
		if obj == nil {
			return graphql.Null
		}
		return ec._ContentEpisode(ctx, sel, obj)
	case *ent.ContentProgress:
		if obj == nil {
			return graphql.Null
		}
		return ec._ContentProgress(ctx, sel, obj)
	case *ent.Course:
		if obj == nil {
			return graphql.Null
		}
		return ec._Course(ctx, sel, obj)
	case *ent.JournalRecord:
		if obj == nil {
			return graphql.Null
		}
		return ec._JournalRecord(ctx, sel, obj)
	case *ent.Lesson:
		if obj == nil {
			return graphql.Null
		}
		return ec._Lesson(ctx, sel, obj)
	case *ent.LessonAudio:
		if obj == nil {
			return graphql.Null
		}
		return ec._LessonAudio(ctx, sel, obj)
	case *ent.Technique:
		if obj == nil {
			return graphql.Null
		}
		return ec._Technique(ctx, sel, obj)
	case *ent.Unit:
		if obj == nil {
			return graphql.Null
		}
		return ec._Unit(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *ent.UserProgress:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserProgress(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var contentImplementors = []string{"Content", "Node"}

func (ec *executionContext) _Content(ctx context.Context, sel ast.SelectionSet, obj *ent.Content) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Content")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Content_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._Content_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "iconimage":
			out.Values[i] = ec._Content_iconimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverimage":
			out.Values[i] = ec._Content_coverimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Content_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subtitle":
			out.Values[i] = ec._Content_subtitle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Content_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			out.Values[i] = ec._Content_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceurl":
			out.Values[i] = ec._Content_sourceurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "licence":
			out.Values[i] = ec._Content_licence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "licenceurl":
			out.Values[i] = ec._Content_licenceurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ishidden":
			out.Values[i] = ec._Content_ishidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Content_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "episodescount":
			out.Values[i] = ec._Content_episodescount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "episodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Content_episodes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "singleEpisode":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Content_singleEpisode(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "episodesList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Content_episodesList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentConnectionImplementors = []string{"ContentConnection"}

func (ec *executionContext) _ContentConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentConnection")
		case "edges":
			out.Values[i] = ec._ContentConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._ContentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ContentConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentEdgeImplementors = []string{"ContentEdge"}

func (ec *executionContext) _ContentEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentEdge")
		case "node":
			out.Values[i] = ec._ContentEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._ContentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentEpisodeImplementors = []string{"ContentEpisode", "Node"}

func (ec *executionContext) _ContentEpisode(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentEpisode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentEpisodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentEpisode")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentEpisode_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "contentID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentEpisode_contentID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._ContentEpisode_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._ContentEpisode_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subtitle":
			out.Values[i] = ec._ContentEpisode_subtitle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ContentEpisode_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			out.Values[i] = ec._ContentEpisode_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "streamurl":
			out.Values[i] = ec._ContentEpisode_streamurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "downloadurl":
			out.Values[i] = ec._ContentEpisode_downloadurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source":
			out.Values[i] = ec._ContentEpisode_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourceurl":
			out.Values[i] = ec._ContentEpisode_sourceurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "licence":
			out.Values[i] = ec._ContentEpisode_licence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "licenceurl":
			out.Values[i] = ec._ContentEpisode_licenceurl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ishidden":
			out.Values[i] = ec._ContentEpisode_ishidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._ContentEpisode_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "content":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentEpisode_content(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "progress":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentEpisode_progress(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishedAt":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentEpisode_finishedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentEpisodeConnectionImplementors = []string{"ContentEpisodeConnection"}

func (ec *executionContext) _ContentEpisodeConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentEpisodeConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentEpisodeConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentEpisodeConnection")
		case "edges":
			out.Values[i] = ec._ContentEpisodeConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._ContentEpisodeConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ContentEpisodeConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentEpisodeEdgeImplementors = []string{"ContentEpisodeEdge"}

func (ec *executionContext) _ContentEpisodeEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentEpisodeEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentEpisodeEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentEpisodeEdge")
		case "node":
			out.Values[i] = ec._ContentEpisodeEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._ContentEpisodeEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contentProgressImplementors = []string{"ContentProgress", "Node"}

func (ec *executionContext) _ContentProgress(ctx context.Context, sel ast.SelectionSet, obj *ent.ContentProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contentProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContentProgress")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_userID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "contentID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_contentID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "episodeID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_episodeID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "contentType":
			out.Values[i] = ec._ContentProgress_contentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "progress":
			out.Values[i] = ec._ContentProgress_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finishedat":
			out.Values[i] = ec._ContentProgress_finishedat(ctx, field, obj)
		case "createdat":
			out.Values[i] = ec._ContentProgress_createdat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedat":
			out.Values[i] = ec._ContentProgress_updatedat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "content":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_content(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "episode":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContentProgress_episode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var courseImplementors = []string{"Course", "Node"}

func (ec *executionContext) _Course(ctx context.Context, sel ast.SelectionSet, obj *ent.Course) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, courseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Course")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Course_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "iconimage":
			out.Values[i] = ec._Course_iconimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverimage":
			out.Values[i] = ec._Course_coverimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Course_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Course_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "color":
			out.Values[i] = ec._Course_color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "active":
			out.Values[i] = ec._Course_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Course_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "units":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Course_units(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isStarted":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Course_isStarted(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var courseConnectionImplementors = []string{"CourseConnection"}

func (ec *executionContext) _CourseConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.CourseConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, courseConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CourseConnection")
		case "edges":
			out.Values[i] = ec._CourseConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._CourseConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._CourseConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var courseEdgeImplementors = []string{"CourseEdge"}

func (ec *executionContext) _CourseEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.CourseEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, courseEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CourseEdge")
		case "node":
			out.Values[i] = ec._CourseEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._CourseEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downloadContentEpisodeResultImplementors = []string{"DownloadContentEpisodeResult"}

func (ec *executionContext) _DownloadContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, obj *DownloadContentEpisodeResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downloadContentEpisodeResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownloadContentEpisodeResult")
		case "success":
			out.Values[i] = ec._DownloadContentEpisodeResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downloadContentResultImplementors = []string{"DownloadContentResult"}

func (ec *executionContext) _DownloadContentResult(ctx context.Context, sel ast.SelectionSet, obj *DownloadContentResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downloadContentResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownloadContentResult")
		case "success":
			out.Values[i] = ec._DownloadContentResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downloadLessonResultImplementors = []string{"DownloadLessonResult"}

func (ec *executionContext) _DownloadLessonResult(ctx context.Context, sel ast.SelectionSet, obj *DownloadLessonResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downloadLessonResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownloadLessonResult")
		case "success":
			out.Values[i] = ec._DownloadLessonResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downloadUnitResultImplementors = []string{"DownloadUnitResult"}

func (ec *executionContext) _DownloadUnitResult(ctx context.Context, sel ast.SelectionSet, obj *DownloadUnitResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downloadUnitResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownloadUnitResult")
		case "success":
			out.Values[i] = ec._DownloadUnitResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var finishContentEpisodeResultImplementors = []string{"FinishContentEpisodeResult"}

func (ec *executionContext) _FinishContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, obj *FinishContentEpisodeResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finishContentEpisodeResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinishContentEpisodeResult")
		case "episode":
			out.Values[i] = ec._FinishContentEpisodeResult_episode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextEpisode":
			out.Values[i] = ec._FinishContentEpisodeResult_nextEpisode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var finishLessonResultImplementors = []string{"FinishLessonResult"}

func (ec *executionContext) _FinishLessonResult(ctx context.Context, sel ast.SelectionSet, obj *FinishLessonResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finishLessonResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinishLessonResult")
		case "lesson":
			out.Values[i] = ec._FinishLessonResult_lesson(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextLesson":
			out.Values[i] = ec._FinishLessonResult_nextLesson(ctx, field, obj)
		case "journalRecord":
			out.Values[i] = ec._FinishLessonResult_journalRecord(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var journalRecordImplementors = []string{"JournalRecord", "Node"}

func (ec *executionContext) _JournalRecord(ctx context.Context, sel ast.SelectionSet, obj *ent.JournalRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, journalRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JournalRecord")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_userID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonID":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_lessonID(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "datetime":
			out.Values[i] = ec._JournalRecord_datetime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			out.Values[i] = ec._JournalRecord_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "note":
			out.Values[i] = ec._JournalRecord_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdat":
			out.Values[i] = ec._JournalRecord_createdat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedat":
			out.Values[i] = ec._JournalRecord_updatedat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lesson":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_lesson(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unitColor":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JournalRecord_unitColor(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var journalRecordConnectionImplementors = []string{"JournalRecordConnection"}

func (ec *executionContext) _JournalRecordConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.JournalRecordConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, journalRecordConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JournalRecordConnection")
		case "edges":
			out.Values[i] = ec._JournalRecordConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._JournalRecordConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._JournalRecordConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var journalRecordEdgeImplementors = []string{"JournalRecordEdge"}

func (ec *executionContext) _JournalRecordEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.JournalRecordEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, journalRecordEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JournalRecordEdge")
		case "node":
			out.Values[i] = ec._JournalRecordEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._JournalRecordEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lessonImplementors = []string{"Lesson", "Node"}

func (ec *executionContext) _Lesson(ctx context.Context, sel ast.SelectionSet, obj *ent.Lesson) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lessonImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Lesson")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unitID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_unitID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._Lesson_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "iconimage":
			out.Values[i] = ec._Lesson_iconimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverimage":
			out.Values[i] = ec._Lesson_coverimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Lesson_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Lesson_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Lesson_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "unit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_unit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isLast":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_isLast(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isNext":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_isNext(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "progress":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_progress(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishedAt":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_finishedAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "techniques":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_techniques(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonTechniques":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_lessonTechniques(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "audios":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Lesson_audios(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lessonAudioImplementors = []string{"LessonAudio", "Node"}

func (ec *executionContext) _LessonAudio(ctx context.Context, sel ast.SelectionSet, obj *ent.LessonAudio) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lessonAudioImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LessonAudio")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonAudio_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonAudio_lessonID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "audiourl":
			out.Values[i] = ec._LessonAudio_audiourl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			out.Values[i] = ec._LessonAudio_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lesson":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonAudio_lesson(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lessonConnectionImplementors = []string{"LessonConnection"}

func (ec *executionContext) _LessonConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.LessonConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lessonConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LessonConnection")
		case "edges":
			out.Values[i] = ec._LessonConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._LessonConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._LessonConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lessonEdgeImplementors = []string{"LessonEdge"}

func (ec *executionContext) _LessonEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.LessonEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lessonEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LessonEdge")
		case "node":
			out.Values[i] = ec._LessonEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._LessonEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var lessonTechniqueImplementors = []string{"LessonTechnique"}

func (ec *executionContext) _LessonTechnique(ctx context.Context, sel ast.SelectionSet, obj *ent.LessonTechnique) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lessonTechniqueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LessonTechnique")
		case "lessonId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonTechnique_lessonId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "techniqueId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonTechnique_techniqueId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "technique":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LessonTechnique_technique(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "order":
			out.Values[i] = ec._LessonTechnique_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var meditationsStatsImplementors = []string{"MeditationsStats"}

func (ec *executionContext) _MeditationsStats(ctx context.Context, sel ast.SelectionSet, obj *MeditationsStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, meditationsStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MeditationsStats")
		case "hoursTotal":
			out.Values[i] = ec._MeditationsStats_hoursTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sessionsTotal":
			out.Values[i] = ec._MeditationsStats_sessionsTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "currentStrike":
			out.Values[i] = ec._MeditationsStats_currentStrike(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastMeditationDate":
			out.Values[i] = ec._MeditationsStats_lastMeditationDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "signInWithEmailAndPassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_signInWithEmailAndPassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signUpWithEmailAndPassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_signUpWithEmailAndPassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "signOut":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_signOut(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "downloadUnit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_downloadUnit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetUnitProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetUnitProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveLessonProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveLessonProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "downloadLesson":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_downloadLesson(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetLessonProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetLessonProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishLesson":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishLesson(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "downloadContent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_downloadContent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetContentProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetContentProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveContentEpisodeProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveContentEpisodeProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "downloadContentEpisode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_downloadContentEpisode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetContentEpisodeProgress":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetContentEpisodeProgress(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "finishContentEpisode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_finishContentEpisode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createJournalRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createJournalRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateJournalRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateJournalRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteJournalRecord":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteJournalRecord(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[string]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "contents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "contentEpisodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_contentEpisodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "courses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_courses(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "journalRecords":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_journalRecords(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "lessons":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_lessons(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "techniques":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_techniques(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "units":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_units(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "activeEpisodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeEpisodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "activeEpisode":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeEpisode(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "weekStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_weekStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "activeLessons":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_activeLessons(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "meditationsStats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_meditationsStats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var refreshTokenResultImplementors = []string{"RefreshTokenResult"}

func (ec *executionContext) _RefreshTokenResult(ctx context.Context, sel ast.SelectionSet, obj *RefreshTokenResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshTokenResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshTokenResult")
		case "accessToken":
			out.Values[i] = ec._RefreshTokenResult_accessToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec._RefreshTokenResult_refreshToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signInWithEmailAndPasswordResultImplementors = []string{"SignInWithEmailAndPasswordResult"}

func (ec *executionContext) _SignInWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, obj *SignInWithEmailAndPasswordResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signInWithEmailAndPasswordResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignInWithEmailAndPasswordResult")
		case "accessToken":
			out.Values[i] = ec._SignInWithEmailAndPasswordResult_accessToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec._SignInWithEmailAndPasswordResult_refreshToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._SignInWithEmailAndPasswordResult_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var signUpWithEmailAndPasswordResultImplementors = []string{"SignUpWithEmailAndPasswordResult"}

func (ec *executionContext) _SignUpWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, obj *SignUpWithEmailAndPasswordResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, signUpWithEmailAndPasswordResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SignUpWithEmailAndPasswordResult")
		case "accessToken":
			out.Values[i] = ec._SignUpWithEmailAndPasswordResult_accessToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "refreshToken":
			out.Values[i] = ec._SignUpWithEmailAndPasswordResult_refreshToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._SignUpWithEmailAndPasswordResult_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var techniqueImplementors = []string{"Technique", "Node"}

func (ec *executionContext) _Technique(ctx context.Context, sel ast.SelectionSet, obj *ent.Technique) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, techniqueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Technique")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technique_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unitID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technique_unitID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "iconimage":
			out.Values[i] = ec._Technique_iconimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverimage":
			out.Values[i] = ec._Technique_coverimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Technique_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subtitle":
			out.Values[i] = ec._Technique_subtitle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Technique_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Technique_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "unit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technique_unit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessons":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technique_lessons(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "techniques":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Technique_techniques(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var techniqueConnectionImplementors = []string{"TechniqueConnection"}

func (ec *executionContext) _TechniqueConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TechniqueConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, techniqueConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechniqueConnection")
		case "edges":
			out.Values[i] = ec._TechniqueConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TechniqueConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TechniqueConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var techniqueEdgeImplementors = []string{"TechniqueEdge"}

func (ec *executionContext) _TechniqueEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TechniqueEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, techniqueEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TechniqueEdge")
		case "node":
			out.Values[i] = ec._TechniqueEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TechniqueEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unitImplementors = []string{"Unit", "Node"}

func (ec *executionContext) _Unit(ctx context.Context, sel ast.SelectionSet, obj *ent.Unit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unitImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Unit")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "courseID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_courseID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "iconimage":
			out.Values[i] = ec._Unit_iconimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coverimage":
			out.Values[i] = ec._Unit_coverimage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			out.Values[i] = ec._Unit_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subtitle":
			out.Values[i] = ec._Unit_subtitle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Unit_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mastering":
			out.Values[i] = ec._Unit_mastering(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "days":
			out.Values[i] = ec._Unit_days(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "color":
			out.Values[i] = ec._Unit_color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Unit_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "course":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_course(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessons":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_lessons(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonsTotal":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_lessonsTotal(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonsCompleted":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_lessonsCompleted(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isActive":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_isActive(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "nextUnit":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_nextUnit(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "techniques":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_techniques(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unitTechniques":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Unit_unitTechniques(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unitConnectionImplementors = []string{"UnitConnection"}

func (ec *executionContext) _UnitConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.UnitConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unitConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnitConnection")
		case "edges":
			out.Values[i] = ec._UnitConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._UnitConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._UnitConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unitEdgeImplementors = []string{"UnitEdge"}

func (ec *executionContext) _UnitEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.UnitEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unitEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnitEdge")
		case "node":
			out.Values[i] = ec._UnitEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._UnitEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unitTechniqueImplementors = []string{"UnitTechnique"}

func (ec *executionContext) _UnitTechnique(ctx context.Context, sel ast.SelectionSet, obj *ent.UnitTechnique) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unitTechniqueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnitTechnique")
		case "unitId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnitTechnique_unitId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "techniqueId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnitTechnique_techniqueId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "technique":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnitTechnique_technique(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "position":
			out.Values[i] = ec._UnitTechnique_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "firebaseuid":
			out.Values[i] = ec._User_firebaseuid(ctx, field, obj)
		case "displayname":
			out.Values[i] = ec._User_displayname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdat":
			out.Values[i] = ec._User_createdat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedat":
			out.Values[i] = ec._User_updatedat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authMethod":
			out.Values[i] = ec._User_authMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "emailVerified":
			out.Values[i] = ec._User_emailVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userProgressImplementors = []string{"UserProgress", "Node"}

func (ec *executionContext) _UserProgress(ctx context.Context, sel ast.SelectionSet, obj *ent.UserProgress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userProgressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserProgress")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_userID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "courseID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_courseID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unitID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_unitID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_lessonID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lessonType":
			out.Values[i] = ec._UserProgress_lessonType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "islast":
			out.Values[i] = ec._UserProgress_islast(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isnext":
			out.Values[i] = ec._UserProgress_isnext(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "progress":
			out.Values[i] = ec._UserProgress_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finishedat":
			out.Values[i] = ec._UserProgress_finishedat(ctx, field, obj)
		case "createdat":
			out.Values[i] = ec._UserProgress_createdat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedat":
			out.Values[i] = ec._UserProgress_updatedat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "course":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_course(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "unit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_unit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lesson":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserProgress_lesson(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNContent2githubcomjhanaappjhanaappentContent(ctx context.Context, sel ast.SelectionSet, v ent.Content) graphql.Marshaler {
	return ec._Content(ctx, sel, &v)
}

func (ec *executionContext) marshalNContent2githubcomjhanaappjhanaappentContent(ctx context.Context, sel ast.SelectionSet, v *ent.Content) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Content(ctx, sel, v)
}

func (ec *executionContext) marshalNContentConnection2githubcomjhanaappjhanaappentContentConnection(ctx context.Context, sel ast.SelectionSet, v ent.ContentConnection) graphql.Marshaler {
	return ec._ContentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNContentConnection2githubcomjhanaappjhanaappentContentConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ContentConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContentConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (property.ContentType, error) {
	var res property.ContentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v property.ContentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx context.Context, sel ast.SelectionSet, v ent.ContentEpisode) graphql.Marshaler {
	return ec._ContentEpisode(ctx, sel, &v)
}

func (ec *executionContext) marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx context.Context, sel ast.SelectionSet, v []*ent.ContentEpisode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEpisode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContentEpisode(ctx, sel, v)
}

func (ec *executionContext) marshalNContentEpisodeConnection2githubcomjhanaappjhanaappentContentEpisodeConnection(ctx context.Context, sel ast.SelectionSet, v ent.ContentEpisodeConnection) graphql.Marshaler {
	return ec._ContentEpisodeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNContentEpisodeConnection2githubcomjhanaappjhanaappentContentEpisodeConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEpisodeConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ContentEpisodeConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (property.ContentType, error) {
	var res property.ContentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v property.ContentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNContentEpisodeOrderField2githubcomjhanaappjhanaappentContentEpisodeOrderField(ctx context.Context, v interface{}) (*ent.ContentEpisodeOrderField, error) {
	var res = new(ent.ContentEpisodeOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNContentEpisodeOrderField2githubcomjhanaappjhanaappentContentEpisodeOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEpisodeOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx context.Context, v interface{}) (*ent.ContentEpisodeWhereInput, error) {
	res, err := ec.unmarshalInputContentEpisodeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNContentOrderField2githubcomjhanaappjhanaappentContentOrderField(ctx context.Context, v interface{}) (*ent.ContentOrderField, error) {
	var res = new(ent.ContentOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNContentOrderField2githubcomjhanaappjhanaappentContentOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ContentOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (property.ContentType, error) {
	var res property.ContentType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v property.ContentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx context.Context, v interface{}) (*ent.ContentProgressWhereInput, error) {
	res, err := ec.unmarshalInputContentProgressWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx context.Context, v interface{}) (*ent.ContentWhereInput, error) {
	res, err := ec.unmarshalInputContentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCourse2githubcomjhanaappjhanaappentCourse(ctx context.Context, sel ast.SelectionSet, v *ent.Course) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Course(ctx, sel, v)
}

func (ec *executionContext) marshalNCourseConnection2githubcomjhanaappjhanaappentCourseConnection(ctx context.Context, sel ast.SelectionSet, v ent.CourseConnection) graphql.Marshaler {
	return ec._CourseConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCourseConnection2githubcomjhanaappjhanaappentCourseConnection(ctx context.Context, sel ast.SelectionSet, v *ent.CourseConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CourseConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCourseOrderField2githubcomjhanaappjhanaappentCourseOrderField(ctx context.Context, v interface{}) (*ent.CourseOrderField, error) {
	var res = new(ent.CourseOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCourseOrderField2githubcomjhanaappjhanaappentCourseOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.CourseOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx context.Context, v interface{}) (*ent.CourseWhereInput, error) {
	res, err := ec.unmarshalInputCourseWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateJournalRecordInput2githubcomjhanaappjhanaappgqlCreateJournalRecordInput(ctx context.Context, v interface{}) (CreateJournalRecordInput, error) {
	res, err := ec.unmarshalInputCreateJournalRecordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (entgql.Cursor[string], error) {
	var res entgql.Cursor[string]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[string]) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDownloadContentEpisodeInput2githubcomjhanaappjhanaappgqlDownloadContentEpisodeInput(ctx context.Context, v interface{}) (DownloadContentEpisodeInput, error) {
	res, err := ec.unmarshalInputDownloadContentEpisodeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDownloadContentEpisodeResult2githubcomjhanaappjhanaappgqlDownloadContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, v DownloadContentEpisodeResult) graphql.Marshaler {
	return ec._DownloadContentEpisodeResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDownloadContentEpisodeResult2githubcomjhanaappjhanaappgqlDownloadContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, v *DownloadContentEpisodeResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DownloadContentEpisodeResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDownloadContentInput2githubcomjhanaappjhanaappgqlDownloadContentInput(ctx context.Context, v interface{}) (DownloadContentInput, error) {
	res, err := ec.unmarshalInputDownloadContentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDownloadContentResult2githubcomjhanaappjhanaappgqlDownloadContentResult(ctx context.Context, sel ast.SelectionSet, v DownloadContentResult) graphql.Marshaler {
	return ec._DownloadContentResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDownloadContentResult2githubcomjhanaappjhanaappgqlDownloadContentResult(ctx context.Context, sel ast.SelectionSet, v *DownloadContentResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DownloadContentResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDownloadLessonInput2githubcomjhanaappjhanaappgqlDownloadLessonInput(ctx context.Context, v interface{}) (DownloadLessonInput, error) {
	res, err := ec.unmarshalInputDownloadLessonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDownloadLessonResult2githubcomjhanaappjhanaappgqlDownloadLessonResult(ctx context.Context, sel ast.SelectionSet, v DownloadLessonResult) graphql.Marshaler {
	return ec._DownloadLessonResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDownloadLessonResult2githubcomjhanaappjhanaappgqlDownloadLessonResult(ctx context.Context, sel ast.SelectionSet, v *DownloadLessonResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DownloadLessonResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDownloadUnitInput2githubcomjhanaappjhanaappgqlDownloadUnitInput(ctx context.Context, v interface{}) (DownloadUnitInput, error) {
	res, err := ec.unmarshalInputDownloadUnitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDownloadUnitResult2githubcomjhanaappjhanaappgqlDownloadUnitResult(ctx context.Context, sel ast.SelectionSet, v DownloadUnitResult) graphql.Marshaler {
	return ec._DownloadUnitResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDownloadUnitResult2githubcomjhanaappjhanaappgqlDownloadUnitResult(ctx context.Context, sel ast.SelectionSet, v *DownloadUnitResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DownloadUnitResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFinishContentEpisodeInput2githubcomjhanaappjhanaappgqlFinishContentEpisodeInput(ctx context.Context, v interface{}) (FinishContentEpisodeInput, error) {
	res, err := ec.unmarshalInputFinishContentEpisodeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinishContentEpisodeResult2githubcomjhanaappjhanaappgqlFinishContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, v FinishContentEpisodeResult) graphql.Marshaler {
	return ec._FinishContentEpisodeResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFinishContentEpisodeResult2githubcomjhanaappjhanaappgqlFinishContentEpisodeResult(ctx context.Context, sel ast.SelectionSet, v *FinishContentEpisodeResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FinishContentEpisodeResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFinishLessonInput2githubcomjhanaappjhanaappgqlFinishLessonInput(ctx context.Context, v interface{}) (FinishLessonInput, error) {
	res, err := ec.unmarshalInputFinishLessonInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinishLessonResult2githubcomjhanaappjhanaappgqlFinishLessonResult(ctx context.Context, sel ast.SelectionSet, v FinishLessonResult) graphql.Marshaler {
	return ec._FinishLessonResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFinishLessonResult2githubcomjhanaappjhanaappgqlFinishLessonResult(ctx context.Context, sel ast.SelectionSet, v *FinishLessonResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FinishLessonResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, v interface{}) (gqlid.Base64ID, error) {
	var res gqlid.Base64ID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, sel ast.SelectionSet, v gqlid.Base64ID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, v interface{}) ([]*gqlid.Base64ID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*gqlid.Base64ID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, sel ast.SelectionSet, v []*gqlid.Base64ID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, v interface{}) (*gqlid.Base64ID, error) {
	var res = new(gqlid.Base64ID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, sel ast.SelectionSet, v *gqlid.Base64ID) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx context.Context, sel ast.SelectionSet, v ent.JournalRecord) graphql.Marshaler {
	return ec._JournalRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx context.Context, sel ast.SelectionSet, v []*ent.JournalRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx context.Context, sel ast.SelectionSet, v *ent.JournalRecord) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JournalRecord(ctx, sel, v)
}

func (ec *executionContext) marshalNJournalRecordConnection2githubcomjhanaappjhanaappentJournalRecordConnection(ctx context.Context, sel ast.SelectionSet, v ent.JournalRecordConnection) graphql.Marshaler {
	return ec._JournalRecordConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJournalRecordConnection2githubcomjhanaappjhanaappentJournalRecordConnection(ctx context.Context, sel ast.SelectionSet, v *ent.JournalRecordConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JournalRecordConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJournalRecordOrderField2githubcomjhanaappjhanaappentJournalRecordOrderField(ctx context.Context, v interface{}) (*ent.JournalRecordOrderField, error) {
	var res = new(ent.JournalRecordOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJournalRecordOrderField2githubcomjhanaappjhanaappentJournalRecordOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.JournalRecordOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx context.Context, v interface{}) (*ent.JournalRecordWhereInput, error) {
	res, err := ec.unmarshalInputJournalRecordWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx context.Context, sel ast.SelectionSet, v ent.Lesson) graphql.Marshaler {
	return ec._Lesson(ctx, sel, &v)
}

func (ec *executionContext) marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx context.Context, sel ast.SelectionSet, v []*ent.Lesson) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx context.Context, sel ast.SelectionSet, v *ent.Lesson) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Lesson(ctx, sel, v)
}

func (ec *executionContext) marshalNLessonAudio2githubcomjhanaappjhanaappentLessonAudio(ctx context.Context, sel ast.SelectionSet, v []*ent.LessonAudio) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLessonAudio2githubcomjhanaappjhanaappentLessonAudio(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLessonAudio2githubcomjhanaappjhanaappentLessonAudio(ctx context.Context, sel ast.SelectionSet, v *ent.LessonAudio) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LessonAudio(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLessonAudioOrderField2githubcomjhanaappjhanaappentLessonAudioOrderField(ctx context.Context, v interface{}) (*ent.LessonAudioOrderField, error) {
	var res = new(ent.LessonAudioOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLessonAudioOrderField2githubcomjhanaappjhanaappentLessonAudioOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.LessonAudioOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx context.Context, v interface{}) (*ent.LessonAudioWhereInput, error) {
	res, err := ec.unmarshalInputLessonAudioWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLessonConnection2githubcomjhanaappjhanaappentLessonConnection(ctx context.Context, sel ast.SelectionSet, v ent.LessonConnection) graphql.Marshaler {
	return ec._LessonConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLessonConnection2githubcomjhanaappjhanaappentLessonConnection(ctx context.Context, sel ast.SelectionSet, v *ent.LessonConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LessonConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) (property.LessonType, error) {
	var res property.LessonType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v property.LessonType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLessonOrderField2githubcomjhanaappjhanaappentLessonOrderField(ctx context.Context, v interface{}) (*ent.LessonOrderField, error) {
	var res = new(ent.LessonOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLessonOrderField2githubcomjhanaappjhanaappentLessonOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.LessonOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNLessonTechnique2githubcomjhanaappjhanaappentLessonTechnique(ctx context.Context, sel ast.SelectionSet, v []*ent.LessonTechnique) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLessonTechnique2githubcomjhanaappjhanaappentLessonTechnique(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLessonTechnique2githubcomjhanaappjhanaappentLessonTechnique(ctx context.Context, sel ast.SelectionSet, v *ent.LessonTechnique) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LessonTechnique(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx context.Context, v interface{}) (*ent.LessonWhereInput, error) {
	res, err := ec.unmarshalInputLessonWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMeditationsStats2githubcomjhanaappjhanaappgqlMeditationsStats(ctx context.Context, sel ast.SelectionSet, v MeditationsStats) graphql.Marshaler {
	return ec._MeditationsStats(ctx, sel, &v)
}

func (ec *executionContext) marshalNMeditationsStats2githubcomjhanaappjhanaappgqlMeditationsStats(ctx context.Context, sel ast.SelectionSet, v *MeditationsStats) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MeditationsStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMeditationsStatsInput2githubcomjhanaappjhanaappgqlMeditationsStatsInput(ctx context.Context, v interface{}) (MeditationsStatsInput, error) {
	res, err := ec.unmarshalInputMeditationsStatsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2githubcomjhanaappjhanaappentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubcomjhanaappjhanaappentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[string]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRefreshTokenInput2githubcomjhanaappjhanaappgqlRefreshTokenInput(ctx context.Context, v interface{}) (RefreshTokenInput, error) {
	res, err := ec.unmarshalInputRefreshTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRefreshTokenResult2githubcomjhanaappjhanaappgqlRefreshTokenResult(ctx context.Context, sel ast.SelectionSet, v RefreshTokenResult) graphql.Marshaler {
	return ec._RefreshTokenResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNRefreshTokenResult2githubcomjhanaappjhanaappgqlRefreshTokenResult(ctx context.Context, sel ast.SelectionSet, v *RefreshTokenResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RefreshTokenResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResetContentEpisodeProgressInput2githubcomjhanaappjhanaappgqlResetContentEpisodeProgressInput(ctx context.Context, v interface{}) (ResetContentEpisodeProgressInput, error) {
	res, err := ec.unmarshalInputResetContentEpisodeProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNResetContentProgressInput2githubcomjhanaappjhanaappgqlResetContentProgressInput(ctx context.Context, v interface{}) (ResetContentProgressInput, error) {
	res, err := ec.unmarshalInputResetContentProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNResetLessonProgressInput2githubcomjhanaappjhanaappgqlResetLessonProgressInput(ctx context.Context, v interface{}) (ResetLessonProgressInput, error) {
	res, err := ec.unmarshalInputResetLessonProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNResetUnitProgressInput2githubcomjhanaappjhanaappgqlResetUnitProgressInput(ctx context.Context, v interface{}) (ResetUnitProgressInput, error) {
	res, err := ec.unmarshalInputResetUnitProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSaveContentEpisodeProgressInput2githubcomjhanaappjhanaappgqlSaveContentEpisodeProgressInput(ctx context.Context, v interface{}) (SaveContentEpisodeProgressInput, error) {
	res, err := ec.unmarshalInputSaveContentEpisodeProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSaveLessonProgressInput2githubcomjhanaappjhanaappgqlSaveLessonProgressInput(ctx context.Context, v interface{}) (SaveLessonProgressInput, error) {
	res, err := ec.unmarshalInputSaveLessonProgressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSignInWithEmailAndPasswordInput2githubcomjhanaappjhanaappgqlSignInWithEmailAndPasswordInput(ctx context.Context, v interface{}) (SignInWithEmailAndPasswordInput, error) {
	res, err := ec.unmarshalInputSignInWithEmailAndPasswordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignInWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignInWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, v SignInWithEmailAndPasswordResult) graphql.Marshaler {
	return ec._SignInWithEmailAndPasswordResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNSignInWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignInWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, v *SignInWithEmailAndPasswordResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignInWithEmailAndPasswordResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSignOutInput2githubcomjhanaappjhanaappgqlSignOutInput(ctx context.Context, v interface{}) (SignOutInput, error) {
	res, err := ec.unmarshalInputSignOutInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSignUpWithEmailAndPasswordInput2githubcomjhanaappjhanaappgqlSignUpWithEmailAndPasswordInput(ctx context.Context, v interface{}) (SignUpWithEmailAndPasswordInput, error) {
	res, err := ec.unmarshalInputSignUpWithEmailAndPasswordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSignUpWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignUpWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, v SignUpWithEmailAndPasswordResult) graphql.Marshaler {
	return ec._SignUpWithEmailAndPasswordResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNSignUpWithEmailAndPasswordResult2githubcomjhanaappjhanaappgqlSignUpWithEmailAndPasswordResult(ctx context.Context, sel ast.SelectionSet, v *SignUpWithEmailAndPasswordResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SignUpWithEmailAndPasswordResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx context.Context, sel ast.SelectionSet, v ent.Technique) graphql.Marshaler {
	return ec._Technique(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx context.Context, sel ast.SelectionSet, v []*ent.Technique) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTechnique2githubcomjhanaappjhanaappentTechnique(ctx context.Context, sel ast.SelectionSet, v *ent.Technique) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Technique(ctx, sel, v)
}

func (ec *executionContext) marshalNTechniqueConnection2githubcomjhanaappjhanaappentTechniqueConnection(ctx context.Context, sel ast.SelectionSet, v ent.TechniqueConnection) graphql.Marshaler {
	return ec._TechniqueConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTechniqueConnection2githubcomjhanaappjhanaappentTechniqueConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TechniqueConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TechniqueConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTechniqueOrderField2githubcomjhanaappjhanaappentTechniqueOrderField(ctx context.Context, v interface{}) (*ent.TechniqueOrderField, error) {
	var res = new(ent.TechniqueOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTechniqueOrderField2githubcomjhanaappjhanaappentTechniqueOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TechniqueOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx context.Context, v interface{}) (*ent.TechniqueWhereInput, error) {
	res, err := ec.unmarshalInputTechniqueWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx context.Context, sel ast.SelectionSet, v ent.Unit) graphql.Marshaler {
	return ec._Unit(ctx, sel, &v)
}

func (ec *executionContext) marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx context.Context, sel ast.SelectionSet, v *ent.Unit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Unit(ctx, sel, v)
}

func (ec *executionContext) marshalNUnitConnection2githubcomjhanaappjhanaappentUnitConnection(ctx context.Context, sel ast.SelectionSet, v ent.UnitConnection) graphql.Marshaler {
	return ec._UnitConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUnitConnection2githubcomjhanaappjhanaappentUnitConnection(ctx context.Context, sel ast.SelectionSet, v *ent.UnitConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UnitConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUnitOrderField2githubcomjhanaappjhanaappentUnitOrderField(ctx context.Context, v interface{}) (*ent.UnitOrderField, error) {
	var res = new(ent.UnitOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUnitOrderField2githubcomjhanaappjhanaappentUnitOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UnitOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNUnitTechnique2githubcomjhanaappjhanaappentUnitTechnique(ctx context.Context, sel ast.SelectionSet, v []*ent.UnitTechnique) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUnitTechnique2githubcomjhanaappjhanaappentUnitTechnique(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUnitTechnique2githubcomjhanaappjhanaappentUnitTechnique(ctx context.Context, sel ast.SelectionSet, v *ent.UnitTechnique) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UnitTechnique(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx context.Context, v interface{}) (*ent.UnitWhereInput, error) {
	res, err := ec.unmarshalInputUnitWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateJournalRecordInput2githubcomjhanaappjhanaappgqlUpdateJournalRecordInput(ctx context.Context, v interface{}) (UpdateJournalRecordInput, error) {
	res, err := ec.unmarshalInputUpdateJournalRecordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomjhanaappjhanaappentUser(ctx context.Context, sel ast.SelectionSet, v ent.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomjhanaappjhanaappentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, v interface{}) (property.AuthMethod, error) {
	var res property.AuthMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, sel ast.SelectionSet, v property.AuthMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserOrderField2githubcomjhanaappjhanaappentUserOrderField(ctx context.Context, v interface{}) (*ent.UserOrderField, error) {
	var res = new(ent.UserOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubcomjhanaappjhanaappentUserOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UserOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) (property.LessonType, error) {
	var res property.LessonType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v property.LessonType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserProgressOrderField2githubcomjhanaappjhanaappentUserProgressOrderField(ctx context.Context, v interface{}) (*ent.UserProgressOrderField, error) {
	var res = new(ent.UserProgressOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserProgressOrderField2githubcomjhanaappjhanaappentUserProgressOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UserProgressOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx context.Context, v interface{}) (*ent.UserProgressWhereInput, error) {
	res, err := ec.unmarshalInputUserProgressWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOContent2githubcomjhanaappjhanaappentContent(ctx context.Context, sel ast.SelectionSet, v *ent.Content) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Content(ctx, sel, v)
}

func (ec *executionContext) unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) ([]property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.ContentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v []property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (*property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.ContentType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContentContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v *property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOContentEdge2githubcomjhanaappjhanaappentContentEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ContentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOContentEdge2githubcomjhanaappjhanaappentContentEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOContentEdge2githubcomjhanaappjhanaappentContentEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContentEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOContentEpisode2githubcomjhanaappjhanaappentContentEpisode(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEpisode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContentEpisode(ctx, sel, v)
}

func (ec *executionContext) unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) ([]property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.ContentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v []property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (*property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.ContentType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContentEpisodeContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v *property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOContentEpisodeEdge2githubcomjhanaappjhanaappentContentEpisodeEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ContentEpisodeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOContentEpisodeEdge2githubcomjhanaappjhanaappentContentEpisodeEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOContentEpisodeEdge2githubcomjhanaappjhanaappentContentEpisodeEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ContentEpisodeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContentEpisodeEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOContentEpisodeOrder2githubcomjhanaappjhanaappentContentEpisodeOrder(ctx context.Context, v interface{}) (*ent.ContentEpisodeOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContentEpisodeOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx context.Context, v interface{}) ([]*ent.ContentEpisodeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ContentEpisodeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOContentEpisodeWhereInput2githubcomjhanaappjhanaappentContentEpisodeWhereInput(ctx context.Context, v interface{}) (*ent.ContentEpisodeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContentEpisodeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOContentOrder2githubcomjhanaappjhanaappentContentOrder(ctx context.Context, v interface{}) (*ent.ContentOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContentOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) ([]property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.ContentType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v []property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, v interface{}) (*property.ContentType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.ContentType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContentProgressContentType2githubcomjhanaappjhanaappentpropertyContentType(ctx context.Context, sel ast.SelectionSet, v *property.ContentType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx context.Context, v interface{}) ([]*ent.ContentProgressWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ContentProgressWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOContentProgressWhereInput2githubcomjhanaappjhanaappentContentProgressWhereInput(ctx context.Context, v interface{}) (*ent.ContentProgressWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContentProgressWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx context.Context, v interface{}) ([]*ent.ContentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ContentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOContentWhereInput2githubcomjhanaappjhanaappentContentWhereInput(ctx context.Context, v interface{}) (*ent.ContentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCourse2githubcomjhanaappjhanaappentCourse(ctx context.Context, sel ast.SelectionSet, v *ent.Course) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Course(ctx, sel, v)
}

func (ec *executionContext) marshalOCourseEdge2githubcomjhanaappjhanaappentCourseEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.CourseEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCourseEdge2githubcomjhanaappjhanaappentCourseEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCourseEdge2githubcomjhanaappjhanaappentCourseEdge(ctx context.Context, sel ast.SelectionSet, v *ent.CourseEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CourseEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCourseOrder2githubcomjhanaappjhanaappentCourseOrder(ctx context.Context, v interface{}) (*ent.CourseOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCourseOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx context.Context, v interface{}) ([]*ent.CourseWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CourseWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCourseWhereInput2githubcomjhanaappjhanaappentCourseWhereInput(ctx context.Context, v interface{}) (*ent.CourseWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCourseWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (*entgql.Cursor[string], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[string])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[string]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, v interface{}) ([]*gqlid.Base64ID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*gqlid.Base64ID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, sel ast.SelectionSet, v []*gqlid.Base64ID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, v interface{}) (*gqlid.Base64ID, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(gqlid.Base64ID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2githubcomjhanaappjhanaappentgqlidBase64ID(ctx context.Context, sel ast.SelectionSet, v *gqlid.Base64ID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) ([]int64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v []int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOJournalRecord2githubcomjhanaappjhanaappentJournalRecord(ctx context.Context, sel ast.SelectionSet, v *ent.JournalRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JournalRecord(ctx, sel, v)
}

func (ec *executionContext) marshalOJournalRecordEdge2githubcomjhanaappjhanaappentJournalRecordEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.JournalRecordEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOJournalRecordEdge2githubcomjhanaappjhanaappentJournalRecordEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOJournalRecordEdge2githubcomjhanaappjhanaappentJournalRecordEdge(ctx context.Context, sel ast.SelectionSet, v *ent.JournalRecordEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JournalRecordEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJournalRecordOrder2githubcomjhanaappjhanaappentJournalRecordOrder(ctx context.Context, v interface{}) (*ent.JournalRecordOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJournalRecordOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx context.Context, v interface{}) ([]*ent.JournalRecordWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.JournalRecordWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOJournalRecordWhereInput2githubcomjhanaappjhanaappentJournalRecordWhereInput(ctx context.Context, v interface{}) (*ent.JournalRecordWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJournalRecordWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx context.Context, sel ast.SelectionSet, v []*ent.Lesson) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLesson2githubcomjhanaappjhanaappentLesson(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLesson2githubcomjhanaappjhanaappentLesson(ctx context.Context, sel ast.SelectionSet, v *ent.Lesson) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Lesson(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx context.Context, v interface{}) ([]*ent.LessonAudioWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LessonAudioWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLessonAudioWhereInput2githubcomjhanaappjhanaappentLessonAudioWhereInput(ctx context.Context, v interface{}) (*ent.LessonAudioWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLessonAudioWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLessonEdge2githubcomjhanaappjhanaappentLessonEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.LessonEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLessonEdge2githubcomjhanaappjhanaappentLessonEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLessonEdge2githubcomjhanaappjhanaappentLessonEdge(ctx context.Context, sel ast.SelectionSet, v *ent.LessonEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LessonEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) ([]property.LessonType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.LessonType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v []property.LessonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) (*property.LessonType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.LessonType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLessonLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v *property.LessonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLessonOrder2githubcomjhanaappjhanaappentLessonOrder(ctx context.Context, v interface{}) (*ent.LessonOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLessonOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx context.Context, v interface{}) ([]*ent.LessonWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LessonWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLessonWhereInput2githubcomjhanaappjhanaappentLessonWhereInput(ctx context.Context, v interface{}) (*ent.LessonWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLessonWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubcomjhanaappjhanaappentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTechnique2githubcomjhanaappjhanaappentTechnique(ctx context.Context, sel ast.SelectionSet, v *ent.Technique) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Technique(ctx, sel, v)
}

func (ec *executionContext) marshalOTechniqueEdge2githubcomjhanaappjhanaappentTechniqueEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TechniqueEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTechniqueEdge2githubcomjhanaappjhanaappentTechniqueEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTechniqueEdge2githubcomjhanaappjhanaappentTechniqueEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TechniqueEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TechniqueEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTechniqueOrder2githubcomjhanaappjhanaappentTechniqueOrder(ctx context.Context, v interface{}) (*ent.TechniqueOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechniqueOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx context.Context, v interface{}) ([]*ent.TechniqueWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TechniqueWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTechniqueWhereInput2githubcomjhanaappjhanaappentTechniqueWhereInput(ctx context.Context, v interface{}) (*ent.TechniqueWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTechniqueWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUnit2githubcomjhanaappjhanaappentUnit(ctx context.Context, sel ast.SelectionSet, v []*ent.Unit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUnit2githubcomjhanaappjhanaappentUnit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUnit2githubcomjhanaappjhanaappentUnit(ctx context.Context, sel ast.SelectionSet, v *ent.Unit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Unit(ctx, sel, v)
}

func (ec *executionContext) marshalOUnitEdge2githubcomjhanaappjhanaappentUnitEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.UnitEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUnitEdge2githubcomjhanaappjhanaappentUnitEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUnitEdge2githubcomjhanaappjhanaappentUnitEdge(ctx context.Context, sel ast.SelectionSet, v *ent.UnitEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnitEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUnitOrder2githubcomjhanaappjhanaappentUnitOrder(ctx context.Context, v interface{}) (*ent.UnitOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUnitOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx context.Context, v interface{}) ([]*ent.UnitWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UnitWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUnitWhereInput2githubcomjhanaappjhanaappentUnitWhereInput(ctx context.Context, v interface{}) (*ent.UnitWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUnitWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, v interface{}) ([]property.AuthMethod, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.AuthMethod, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, sel ast.SelectionSet, v []property.AuthMethod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, v interface{}) (*property.AuthMethod, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.AuthMethod)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserAuthMethod2githubcomjhanaappjhanaappentpropertyAuthMethod(ctx context.Context, sel ast.SelectionSet, v *property.AuthMethod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) ([]property.LessonType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]property.LessonType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v []property.LessonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, v interface{}) (*property.LessonType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(property.LessonType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserProgressLessonType2githubcomjhanaappjhanaappentpropertyLessonType(ctx context.Context, sel ast.SelectionSet, v *property.LessonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx context.Context, v interface{}) ([]*ent.UserProgressWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserProgressWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserProgressWhereInput2githubcomjhanaappjhanaappentUserProgressWhereInput(ctx context.Context, v interface{}) (*ent.UserProgressWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserProgressWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx context.Context, v interface{}) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomjhanaappjhanaappentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
