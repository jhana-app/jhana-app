package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/jhana-app/jhana-app/ent"
	"github.com/jhana-app/jhana-app/ent/content"
	"github.com/jhana-app/jhana-app/ent/contentepisode"
	"github.com/jhana-app/jhana-app/ent/contentprogress"
	"github.com/jhana-app/jhana-app/ent/dataloaders"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/property"
	"github.com/jhana-app/jhana-app/internal/authctx"
	"go.uber.org/zap"
)

// Progress is the resolver for the progress field.
func (r *contentEpisodeResolver) Progress(ctx context.Context, obj *ent.ContentEpisode) (int, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	progress, err := dataloaders.MustGet(ctx).ContentProgress.Load(gqlid.NewContentProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil {
		if ent.IsNotFound(err) {
			return 0, nil
		}
		r.logger.Error("failed to get content progress", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("episode_id", obj.ID.ID))
		return 0, fmt.Errorf("internal server error")
	}

	return int(progress.Progress), nil
}

// FinishedAt is the resolver for the finishedAt field.
func (r *contentEpisodeResolver) FinishedAt(ctx context.Context, obj *ent.ContentEpisode) (*time.Time, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	progress, err := dataloaders.MustGet(ctx).ContentProgress.Load(gqlid.NewContentProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}
		r.logger.Error("failed to get content progress", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("episode_id", obj.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	return progress.FinishedAt, nil
}

// ActiveEpisodes is the resolver for the activeEpisodes field.
func (r *queryResolver) ActiveEpisodes(ctx context.Context) ([]*ent.ContentEpisode, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	// get unique contents IDs where user have any progress
	uniqueContents, err := r.client.Debug().ContentProgress.Query().
		Unique(true).
		Modify(func(s *sql.Selector) {
			// NOTE(vlad): we use 'Modify' instead of 'Select' here
			// because Ent will add "id" field to the query by default which breaks DISTINCT query
			s.Select(contentprogress.FieldContentID)
		}).
		Where(contentprogress.UserID(authenticatedUser.ID)).
		All(ctx)
	if err != nil {
		r.logger.Error("failed to get user contents", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	var episodes []*ent.ContentEpisode
	for _, p := range uniqueContents {
		episode, err := r.activeEpisode(ctx, authenticatedUser, p.ContentID)
		if err != nil {
			return nil, err
		}

		if episode != nil {
			episodes = append(episodes, episode)
		}
	}

	var (
		audioFound       bool
		videoFound       bool
		ignoreContentIDs []gqlid.ContentID
		ignoreEpisodeIDs []gqlid.ContentEpisodeID
	)
	for _, e := range episodes {
		if e.Type == property.ContentAudio {
			audioFound = true
		} else if e.Type == property.ContentVideo {
			videoFound = true
		}
	}

	if !audioFound || !videoFound {
		hiddenContent, err := r.client.Content.Query().
			Select(content.FieldID).
			Where(content.IsHidden(true)).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get hidden contents", zap.Error(err))
			return nil, fmt.Errorf("internal server error")
		}
		for _, c := range hiddenContent {
			ignoreContentIDs = append(ignoreContentIDs, c.ID)
		}

		hiddenEpisode, err := r.client.ContentEpisode.Query().
			Select(contentepisode.FieldID).
			Where(contentepisode.IsHidden(true)).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get hidden content episodes", zap.Error(err))
			return nil, fmt.Errorf("internal server error")
		}
		for _, c := range hiddenEpisode {
			ignoreEpisodeIDs = append(ignoreEpisodeIDs, c.ID)
		}

		items, err := r.client.ContentProgress.Query().
			Unique(true).
			Modify(func(s *sql.Selector) {
				// NOTE(vlad): we use 'Modify' instead of 'Select' here
				// because Ent will add "id" field to the query by default which breaks DISTINCT query
				s.Select(contentprogress.FieldEpisodeID)
			}).
			Where(contentprogress.UserID(authenticatedUser.ID), contentprogress.FinishedAtNotNil()).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get finished episodes", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID))
			return nil, fmt.Errorf("internal server error")
		}
		for _, item := range items {
			ignoreEpisodeIDs = append(ignoreEpisodeIDs, item.EpisodeID)
		}
	}

	if !audioFound {
		// get random unfinished episode
		episodeObj, err := r.client.ContentEpisode.Query().
			Select(contentepisode.FieldContentID).
			Where(contentepisode.TypeEQ(property.ContentAudio), contentepisode.ContentIDNotIn(ignoreContentIDs...), contentepisode.IDNotIn(ignoreEpisodeIDs...)).
			Order(func(s *sql.Selector) {
				s.OrderBy("RANDOM()")
			}).First(ctx)
		if err != nil && !ent.IsNotFound(err) {
			r.logger.Error("failed to get random audio content episode", zap.Error(err))
			return nil, fmt.Errorf("internal server error")
		}

		if episodeObj != nil {
			contentObj, err := r.client.Content.Get(ctx, episodeObj.ContentID)
			if err != nil {
				r.logger.Error("failed to get random audio content", zap.Error(err))
				return nil, fmt.Errorf("internal server error")
			}

			episodeObj, err = r.client.ContentEpisode.Query().
				Where(contentepisode.ContentID(contentObj.ID)).
				Order(ent.Asc(contentepisode.FieldOrder)).
				First(ctx)
			if err != nil && !ent.IsNotFound(err) {
				r.logger.Error("failed to get random audio content episode", zap.Error(err))
				return nil, fmt.Errorf("internal server error")
			}

			if episodeObj != nil {
				episodes = append(episodes, episodeObj)
			}
		}
	}

	if !videoFound {
		// get random unfinished episode
		episodeObj, err := r.client.ContentEpisode.Query().
			Select(contentepisode.FieldContentID).
			Where(contentepisode.TypeEQ(property.ContentVideo), contentepisode.ContentIDNotIn(ignoreContentIDs...), contentepisode.IDNotIn(ignoreEpisodeIDs...)).
			WithContent(func(query *ent.ContentQuery) {
				query.Where(content.IsHidden(false))
			}).
			Order(func(s *sql.Selector) {
				s.OrderBy("RANDOM()")
			}).First(ctx)
		if err != nil && !ent.IsNotFound(err) {
			r.logger.Error("failed to get random video content episode", zap.Error(err))
			return nil, fmt.Errorf("internal server error")
		}

		if episodeObj != nil {
			contentObj, err := r.client.Content.Get(ctx, episodeObj.ContentID)
			if err != nil {
				r.logger.Error("failed to get random video content", zap.Error(err))
				return nil, fmt.Errorf("internal server error")
			}

			episodeObj, err = r.client.ContentEpisode.Query().
				Where(contentepisode.ContentID(contentObj.ID)).
				Order(ent.Asc(contentepisode.FieldOrder)).
				First(ctx)
			if err != nil && !ent.IsNotFound(err) {
				r.logger.Error("failed to get random video content episode", zap.Error(err))
				return nil, fmt.Errorf("internal server error")
			}

			if episodeObj != nil {
				episodes = append(episodes, episodeObj)
			}
		}
	}

	return episodes, nil
}

// ActiveEpisode is the resolver for the activeEpisode field.
func (r *queryResolver) ActiveEpisode(ctx context.Context, contentID gqlid.Base64ID) (*ent.ContentEpisode, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	id, err := gqlid.NewContentIDFromBase64(&contentID)
	if err != nil {
		return nil, err
	}

	return r.activeEpisode(ctx, authenticatedUser, *id)
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) activeEpisode(
	ctx context.Context,
	authenticatedUser *ent.User,
	contentID gqlid.ContentID,
) (*ent.ContentEpisode, error) {
	lastContentProgress, err := r.client.ContentProgress.Query().
		Select(contentprogress.FieldEpisodeID, contentprogress.FieldFinishedAt).
		Where(contentprogress.UserID(authenticatedUser.ID), contentprogress.ContentID(contentID)).
		Order(ent.Desc(contentprogress.FieldUpdatedAt)).
		First(ctx)
	if err != nil && !ent.IsNotFound(err) {
		r.logger.Error("failed to get last content progress", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	if lastContentProgress == nil {
		episode, err := r.client.ContentEpisode.Query().
			Where(contentepisode.ContentID(contentID), contentepisode.IsHidden(false)).
			Order(ent.Asc(contentepisode.FieldOrder)).
			First(ctx)
		if err != nil && !ent.IsNotFound(err) {
			r.logger.Error("failed to get first content episode", zap.Error(err), zap.Int64("content_id", contentID.ID))
			return nil, fmt.Errorf("internal server error")
		}

		return episode, nil
	}

	episode, err := r.client.ContentEpisode.Get(ctx, lastContentProgress.EpisodeID)
	if err != nil {
		r.logger.Error("failed to get content episode", zap.Error(err), zap.Int64("episode_id", lastContentProgress.EpisodeID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	if lastContentProgress.FinishedAt == nil && !episode.IsHidden {
		return episode, nil
	}

	nextEpisode, err := r.contentProgress.NextEpisode(ctx, authenticatedUser, episode)
	if err != nil {
		r.logger.Error("failed to get next content episode", zap.Error(err), zap.Int64("episode_id", lastContentProgress.EpisodeID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	return nextEpisode, nil
}
