package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"sort"

	"github.com/jhana-app/jhana-app/ent"
	"github.com/jhana-app/jhana-app/ent/dataloaders"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/internal/authctx"
	"go.uber.org/zap"
)

// LessonsTotal is the resolver for the lessonsTotal field.
func (r *unitResolver) LessonsTotal(ctx context.Context, obj *ent.Unit) (int, error) {
	return obj.Days, nil
}

// LessonsCompleted is the resolver for the lessonsCompleted field.
func (r *unitResolver) LessonsCompleted(ctx context.Context, obj *ent.Unit) (int, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	completed, err := dataloaders.MustGet(ctx).LessonsFinished.Load(gqlid.NewUnitProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil {
		r.logger.Error("failed to count completed lessons", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("unit_id", obj.ID.ID))
		return 0, fmt.Errorf("internal server error")
	}

	return completed, nil
}

// IsActive is the resolver for the isActive field.
func (r *unitResolver) IsActive(ctx context.Context, obj *ent.Unit) (bool, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	isActive, err := dataloaders.MustGet(ctx).UnitIsActive.Load(gqlid.NewUnitProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil {
		r.logger.Error("failed to check if unit is active", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("unit_id", obj.ID.ID))
		return false, fmt.Errorf("internal server error")
	}

	return isActive, nil
}

// NextUnit is the resolver for the nextUnit field.
func (r *unitResolver) NextUnit(ctx context.Context, obj *ent.Unit) (*ent.Unit, error) {
	nextUnit, err := r.client.Unit.Query().
		Where(unit.OrderGT(obj.Order)).
		Order(ent.Asc(unit.FieldOrder)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}

		r.logger.Error("failed to query next unit", zap.Error(err), zap.Int64("unit_id", obj.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	return nextUnit, nil
}

// Techniques is the resolver for the techniques field.
func (r *unitResolver) Techniques(ctx context.Context, obj *ent.Unit) ([]*ent.Technique, error) {
	unitTechniques, err := dataloaders.MustGet(ctx).UnitTechniques.Load(obj.ID)
	if err != nil {
		r.logger.Error("failed to get units techniques", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	sort.Slice(unitTechniques, func(i, j int) bool {
		return unitTechniques[i].Position < unitTechniques[j].Position
	})

	var techniques = make([]*ent.Technique, 0, len(unitTechniques))
	for _, t := range unitTechniques {
		techniques = append(techniques, t.Edges.Technique)
	}

	sort.Slice(techniques, func(i, j int) bool {
		return techniques[i].Order < techniques[j].Order
	})

	return techniques, nil
}

// UnitTechniques is the resolver for the unitTechniques field.
func (r *unitResolver) UnitTechniques(ctx context.Context, obj *ent.Unit) ([]*ent.UnitTechnique, error) {
	unitTechniques, err := dataloaders.MustGet(ctx).UnitTechniques.Load(obj.ID)
	if err != nil {
		r.logger.Error("failed to get units techniques", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	sort.Slice(unitTechniques, func(i, j int) bool {
		return unitTechniques[i].Position < unitTechniques[j].Position
	})

	return unitTechniques, nil
}
