package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"math"
	"sort"
	"time"

	"github.com/jhana-app/jhana-app/ent"
	"github.com/jhana-app/jhana-app/ent/journalrecord"
	"github.com/jhana-app/jhana-app/internal/authctx"
	"go.uber.org/zap"
)

// MeditationsStats is the resolver for the meditationsStats field.
func (r *queryResolver) MeditationsStats(ctx context.Context, input MeditationsStatsInput) (*MeditationsStats, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		r.logger.Error("failed to get user from context", zap.Error(err))
		return nil, fmt.Errorf("user is not authorized")
	}
	logger := r.logger.With(zap.Int64("user_id", authenticatedUser.ID.ID), zap.String("user_timezone", input.UserTimezone))

	loc, err := time.LoadLocation(input.UserTimezone)
	if err != nil {
		logger.Error("failed to load user location", zap.Error(err))
		loc = time.UTC
	}

	records, err := r.client.JournalRecord.Query().
		Select(journalrecord.FieldDateTime, journalrecord.FieldDuration).
		Where(journalrecord.UserID(authenticatedUser.ID)).
		Order(ent.Desc(journalrecord.FieldDateTime)).
		All(ctx)
	if err != nil {
		logger.Error("failed to get user journal records", zap.Error(err))
		return nil, fmt.Errorf("failed to get meditations stats")
	}

	asDate := func(t time.Time) time.Time {
		t = t.In(loc)
		return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.UTC)
	}

	isSameDate := func(t1, t2 time.Time) bool {
		t1 = t1.In(loc)
		t2 = t2.In(loc)
		return t1.Year() == t2.Year() && t1.Month() == t2.Month() && t1.Day() == t2.Day()
	}

	var (
		secondsTotal  int
		sessionsTotal int
		uniqDates     = make(map[int64]bool)
	)

	for _, record := range records {
		secondsTotal += record.Duration
		sessionsTotal++
		uniqDates[asDate(record.DateTime).Unix()] = true
	}

	var (
		currentStrike      int
		dates              = make([]time.Time, 0, len(uniqDates))
		lastMeditationDate *string
		lastDate           = asDate(time.Now())
	)

	for dateTs := range uniqDates {
		dates = append(dates, time.Unix(dateTs, 0))
	}
	sort.Slice(dates, func(i, j int) bool {
		return dates[j].Before(dates[i]) // reverse order
	})

	for i, date := range dates {
		if i == 0 {
			firstDateStr := date.Format("2006-01-02")
			lastMeditationDate = &firstDateStr
		}
		if isSameDate(date, lastDate) || (i == 0 && isSameDate(date, lastDate.AddDate(0, 0, -1))) {
			currentStrike++
			lastDate = date.AddDate(0, 0, -1)
		} else {
			break
		}
	}

	res := &MeditationsStats{
		HoursTotal:    int(math.Round(float64(secondsTotal) / 3600)),
		SessionsTotal: sessionsTotal,
		CurrentStrike: currentStrike,
	}

	if lastMeditationDate != nil {
		res.LastMeditationDate = lastMeditationDate
	}

	return res, nil
}
