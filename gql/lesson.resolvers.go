package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"sort"
	"time"

	"github.com/jhana-app/jhana-app/ent"
	"github.com/jhana-app/jhana-app/ent/dataloaders"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/lesson"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/ent/userprogress"
	"github.com/jhana-app/jhana-app/internal/authctx"
	"go.uber.org/zap"
)

// IsLast is the resolver for the isLast field.
func (r *lessonResolver) IsLast(ctx context.Context, obj *ent.Lesson) (bool, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	progress, err := dataloaders.MustGet(ctx).UserProgress.Load(gqlid.NewUserProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil && !ent.IsNotFound(err) {
		r.logger.Error("failed to get user progress on lesson", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("lesson_id", obj.ID.ID))
		return false, fmt.Errorf("internal server error")
	}

	return progress != nil && progress.IsLast, nil
}

// IsNext is the resolver for the isNext field.
func (r *lessonResolver) IsNext(ctx context.Context, obj *ent.Lesson) (bool, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return false, nil
	}

	progress, err := dataloaders.MustGet(ctx).UserProgress.Load(gqlid.NewUserProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil && !ent.IsNotFound(err) {
		r.logger.Error("failed to get user progress on lesson", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("lesson_id", obj.ID.ID))
		return false, fmt.Errorf("internal server error")
	}

	return progress != nil && progress.IsNext, nil
}

// Progress is the resolver for the progress field.
func (r *lessonResolver) Progress(ctx context.Context, obj *ent.Lesson) (int, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return 0, nil
	}

	progress, err := dataloaders.MustGet(ctx).UserProgress.Load(gqlid.NewUserProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil && !ent.IsNotFound(err) {
		r.logger.Error("failed to get user progress on lesson", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("lesson_id", obj.ID.ID))
		return 0, fmt.Errorf("internal server error")
	}

	if progress == nil {
		return 0, nil
	}

	return int(progress.Progress), nil
}

// FinishedAt is the resolver for the finishedAt field.
func (r *lessonResolver) FinishedAt(ctx context.Context, obj *ent.Lesson) (*time.Time, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	progress, err := dataloaders.MustGet(ctx).UserProgress.Load(gqlid.NewUserProgressKey(authenticatedUser.ID, obj.ID))
	if err != nil && !ent.IsNotFound(err) {
		r.logger.Error("failed to get user progress on lesson", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("lesson_id", obj.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	if progress == nil {
		return nil, nil
	}

	return progress.FinishedAt, nil
}

// Techniques is the resolver for the techniques field.
func (r *lessonResolver) Techniques(ctx context.Context, obj *ent.Lesson) ([]*ent.Technique, error) {
	lessonTechniques, err := dataloaders.MustGet(ctx).LessonTechniques.Load(obj.ID)
	if err != nil {
		r.logger.Error("failed to get lessons techniques", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	sort.Slice(lessonTechniques, func(i, j int) bool {
		return lessonTechniques[i].Order < lessonTechniques[j].Order
	})

	var techniques = make([]*ent.Technique, 0, len(lessonTechniques))
	for _, lessonTechnique := range lessonTechniques {
		techniques = append(techniques, lessonTechnique.Edges.Technique)
	}

	sort.Slice(techniques, func(i, j int) bool {
		return techniques[i].Order < techniques[j].Order
	})

	return techniques, nil
}

// LessonTechniques is the resolver for the lessonTechniques field.
func (r *lessonResolver) LessonTechniques(ctx context.Context, obj *ent.Lesson) ([]*ent.LessonTechnique, error) {
	lessonTechniques, err := dataloaders.MustGet(ctx).LessonTechniques.Load(obj.ID)
	if err != nil {
		r.logger.Error("failed to get lessons techniques", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	sort.Slice(lessonTechniques, func(i, j int) bool {
		return lessonTechniques[i].Order < lessonTechniques[j].Order
	})

	return lessonTechniques, nil
}

// Audios is the resolver for the audios field.
func (r *lessonResolver) Audios(ctx context.Context, obj *ent.Lesson) ([]*ent.LessonAudio, error) {
	audios, err := dataloaders.MustGet(ctx).LessonAudios.Load(obj.ID)
	if err != nil {
		r.logger.Error("failed to get lessons audios", zap.Error(err))
		return nil, fmt.Errorf("internal server error")
	}

	sort.Slice(audios, func(i, j int) bool {
		return audios[i].Duration < audios[j].Duration
	})

	return audios, nil
}

// ActiveLessons is the resolver for the activeLessons field.
func (r *queryResolver) ActiveLessons(ctx context.Context) ([]*ent.Lesson, error) {
	authenticatedUser, err := authctx.GetUser(ctx)
	if err != nil {
		return nil, nil
	}

	courses, err := r.client.Course.Query().All(ctx)
	if err != nil {
		r.logger.Error("failed to get courses", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID))
		return nil, fmt.Errorf("internal server error")
	}

	var lessonIDs []gqlid.LessonID
	for _, c := range courses {
		courseProgress, err := r.client.UserProgress.Query().
			Select(userprogress.FieldLessonID, userprogress.FieldIsLast, userprogress.FieldIsNext).
			Where(
				userprogress.UserID(authenticatedUser.ID),
				userprogress.CourseID(c.ID),
				userprogress.Or(
					userprogress.IsNext(true),
					userprogress.And(
						userprogress.IsLast(true),
						userprogress.FinishedAtGTE(time.Now().Add(-24*time.Hour)),
					),
				),
			).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get user progress", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID))
			return nil, fmt.Errorf("internal server error")
		}

		isLast := false
		for _, cp := range courseProgress {
			if cp.IsLast {
				lessonIDs = append(lessonIDs, cp.LessonID)
				isLast = true
				break
			}
		}
		if isLast {
			continue
		}

		isNext := false
		for _, cp := range courseProgress {
			if cp.IsNext {
				lessonIDs = append(lessonIDs, cp.LessonID)
				isNext = true
				break
			}
		}
		if isNext {
			continue
		}

		firstUnits, err := r.client.Unit.Query().
			Select(unit.FieldID).
			Where(unit.CourseID(c.ID)).
			Order(ent.Asc(unit.FieldOrder)).
			Limit(1).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get course first unit", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("course_id", c.ID.ID))
			return nil, fmt.Errorf("internal server error")
		}

		if len(firstUnits) == 0 {
			continue
		}

		firstLessons, err := r.client.Lesson.Query().
			Select(lesson.FieldID).
			Where(lesson.UnitID(firstUnits[0].ID)).
			Order(ent.Asc(lesson.FieldOrder)).
			Limit(1).
			All(ctx)
		if err != nil {
			r.logger.Error("failed to get unit first lesson", zap.Error(err), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("unit_id", firstUnits[0].ID.ID))
			return nil, fmt.Errorf("internal server error")
		}

		lessonIDs = append(lessonIDs, firstLessons[0].ID)
	}

	var lessons []*ent.Lesson
	lessonItems, errors := dataloaders.MustGet(ctx).Lesson.LoadAll(lessonIDs)
	for i, l := range lessonItems {
		if errors[i] != nil {
			r.logger.Error("failed to get lesson", zap.Error(errors[i]), zap.Int64("user_id", authenticatedUser.ID.ID), zap.Int64("lesson_id", lessonIDs[i].ID))
			return nil, fmt.Errorf("internal server error")
		}
		lessons = append(lessons, l)
	}

	return lessons, nil
}
