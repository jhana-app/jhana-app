// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/jhana-app/jhana-app/ent/content"
	"github.com/jhana-app/jhana-app/ent/contentepisode"
	"github.com/jhana-app/jhana-app/ent/contentprogress"
	"github.com/jhana-app/jhana-app/ent/course"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/journalrecord"
	"github.com/jhana-app/jhana-app/ent/lesson"
	"github.com/jhana-app/jhana-app/ent/lessonaudio"
	"github.com/jhana-app/jhana-app/ent/predicate"
	"github.com/jhana-app/jhana-app/ent/property"
	"github.com/jhana-app/jhana-app/ent/technique"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/ent/user"
	"github.com/jhana-app/jhana-app/ent/userprogress"
)

// ContentWhereInput represents a where input for filtering Content queries.
type ContentWhereInput struct {
	Predicates []predicate.Content  `json:"-"`
	Not        *ContentWhereInput   `json:"not,omitempty"`
	Or         []*ContentWhereInput `json:"or,omitempty"`
	And        []*ContentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.ContentID  `json:"id,omitempty"`
	IDNEQ   *gqlid.ContentID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.ContentID `json:"idIn,omitempty"`
	IDNotIn []gqlid.ContentID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.ContentID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.ContentID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.ContentID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.ContentID  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *property.ContentType  `json:"type,omitempty"`
	TypeNEQ   *property.ContentType  `json:"typeNEQ,omitempty"`
	TypeIn    []property.ContentType `json:"typeIn,omitempty"`
	TypeNotIn []property.ContentType `json:"typeNotIn,omitempty"`

	// "iconImage" field predicates.
	IconImage             *string  `json:"iconimage,omitempty"`
	IconImageNEQ          *string  `json:"iconimageNEQ,omitempty"`
	IconImageIn           []string `json:"iconimageIn,omitempty"`
	IconImageNotIn        []string `json:"iconimageNotIn,omitempty"`
	IconImageGT           *string  `json:"iconimageGT,omitempty"`
	IconImageGTE          *string  `json:"iconimageGTE,omitempty"`
	IconImageLT           *string  `json:"iconimageLT,omitempty"`
	IconImageLTE          *string  `json:"iconimageLTE,omitempty"`
	IconImageContains     *string  `json:"iconimageContains,omitempty"`
	IconImageHasPrefix    *string  `json:"iconimageHasPrefix,omitempty"`
	IconImageHasSuffix    *string  `json:"iconimageHasSuffix,omitempty"`
	IconImageEqualFold    *string  `json:"iconimageEqualFold,omitempty"`
	IconImageContainsFold *string  `json:"iconimageContainsFold,omitempty"`

	// "coverImage" field predicates.
	CoverImage             *string  `json:"coverimage,omitempty"`
	CoverImageNEQ          *string  `json:"coverimageNEQ,omitempty"`
	CoverImageIn           []string `json:"coverimageIn,omitempty"`
	CoverImageNotIn        []string `json:"coverimageNotIn,omitempty"`
	CoverImageGT           *string  `json:"coverimageGT,omitempty"`
	CoverImageGTE          *string  `json:"coverimageGTE,omitempty"`
	CoverImageLT           *string  `json:"coverimageLT,omitempty"`
	CoverImageLTE          *string  `json:"coverimageLTE,omitempty"`
	CoverImageContains     *string  `json:"coverimageContains,omitempty"`
	CoverImageHasPrefix    *string  `json:"coverimageHasPrefix,omitempty"`
	CoverImageHasSuffix    *string  `json:"coverimageHasSuffix,omitempty"`
	CoverImageEqualFold    *string  `json:"coverimageEqualFold,omitempty"`
	CoverImageContainsFold *string  `json:"coverimageContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "subtitle" field predicates.
	Subtitle             *string  `json:"subtitle,omitempty"`
	SubtitleNEQ          *string  `json:"subtitleNEQ,omitempty"`
	SubtitleIn           []string `json:"subtitleIn,omitempty"`
	SubtitleNotIn        []string `json:"subtitleNotIn,omitempty"`
	SubtitleGT           *string  `json:"subtitleGT,omitempty"`
	SubtitleGTE          *string  `json:"subtitleGTE,omitempty"`
	SubtitleLT           *string  `json:"subtitleLT,omitempty"`
	SubtitleLTE          *string  `json:"subtitleLTE,omitempty"`
	SubtitleContains     *string  `json:"subtitleContains,omitempty"`
	SubtitleHasPrefix    *string  `json:"subtitleHasPrefix,omitempty"`
	SubtitleHasSuffix    *string  `json:"subtitleHasSuffix,omitempty"`
	SubtitleEqualFold    *string  `json:"subtitleEqualFold,omitempty"`
	SubtitleContainsFold *string  `json:"subtitleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "sourceURL" field predicates.
	SourceURL             *string  `json:"sourceurl,omitempty"`
	SourceURLNEQ          *string  `json:"sourceurlNEQ,omitempty"`
	SourceURLIn           []string `json:"sourceurlIn,omitempty"`
	SourceURLNotIn        []string `json:"sourceurlNotIn,omitempty"`
	SourceURLGT           *string  `json:"sourceurlGT,omitempty"`
	SourceURLGTE          *string  `json:"sourceurlGTE,omitempty"`
	SourceURLLT           *string  `json:"sourceurlLT,omitempty"`
	SourceURLLTE          *string  `json:"sourceurlLTE,omitempty"`
	SourceURLContains     *string  `json:"sourceurlContains,omitempty"`
	SourceURLHasPrefix    *string  `json:"sourceurlHasPrefix,omitempty"`
	SourceURLHasSuffix    *string  `json:"sourceurlHasSuffix,omitempty"`
	SourceURLEqualFold    *string  `json:"sourceurlEqualFold,omitempty"`
	SourceURLContainsFold *string  `json:"sourceurlContainsFold,omitempty"`

	// "licence" field predicates.
	Licence             *string  `json:"licence,omitempty"`
	LicenceNEQ          *string  `json:"licenceNEQ,omitempty"`
	LicenceIn           []string `json:"licenceIn,omitempty"`
	LicenceNotIn        []string `json:"licenceNotIn,omitempty"`
	LicenceGT           *string  `json:"licenceGT,omitempty"`
	LicenceGTE          *string  `json:"licenceGTE,omitempty"`
	LicenceLT           *string  `json:"licenceLT,omitempty"`
	LicenceLTE          *string  `json:"licenceLTE,omitempty"`
	LicenceContains     *string  `json:"licenceContains,omitempty"`
	LicenceHasPrefix    *string  `json:"licenceHasPrefix,omitempty"`
	LicenceHasSuffix    *string  `json:"licenceHasSuffix,omitempty"`
	LicenceEqualFold    *string  `json:"licenceEqualFold,omitempty"`
	LicenceContainsFold *string  `json:"licenceContainsFold,omitempty"`

	// "licenceURL" field predicates.
	LicenceURL             *string  `json:"licenceurl,omitempty"`
	LicenceURLNEQ          *string  `json:"licenceurlNEQ,omitempty"`
	LicenceURLIn           []string `json:"licenceurlIn,omitempty"`
	LicenceURLNotIn        []string `json:"licenceurlNotIn,omitempty"`
	LicenceURLGT           *string  `json:"licenceurlGT,omitempty"`
	LicenceURLGTE          *string  `json:"licenceurlGTE,omitempty"`
	LicenceURLLT           *string  `json:"licenceurlLT,omitempty"`
	LicenceURLLTE          *string  `json:"licenceurlLTE,omitempty"`
	LicenceURLContains     *string  `json:"licenceurlContains,omitempty"`
	LicenceURLHasPrefix    *string  `json:"licenceurlHasPrefix,omitempty"`
	LicenceURLHasSuffix    *string  `json:"licenceurlHasSuffix,omitempty"`
	LicenceURLEqualFold    *string  `json:"licenceurlEqualFold,omitempty"`
	LicenceURLContainsFold *string  `json:"licenceurlContainsFold,omitempty"`

	// "isHidden" field predicates.
	IsHidden    *bool `json:"ishidden,omitempty"`
	IsHiddenNEQ *bool `json:"ishiddenNEQ,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "episodesCount" field predicates.
	EpisodesCount      *int  `json:"episodescount,omitempty"`
	EpisodesCountNEQ   *int  `json:"episodescountNEQ,omitempty"`
	EpisodesCountIn    []int `json:"episodescountIn,omitempty"`
	EpisodesCountNotIn []int `json:"episodescountNotIn,omitempty"`
	EpisodesCountGT    *int  `json:"episodescountGT,omitempty"`
	EpisodesCountGTE   *int  `json:"episodescountGTE,omitempty"`
	EpisodesCountLT    *int  `json:"episodescountLT,omitempty"`
	EpisodesCountLTE   *int  `json:"episodescountLTE,omitempty"`

	// "episodes" edge predicates.
	HasEpisodes     *bool                       `json:"hasEpisodes,omitempty"`
	HasEpisodesWith []*ContentEpisodeWhereInput `json:"hasEpisodesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContentWhereInput) AddPredicates(predicates ...predicate.Content) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContentWhereInput filter on the ContentQuery builder.
func (i *ContentWhereInput) Filter(q *ContentQuery) (*ContentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContentWhereInput is returned in case the ContentWhereInput is empty.
var ErrEmptyContentWhereInput = errors.New("ent: empty predicate ContentWhereInput")

// P returns a predicate for filtering contents.
// An error is returned if the input is empty or invalid.
func (i *ContentWhereInput) P() (predicate.Content, error) {
	var predicates []predicate.Content
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, content.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Content, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, content.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Content, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, content.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, content.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, content.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, content.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, content.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, content.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, content.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, content.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, content.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, content.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, content.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, content.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, content.TypeNotIn(i.TypeNotIn...))
	}
	if i.IconImage != nil {
		predicates = append(predicates, content.IconImageEQ(*i.IconImage))
	}
	if i.IconImageNEQ != nil {
		predicates = append(predicates, content.IconImageNEQ(*i.IconImageNEQ))
	}
	if len(i.IconImageIn) > 0 {
		predicates = append(predicates, content.IconImageIn(i.IconImageIn...))
	}
	if len(i.IconImageNotIn) > 0 {
		predicates = append(predicates, content.IconImageNotIn(i.IconImageNotIn...))
	}
	if i.IconImageGT != nil {
		predicates = append(predicates, content.IconImageGT(*i.IconImageGT))
	}
	if i.IconImageGTE != nil {
		predicates = append(predicates, content.IconImageGTE(*i.IconImageGTE))
	}
	if i.IconImageLT != nil {
		predicates = append(predicates, content.IconImageLT(*i.IconImageLT))
	}
	if i.IconImageLTE != nil {
		predicates = append(predicates, content.IconImageLTE(*i.IconImageLTE))
	}
	if i.IconImageContains != nil {
		predicates = append(predicates, content.IconImageContains(*i.IconImageContains))
	}
	if i.IconImageHasPrefix != nil {
		predicates = append(predicates, content.IconImageHasPrefix(*i.IconImageHasPrefix))
	}
	if i.IconImageHasSuffix != nil {
		predicates = append(predicates, content.IconImageHasSuffix(*i.IconImageHasSuffix))
	}
	if i.IconImageEqualFold != nil {
		predicates = append(predicates, content.IconImageEqualFold(*i.IconImageEqualFold))
	}
	if i.IconImageContainsFold != nil {
		predicates = append(predicates, content.IconImageContainsFold(*i.IconImageContainsFold))
	}
	if i.CoverImage != nil {
		predicates = append(predicates, content.CoverImageEQ(*i.CoverImage))
	}
	if i.CoverImageNEQ != nil {
		predicates = append(predicates, content.CoverImageNEQ(*i.CoverImageNEQ))
	}
	if len(i.CoverImageIn) > 0 {
		predicates = append(predicates, content.CoverImageIn(i.CoverImageIn...))
	}
	if len(i.CoverImageNotIn) > 0 {
		predicates = append(predicates, content.CoverImageNotIn(i.CoverImageNotIn...))
	}
	if i.CoverImageGT != nil {
		predicates = append(predicates, content.CoverImageGT(*i.CoverImageGT))
	}
	if i.CoverImageGTE != nil {
		predicates = append(predicates, content.CoverImageGTE(*i.CoverImageGTE))
	}
	if i.CoverImageLT != nil {
		predicates = append(predicates, content.CoverImageLT(*i.CoverImageLT))
	}
	if i.CoverImageLTE != nil {
		predicates = append(predicates, content.CoverImageLTE(*i.CoverImageLTE))
	}
	if i.CoverImageContains != nil {
		predicates = append(predicates, content.CoverImageContains(*i.CoverImageContains))
	}
	if i.CoverImageHasPrefix != nil {
		predicates = append(predicates, content.CoverImageHasPrefix(*i.CoverImageHasPrefix))
	}
	if i.CoverImageHasSuffix != nil {
		predicates = append(predicates, content.CoverImageHasSuffix(*i.CoverImageHasSuffix))
	}
	if i.CoverImageEqualFold != nil {
		predicates = append(predicates, content.CoverImageEqualFold(*i.CoverImageEqualFold))
	}
	if i.CoverImageContainsFold != nil {
		predicates = append(predicates, content.CoverImageContainsFold(*i.CoverImageContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, content.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, content.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, content.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, content.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, content.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, content.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, content.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, content.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, content.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, content.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, content.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, content.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, content.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Subtitle != nil {
		predicates = append(predicates, content.SubtitleEQ(*i.Subtitle))
	}
	if i.SubtitleNEQ != nil {
		predicates = append(predicates, content.SubtitleNEQ(*i.SubtitleNEQ))
	}
	if len(i.SubtitleIn) > 0 {
		predicates = append(predicates, content.SubtitleIn(i.SubtitleIn...))
	}
	if len(i.SubtitleNotIn) > 0 {
		predicates = append(predicates, content.SubtitleNotIn(i.SubtitleNotIn...))
	}
	if i.SubtitleGT != nil {
		predicates = append(predicates, content.SubtitleGT(*i.SubtitleGT))
	}
	if i.SubtitleGTE != nil {
		predicates = append(predicates, content.SubtitleGTE(*i.SubtitleGTE))
	}
	if i.SubtitleLT != nil {
		predicates = append(predicates, content.SubtitleLT(*i.SubtitleLT))
	}
	if i.SubtitleLTE != nil {
		predicates = append(predicates, content.SubtitleLTE(*i.SubtitleLTE))
	}
	if i.SubtitleContains != nil {
		predicates = append(predicates, content.SubtitleContains(*i.SubtitleContains))
	}
	if i.SubtitleHasPrefix != nil {
		predicates = append(predicates, content.SubtitleHasPrefix(*i.SubtitleHasPrefix))
	}
	if i.SubtitleHasSuffix != nil {
		predicates = append(predicates, content.SubtitleHasSuffix(*i.SubtitleHasSuffix))
	}
	if i.SubtitleEqualFold != nil {
		predicates = append(predicates, content.SubtitleEqualFold(*i.SubtitleEqualFold))
	}
	if i.SubtitleContainsFold != nil {
		predicates = append(predicates, content.SubtitleContainsFold(*i.SubtitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, content.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, content.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, content.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, content.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, content.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, content.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, content.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, content.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, content.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, content.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, content.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, content.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, content.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, content.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, content.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, content.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, content.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, content.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, content.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, content.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, content.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, content.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, content.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, content.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, content.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, content.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.SourceURL != nil {
		predicates = append(predicates, content.SourceURLEQ(*i.SourceURL))
	}
	if i.SourceURLNEQ != nil {
		predicates = append(predicates, content.SourceURLNEQ(*i.SourceURLNEQ))
	}
	if len(i.SourceURLIn) > 0 {
		predicates = append(predicates, content.SourceURLIn(i.SourceURLIn...))
	}
	if len(i.SourceURLNotIn) > 0 {
		predicates = append(predicates, content.SourceURLNotIn(i.SourceURLNotIn...))
	}
	if i.SourceURLGT != nil {
		predicates = append(predicates, content.SourceURLGT(*i.SourceURLGT))
	}
	if i.SourceURLGTE != nil {
		predicates = append(predicates, content.SourceURLGTE(*i.SourceURLGTE))
	}
	if i.SourceURLLT != nil {
		predicates = append(predicates, content.SourceURLLT(*i.SourceURLLT))
	}
	if i.SourceURLLTE != nil {
		predicates = append(predicates, content.SourceURLLTE(*i.SourceURLLTE))
	}
	if i.SourceURLContains != nil {
		predicates = append(predicates, content.SourceURLContains(*i.SourceURLContains))
	}
	if i.SourceURLHasPrefix != nil {
		predicates = append(predicates, content.SourceURLHasPrefix(*i.SourceURLHasPrefix))
	}
	if i.SourceURLHasSuffix != nil {
		predicates = append(predicates, content.SourceURLHasSuffix(*i.SourceURLHasSuffix))
	}
	if i.SourceURLEqualFold != nil {
		predicates = append(predicates, content.SourceURLEqualFold(*i.SourceURLEqualFold))
	}
	if i.SourceURLContainsFold != nil {
		predicates = append(predicates, content.SourceURLContainsFold(*i.SourceURLContainsFold))
	}
	if i.Licence != nil {
		predicates = append(predicates, content.LicenceEQ(*i.Licence))
	}
	if i.LicenceNEQ != nil {
		predicates = append(predicates, content.LicenceNEQ(*i.LicenceNEQ))
	}
	if len(i.LicenceIn) > 0 {
		predicates = append(predicates, content.LicenceIn(i.LicenceIn...))
	}
	if len(i.LicenceNotIn) > 0 {
		predicates = append(predicates, content.LicenceNotIn(i.LicenceNotIn...))
	}
	if i.LicenceGT != nil {
		predicates = append(predicates, content.LicenceGT(*i.LicenceGT))
	}
	if i.LicenceGTE != nil {
		predicates = append(predicates, content.LicenceGTE(*i.LicenceGTE))
	}
	if i.LicenceLT != nil {
		predicates = append(predicates, content.LicenceLT(*i.LicenceLT))
	}
	if i.LicenceLTE != nil {
		predicates = append(predicates, content.LicenceLTE(*i.LicenceLTE))
	}
	if i.LicenceContains != nil {
		predicates = append(predicates, content.LicenceContains(*i.LicenceContains))
	}
	if i.LicenceHasPrefix != nil {
		predicates = append(predicates, content.LicenceHasPrefix(*i.LicenceHasPrefix))
	}
	if i.LicenceHasSuffix != nil {
		predicates = append(predicates, content.LicenceHasSuffix(*i.LicenceHasSuffix))
	}
	if i.LicenceEqualFold != nil {
		predicates = append(predicates, content.LicenceEqualFold(*i.LicenceEqualFold))
	}
	if i.LicenceContainsFold != nil {
		predicates = append(predicates, content.LicenceContainsFold(*i.LicenceContainsFold))
	}
	if i.LicenceURL != nil {
		predicates = append(predicates, content.LicenceURLEQ(*i.LicenceURL))
	}
	if i.LicenceURLNEQ != nil {
		predicates = append(predicates, content.LicenceURLNEQ(*i.LicenceURLNEQ))
	}
	if len(i.LicenceURLIn) > 0 {
		predicates = append(predicates, content.LicenceURLIn(i.LicenceURLIn...))
	}
	if len(i.LicenceURLNotIn) > 0 {
		predicates = append(predicates, content.LicenceURLNotIn(i.LicenceURLNotIn...))
	}
	if i.LicenceURLGT != nil {
		predicates = append(predicates, content.LicenceURLGT(*i.LicenceURLGT))
	}
	if i.LicenceURLGTE != nil {
		predicates = append(predicates, content.LicenceURLGTE(*i.LicenceURLGTE))
	}
	if i.LicenceURLLT != nil {
		predicates = append(predicates, content.LicenceURLLT(*i.LicenceURLLT))
	}
	if i.LicenceURLLTE != nil {
		predicates = append(predicates, content.LicenceURLLTE(*i.LicenceURLLTE))
	}
	if i.LicenceURLContains != nil {
		predicates = append(predicates, content.LicenceURLContains(*i.LicenceURLContains))
	}
	if i.LicenceURLHasPrefix != nil {
		predicates = append(predicates, content.LicenceURLHasPrefix(*i.LicenceURLHasPrefix))
	}
	if i.LicenceURLHasSuffix != nil {
		predicates = append(predicates, content.LicenceURLHasSuffix(*i.LicenceURLHasSuffix))
	}
	if i.LicenceURLEqualFold != nil {
		predicates = append(predicates, content.LicenceURLEqualFold(*i.LicenceURLEqualFold))
	}
	if i.LicenceURLContainsFold != nil {
		predicates = append(predicates, content.LicenceURLContainsFold(*i.LicenceURLContainsFold))
	}
	if i.IsHidden != nil {
		predicates = append(predicates, content.IsHiddenEQ(*i.IsHidden))
	}
	if i.IsHiddenNEQ != nil {
		predicates = append(predicates, content.IsHiddenNEQ(*i.IsHiddenNEQ))
	}
	if i.Order != nil {
		predicates = append(predicates, content.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, content.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, content.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, content.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, content.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, content.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, content.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, content.OrderLTE(*i.OrderLTE))
	}
	if i.EpisodesCount != nil {
		predicates = append(predicates, content.EpisodesCountEQ(*i.EpisodesCount))
	}
	if i.EpisodesCountNEQ != nil {
		predicates = append(predicates, content.EpisodesCountNEQ(*i.EpisodesCountNEQ))
	}
	if len(i.EpisodesCountIn) > 0 {
		predicates = append(predicates, content.EpisodesCountIn(i.EpisodesCountIn...))
	}
	if len(i.EpisodesCountNotIn) > 0 {
		predicates = append(predicates, content.EpisodesCountNotIn(i.EpisodesCountNotIn...))
	}
	if i.EpisodesCountGT != nil {
		predicates = append(predicates, content.EpisodesCountGT(*i.EpisodesCountGT))
	}
	if i.EpisodesCountGTE != nil {
		predicates = append(predicates, content.EpisodesCountGTE(*i.EpisodesCountGTE))
	}
	if i.EpisodesCountLT != nil {
		predicates = append(predicates, content.EpisodesCountLT(*i.EpisodesCountLT))
	}
	if i.EpisodesCountLTE != nil {
		predicates = append(predicates, content.EpisodesCountLTE(*i.EpisodesCountLTE))
	}

	if i.HasEpisodes != nil {
		p := content.HasEpisodes()
		if !*i.HasEpisodes {
			p = content.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpisodesWith) > 0 {
		with := make([]predicate.ContentEpisode, 0, len(i.HasEpisodesWith))
		for _, w := range i.HasEpisodesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpisodesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, content.HasEpisodesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return content.And(predicates...), nil
	}
}

// ContentEpisodeWhereInput represents a where input for filtering ContentEpisode queries.
type ContentEpisodeWhereInput struct {
	Predicates []predicate.ContentEpisode  `json:"-"`
	Not        *ContentEpisodeWhereInput   `json:"not,omitempty"`
	Or         []*ContentEpisodeWhereInput `json:"or,omitempty"`
	And        []*ContentEpisodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.ContentEpisodeID  `json:"id,omitempty"`
	IDNEQ   *gqlid.ContentEpisodeID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.ContentEpisodeID `json:"idIn,omitempty"`
	IDNotIn []gqlid.ContentEpisodeID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.ContentEpisodeID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.ContentEpisodeID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.ContentEpisodeID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.ContentEpisodeID  `json:"idLTE,omitempty"`

	// "content_id" field predicates.
	ContentID      *gqlid.ContentID  `json:"contentID,omitempty"`
	ContentIDNEQ   *gqlid.ContentID  `json:"contentIDNEQ,omitempty"`
	ContentIDIn    []gqlid.ContentID `json:"contentIDIn,omitempty"`
	ContentIDNotIn []gqlid.ContentID `json:"contentIDNotIn,omitempty"`

	// "type" field predicates.
	Type      *property.ContentType  `json:"type,omitempty"`
	TypeNEQ   *property.ContentType  `json:"typeNEQ,omitempty"`
	TypeIn    []property.ContentType `json:"typeIn,omitempty"`
	TypeNotIn []property.ContentType `json:"typeNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "subtitle" field predicates.
	Subtitle             *string  `json:"subtitle,omitempty"`
	SubtitleNEQ          *string  `json:"subtitleNEQ,omitempty"`
	SubtitleIn           []string `json:"subtitleIn,omitempty"`
	SubtitleNotIn        []string `json:"subtitleNotIn,omitempty"`
	SubtitleGT           *string  `json:"subtitleGT,omitempty"`
	SubtitleGTE          *string  `json:"subtitleGTE,omitempty"`
	SubtitleLT           *string  `json:"subtitleLT,omitempty"`
	SubtitleLTE          *string  `json:"subtitleLTE,omitempty"`
	SubtitleContains     *string  `json:"subtitleContains,omitempty"`
	SubtitleHasPrefix    *string  `json:"subtitleHasPrefix,omitempty"`
	SubtitleHasSuffix    *string  `json:"subtitleHasSuffix,omitempty"`
	SubtitleEqualFold    *string  `json:"subtitleEqualFold,omitempty"`
	SubtitleContainsFold *string  `json:"subtitleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "duration" field predicates.
	Duration      *int  `json:"duration,omitempty"`
	DurationNEQ   *int  `json:"durationNEQ,omitempty"`
	DurationIn    []int `json:"durationIn,omitempty"`
	DurationNotIn []int `json:"durationNotIn,omitempty"`
	DurationGT    *int  `json:"durationGT,omitempty"`
	DurationGTE   *int  `json:"durationGTE,omitempty"`
	DurationLT    *int  `json:"durationLT,omitempty"`
	DurationLTE   *int  `json:"durationLTE,omitempty"`

	// "streamURL" field predicates.
	StreamURL             *string  `json:"streamurl,omitempty"`
	StreamURLNEQ          *string  `json:"streamurlNEQ,omitempty"`
	StreamURLIn           []string `json:"streamurlIn,omitempty"`
	StreamURLNotIn        []string `json:"streamurlNotIn,omitempty"`
	StreamURLGT           *string  `json:"streamurlGT,omitempty"`
	StreamURLGTE          *string  `json:"streamurlGTE,omitempty"`
	StreamURLLT           *string  `json:"streamurlLT,omitempty"`
	StreamURLLTE          *string  `json:"streamurlLTE,omitempty"`
	StreamURLContains     *string  `json:"streamurlContains,omitempty"`
	StreamURLHasPrefix    *string  `json:"streamurlHasPrefix,omitempty"`
	StreamURLHasSuffix    *string  `json:"streamurlHasSuffix,omitempty"`
	StreamURLEqualFold    *string  `json:"streamurlEqualFold,omitempty"`
	StreamURLContainsFold *string  `json:"streamurlContainsFold,omitempty"`

	// "downloadURL" field predicates.
	DownloadURL             *string  `json:"downloadurl,omitempty"`
	DownloadURLNEQ          *string  `json:"downloadurlNEQ,omitempty"`
	DownloadURLIn           []string `json:"downloadurlIn,omitempty"`
	DownloadURLNotIn        []string `json:"downloadurlNotIn,omitempty"`
	DownloadURLGT           *string  `json:"downloadurlGT,omitempty"`
	DownloadURLGTE          *string  `json:"downloadurlGTE,omitempty"`
	DownloadURLLT           *string  `json:"downloadurlLT,omitempty"`
	DownloadURLLTE          *string  `json:"downloadurlLTE,omitempty"`
	DownloadURLContains     *string  `json:"downloadurlContains,omitempty"`
	DownloadURLHasPrefix    *string  `json:"downloadurlHasPrefix,omitempty"`
	DownloadURLHasSuffix    *string  `json:"downloadurlHasSuffix,omitempty"`
	DownloadURLEqualFold    *string  `json:"downloadurlEqualFold,omitempty"`
	DownloadURLContainsFold *string  `json:"downloadurlContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "sourceURL" field predicates.
	SourceURL             *string  `json:"sourceurl,omitempty"`
	SourceURLNEQ          *string  `json:"sourceurlNEQ,omitempty"`
	SourceURLIn           []string `json:"sourceurlIn,omitempty"`
	SourceURLNotIn        []string `json:"sourceurlNotIn,omitempty"`
	SourceURLGT           *string  `json:"sourceurlGT,omitempty"`
	SourceURLGTE          *string  `json:"sourceurlGTE,omitempty"`
	SourceURLLT           *string  `json:"sourceurlLT,omitempty"`
	SourceURLLTE          *string  `json:"sourceurlLTE,omitempty"`
	SourceURLContains     *string  `json:"sourceurlContains,omitempty"`
	SourceURLHasPrefix    *string  `json:"sourceurlHasPrefix,omitempty"`
	SourceURLHasSuffix    *string  `json:"sourceurlHasSuffix,omitempty"`
	SourceURLEqualFold    *string  `json:"sourceurlEqualFold,omitempty"`
	SourceURLContainsFold *string  `json:"sourceurlContainsFold,omitempty"`

	// "licence" field predicates.
	Licence             *string  `json:"licence,omitempty"`
	LicenceNEQ          *string  `json:"licenceNEQ,omitempty"`
	LicenceIn           []string `json:"licenceIn,omitempty"`
	LicenceNotIn        []string `json:"licenceNotIn,omitempty"`
	LicenceGT           *string  `json:"licenceGT,omitempty"`
	LicenceGTE          *string  `json:"licenceGTE,omitempty"`
	LicenceLT           *string  `json:"licenceLT,omitempty"`
	LicenceLTE          *string  `json:"licenceLTE,omitempty"`
	LicenceContains     *string  `json:"licenceContains,omitempty"`
	LicenceHasPrefix    *string  `json:"licenceHasPrefix,omitempty"`
	LicenceHasSuffix    *string  `json:"licenceHasSuffix,omitempty"`
	LicenceEqualFold    *string  `json:"licenceEqualFold,omitempty"`
	LicenceContainsFold *string  `json:"licenceContainsFold,omitempty"`

	// "licenceURL" field predicates.
	LicenceURL             *string  `json:"licenceurl,omitempty"`
	LicenceURLNEQ          *string  `json:"licenceurlNEQ,omitempty"`
	LicenceURLIn           []string `json:"licenceurlIn,omitempty"`
	LicenceURLNotIn        []string `json:"licenceurlNotIn,omitempty"`
	LicenceURLGT           *string  `json:"licenceurlGT,omitempty"`
	LicenceURLGTE          *string  `json:"licenceurlGTE,omitempty"`
	LicenceURLLT           *string  `json:"licenceurlLT,omitempty"`
	LicenceURLLTE          *string  `json:"licenceurlLTE,omitempty"`
	LicenceURLContains     *string  `json:"licenceurlContains,omitempty"`
	LicenceURLHasPrefix    *string  `json:"licenceurlHasPrefix,omitempty"`
	LicenceURLHasSuffix    *string  `json:"licenceurlHasSuffix,omitempty"`
	LicenceURLEqualFold    *string  `json:"licenceurlEqualFold,omitempty"`
	LicenceURLContainsFold *string  `json:"licenceurlContainsFold,omitempty"`

	// "isHidden" field predicates.
	IsHidden    *bool `json:"ishidden,omitempty"`
	IsHiddenNEQ *bool `json:"ishiddenNEQ,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "content" edge predicates.
	HasContent     *bool                `json:"hasContent,omitempty"`
	HasContentWith []*ContentWhereInput `json:"hasContentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContentEpisodeWhereInput) AddPredicates(predicates ...predicate.ContentEpisode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContentEpisodeWhereInput filter on the ContentEpisodeQuery builder.
func (i *ContentEpisodeWhereInput) Filter(q *ContentEpisodeQuery) (*ContentEpisodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContentEpisodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContentEpisodeWhereInput is returned in case the ContentEpisodeWhereInput is empty.
var ErrEmptyContentEpisodeWhereInput = errors.New("ent: empty predicate ContentEpisodeWhereInput")

// P returns a predicate for filtering contentepisodes.
// An error is returned if the input is empty or invalid.
func (i *ContentEpisodeWhereInput) P() (predicate.ContentEpisode, error) {
	var predicates []predicate.ContentEpisode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contentepisode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ContentEpisode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contentepisode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ContentEpisode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contentepisode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contentepisode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contentepisode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contentepisode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contentepisode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contentepisode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contentepisode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contentepisode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contentepisode.IDLTE(*i.IDLTE))
	}
	if i.ContentID != nil {
		predicates = append(predicates, contentepisode.ContentIDEQ(*i.ContentID))
	}
	if i.ContentIDNEQ != nil {
		predicates = append(predicates, contentepisode.ContentIDNEQ(*i.ContentIDNEQ))
	}
	if len(i.ContentIDIn) > 0 {
		predicates = append(predicates, contentepisode.ContentIDIn(i.ContentIDIn...))
	}
	if len(i.ContentIDNotIn) > 0 {
		predicates = append(predicates, contentepisode.ContentIDNotIn(i.ContentIDNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, contentepisode.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, contentepisode.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, contentepisode.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, contentepisode.TypeNotIn(i.TypeNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, contentepisode.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, contentepisode.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, contentepisode.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, contentepisode.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, contentepisode.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, contentepisode.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, contentepisode.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, contentepisode.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, contentepisode.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, contentepisode.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, contentepisode.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, contentepisode.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, contentepisode.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Subtitle != nil {
		predicates = append(predicates, contentepisode.SubtitleEQ(*i.Subtitle))
	}
	if i.SubtitleNEQ != nil {
		predicates = append(predicates, contentepisode.SubtitleNEQ(*i.SubtitleNEQ))
	}
	if len(i.SubtitleIn) > 0 {
		predicates = append(predicates, contentepisode.SubtitleIn(i.SubtitleIn...))
	}
	if len(i.SubtitleNotIn) > 0 {
		predicates = append(predicates, contentepisode.SubtitleNotIn(i.SubtitleNotIn...))
	}
	if i.SubtitleGT != nil {
		predicates = append(predicates, contentepisode.SubtitleGT(*i.SubtitleGT))
	}
	if i.SubtitleGTE != nil {
		predicates = append(predicates, contentepisode.SubtitleGTE(*i.SubtitleGTE))
	}
	if i.SubtitleLT != nil {
		predicates = append(predicates, contentepisode.SubtitleLT(*i.SubtitleLT))
	}
	if i.SubtitleLTE != nil {
		predicates = append(predicates, contentepisode.SubtitleLTE(*i.SubtitleLTE))
	}
	if i.SubtitleContains != nil {
		predicates = append(predicates, contentepisode.SubtitleContains(*i.SubtitleContains))
	}
	if i.SubtitleHasPrefix != nil {
		predicates = append(predicates, contentepisode.SubtitleHasPrefix(*i.SubtitleHasPrefix))
	}
	if i.SubtitleHasSuffix != nil {
		predicates = append(predicates, contentepisode.SubtitleHasSuffix(*i.SubtitleHasSuffix))
	}
	if i.SubtitleEqualFold != nil {
		predicates = append(predicates, contentepisode.SubtitleEqualFold(*i.SubtitleEqualFold))
	}
	if i.SubtitleContainsFold != nil {
		predicates = append(predicates, contentepisode.SubtitleContainsFold(*i.SubtitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, contentepisode.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, contentepisode.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, contentepisode.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, contentepisode.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, contentepisode.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, contentepisode.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, contentepisode.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, contentepisode.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, contentepisode.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, contentepisode.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, contentepisode.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, contentepisode.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, contentepisode.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Duration != nil {
		predicates = append(predicates, contentepisode.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, contentepisode.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, contentepisode.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, contentepisode.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, contentepisode.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, contentepisode.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, contentepisode.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, contentepisode.DurationLTE(*i.DurationLTE))
	}
	if i.StreamURL != nil {
		predicates = append(predicates, contentepisode.StreamURLEQ(*i.StreamURL))
	}
	if i.StreamURLNEQ != nil {
		predicates = append(predicates, contentepisode.StreamURLNEQ(*i.StreamURLNEQ))
	}
	if len(i.StreamURLIn) > 0 {
		predicates = append(predicates, contentepisode.StreamURLIn(i.StreamURLIn...))
	}
	if len(i.StreamURLNotIn) > 0 {
		predicates = append(predicates, contentepisode.StreamURLNotIn(i.StreamURLNotIn...))
	}
	if i.StreamURLGT != nil {
		predicates = append(predicates, contentepisode.StreamURLGT(*i.StreamURLGT))
	}
	if i.StreamURLGTE != nil {
		predicates = append(predicates, contentepisode.StreamURLGTE(*i.StreamURLGTE))
	}
	if i.StreamURLLT != nil {
		predicates = append(predicates, contentepisode.StreamURLLT(*i.StreamURLLT))
	}
	if i.StreamURLLTE != nil {
		predicates = append(predicates, contentepisode.StreamURLLTE(*i.StreamURLLTE))
	}
	if i.StreamURLContains != nil {
		predicates = append(predicates, contentepisode.StreamURLContains(*i.StreamURLContains))
	}
	if i.StreamURLHasPrefix != nil {
		predicates = append(predicates, contentepisode.StreamURLHasPrefix(*i.StreamURLHasPrefix))
	}
	if i.StreamURLHasSuffix != nil {
		predicates = append(predicates, contentepisode.StreamURLHasSuffix(*i.StreamURLHasSuffix))
	}
	if i.StreamURLEqualFold != nil {
		predicates = append(predicates, contentepisode.StreamURLEqualFold(*i.StreamURLEqualFold))
	}
	if i.StreamURLContainsFold != nil {
		predicates = append(predicates, contentepisode.StreamURLContainsFold(*i.StreamURLContainsFold))
	}
	if i.DownloadURL != nil {
		predicates = append(predicates, contentepisode.DownloadURLEQ(*i.DownloadURL))
	}
	if i.DownloadURLNEQ != nil {
		predicates = append(predicates, contentepisode.DownloadURLNEQ(*i.DownloadURLNEQ))
	}
	if len(i.DownloadURLIn) > 0 {
		predicates = append(predicates, contentepisode.DownloadURLIn(i.DownloadURLIn...))
	}
	if len(i.DownloadURLNotIn) > 0 {
		predicates = append(predicates, contentepisode.DownloadURLNotIn(i.DownloadURLNotIn...))
	}
	if i.DownloadURLGT != nil {
		predicates = append(predicates, contentepisode.DownloadURLGT(*i.DownloadURLGT))
	}
	if i.DownloadURLGTE != nil {
		predicates = append(predicates, contentepisode.DownloadURLGTE(*i.DownloadURLGTE))
	}
	if i.DownloadURLLT != nil {
		predicates = append(predicates, contentepisode.DownloadURLLT(*i.DownloadURLLT))
	}
	if i.DownloadURLLTE != nil {
		predicates = append(predicates, contentepisode.DownloadURLLTE(*i.DownloadURLLTE))
	}
	if i.DownloadURLContains != nil {
		predicates = append(predicates, contentepisode.DownloadURLContains(*i.DownloadURLContains))
	}
	if i.DownloadURLHasPrefix != nil {
		predicates = append(predicates, contentepisode.DownloadURLHasPrefix(*i.DownloadURLHasPrefix))
	}
	if i.DownloadURLHasSuffix != nil {
		predicates = append(predicates, contentepisode.DownloadURLHasSuffix(*i.DownloadURLHasSuffix))
	}
	if i.DownloadURLEqualFold != nil {
		predicates = append(predicates, contentepisode.DownloadURLEqualFold(*i.DownloadURLEqualFold))
	}
	if i.DownloadURLContainsFold != nil {
		predicates = append(predicates, contentepisode.DownloadURLContainsFold(*i.DownloadURLContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, contentepisode.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, contentepisode.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, contentepisode.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, contentepisode.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, contentepisode.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, contentepisode.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, contentepisode.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, contentepisode.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, contentepisode.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, contentepisode.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, contentepisode.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, contentepisode.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, contentepisode.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.SourceURL != nil {
		predicates = append(predicates, contentepisode.SourceURLEQ(*i.SourceURL))
	}
	if i.SourceURLNEQ != nil {
		predicates = append(predicates, contentepisode.SourceURLNEQ(*i.SourceURLNEQ))
	}
	if len(i.SourceURLIn) > 0 {
		predicates = append(predicates, contentepisode.SourceURLIn(i.SourceURLIn...))
	}
	if len(i.SourceURLNotIn) > 0 {
		predicates = append(predicates, contentepisode.SourceURLNotIn(i.SourceURLNotIn...))
	}
	if i.SourceURLGT != nil {
		predicates = append(predicates, contentepisode.SourceURLGT(*i.SourceURLGT))
	}
	if i.SourceURLGTE != nil {
		predicates = append(predicates, contentepisode.SourceURLGTE(*i.SourceURLGTE))
	}
	if i.SourceURLLT != nil {
		predicates = append(predicates, contentepisode.SourceURLLT(*i.SourceURLLT))
	}
	if i.SourceURLLTE != nil {
		predicates = append(predicates, contentepisode.SourceURLLTE(*i.SourceURLLTE))
	}
	if i.SourceURLContains != nil {
		predicates = append(predicates, contentepisode.SourceURLContains(*i.SourceURLContains))
	}
	if i.SourceURLHasPrefix != nil {
		predicates = append(predicates, contentepisode.SourceURLHasPrefix(*i.SourceURLHasPrefix))
	}
	if i.SourceURLHasSuffix != nil {
		predicates = append(predicates, contentepisode.SourceURLHasSuffix(*i.SourceURLHasSuffix))
	}
	if i.SourceURLEqualFold != nil {
		predicates = append(predicates, contentepisode.SourceURLEqualFold(*i.SourceURLEqualFold))
	}
	if i.SourceURLContainsFold != nil {
		predicates = append(predicates, contentepisode.SourceURLContainsFold(*i.SourceURLContainsFold))
	}
	if i.Licence != nil {
		predicates = append(predicates, contentepisode.LicenceEQ(*i.Licence))
	}
	if i.LicenceNEQ != nil {
		predicates = append(predicates, contentepisode.LicenceNEQ(*i.LicenceNEQ))
	}
	if len(i.LicenceIn) > 0 {
		predicates = append(predicates, contentepisode.LicenceIn(i.LicenceIn...))
	}
	if len(i.LicenceNotIn) > 0 {
		predicates = append(predicates, contentepisode.LicenceNotIn(i.LicenceNotIn...))
	}
	if i.LicenceGT != nil {
		predicates = append(predicates, contentepisode.LicenceGT(*i.LicenceGT))
	}
	if i.LicenceGTE != nil {
		predicates = append(predicates, contentepisode.LicenceGTE(*i.LicenceGTE))
	}
	if i.LicenceLT != nil {
		predicates = append(predicates, contentepisode.LicenceLT(*i.LicenceLT))
	}
	if i.LicenceLTE != nil {
		predicates = append(predicates, contentepisode.LicenceLTE(*i.LicenceLTE))
	}
	if i.LicenceContains != nil {
		predicates = append(predicates, contentepisode.LicenceContains(*i.LicenceContains))
	}
	if i.LicenceHasPrefix != nil {
		predicates = append(predicates, contentepisode.LicenceHasPrefix(*i.LicenceHasPrefix))
	}
	if i.LicenceHasSuffix != nil {
		predicates = append(predicates, contentepisode.LicenceHasSuffix(*i.LicenceHasSuffix))
	}
	if i.LicenceEqualFold != nil {
		predicates = append(predicates, contentepisode.LicenceEqualFold(*i.LicenceEqualFold))
	}
	if i.LicenceContainsFold != nil {
		predicates = append(predicates, contentepisode.LicenceContainsFold(*i.LicenceContainsFold))
	}
	if i.LicenceURL != nil {
		predicates = append(predicates, contentepisode.LicenceURLEQ(*i.LicenceURL))
	}
	if i.LicenceURLNEQ != nil {
		predicates = append(predicates, contentepisode.LicenceURLNEQ(*i.LicenceURLNEQ))
	}
	if len(i.LicenceURLIn) > 0 {
		predicates = append(predicates, contentepisode.LicenceURLIn(i.LicenceURLIn...))
	}
	if len(i.LicenceURLNotIn) > 0 {
		predicates = append(predicates, contentepisode.LicenceURLNotIn(i.LicenceURLNotIn...))
	}
	if i.LicenceURLGT != nil {
		predicates = append(predicates, contentepisode.LicenceURLGT(*i.LicenceURLGT))
	}
	if i.LicenceURLGTE != nil {
		predicates = append(predicates, contentepisode.LicenceURLGTE(*i.LicenceURLGTE))
	}
	if i.LicenceURLLT != nil {
		predicates = append(predicates, contentepisode.LicenceURLLT(*i.LicenceURLLT))
	}
	if i.LicenceURLLTE != nil {
		predicates = append(predicates, contentepisode.LicenceURLLTE(*i.LicenceURLLTE))
	}
	if i.LicenceURLContains != nil {
		predicates = append(predicates, contentepisode.LicenceURLContains(*i.LicenceURLContains))
	}
	if i.LicenceURLHasPrefix != nil {
		predicates = append(predicates, contentepisode.LicenceURLHasPrefix(*i.LicenceURLHasPrefix))
	}
	if i.LicenceURLHasSuffix != nil {
		predicates = append(predicates, contentepisode.LicenceURLHasSuffix(*i.LicenceURLHasSuffix))
	}
	if i.LicenceURLEqualFold != nil {
		predicates = append(predicates, contentepisode.LicenceURLEqualFold(*i.LicenceURLEqualFold))
	}
	if i.LicenceURLContainsFold != nil {
		predicates = append(predicates, contentepisode.LicenceURLContainsFold(*i.LicenceURLContainsFold))
	}
	if i.IsHidden != nil {
		predicates = append(predicates, contentepisode.IsHiddenEQ(*i.IsHidden))
	}
	if i.IsHiddenNEQ != nil {
		predicates = append(predicates, contentepisode.IsHiddenNEQ(*i.IsHiddenNEQ))
	}
	if i.Order != nil {
		predicates = append(predicates, contentepisode.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, contentepisode.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, contentepisode.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, contentepisode.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, contentepisode.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, contentepisode.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, contentepisode.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, contentepisode.OrderLTE(*i.OrderLTE))
	}

	if i.HasContent != nil {
		p := contentepisode.HasContent()
		if !*i.HasContent {
			p = contentepisode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContentWith) > 0 {
		with := make([]predicate.Content, 0, len(i.HasContentWith))
		for _, w := range i.HasContentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contentepisode.HasContentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContentEpisodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contentepisode.And(predicates...), nil
	}
}

// ContentProgressWhereInput represents a where input for filtering ContentProgress queries.
type ContentProgressWhereInput struct {
	Predicates []predicate.ContentProgress  `json:"-"`
	Not        *ContentProgressWhereInput   `json:"not,omitempty"`
	Or         []*ContentProgressWhereInput `json:"or,omitempty"`
	And        []*ContentProgressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.ContentProgressID  `json:"id,omitempty"`
	IDNEQ   *gqlid.ContentProgressID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.ContentProgressID `json:"idIn,omitempty"`
	IDNotIn []gqlid.ContentProgressID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.ContentProgressID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.ContentProgressID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.ContentProgressID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.ContentProgressID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *gqlid.UserID  `json:"userID,omitempty"`
	UserIDNEQ   *gqlid.UserID  `json:"userIDNEQ,omitempty"`
	UserIDIn    []gqlid.UserID `json:"userIDIn,omitempty"`
	UserIDNotIn []gqlid.UserID `json:"userIDNotIn,omitempty"`

	// "content_id" field predicates.
	ContentID      *gqlid.ContentID  `json:"contentID,omitempty"`
	ContentIDNEQ   *gqlid.ContentID  `json:"contentIDNEQ,omitempty"`
	ContentIDIn    []gqlid.ContentID `json:"contentIDIn,omitempty"`
	ContentIDNotIn []gqlid.ContentID `json:"contentIDNotIn,omitempty"`

	// "episode_id" field predicates.
	EpisodeID      *gqlid.ContentEpisodeID  `json:"episodeID,omitempty"`
	EpisodeIDNEQ   *gqlid.ContentEpisodeID  `json:"episodeIDNEQ,omitempty"`
	EpisodeIDIn    []gqlid.ContentEpisodeID `json:"episodeIDIn,omitempty"`
	EpisodeIDNotIn []gqlid.ContentEpisodeID `json:"episodeIDNotIn,omitempty"`

	// "content_type" field predicates.
	ContentType      *property.ContentType  `json:"contentType,omitempty"`
	ContentTypeNEQ   *property.ContentType  `json:"contentTypeNEQ,omitempty"`
	ContentTypeIn    []property.ContentType `json:"contentTypeIn,omitempty"`
	ContentTypeNotIn []property.ContentType `json:"contentTypeNotIn,omitempty"`

	// "progress" field predicates.
	Progress      *int64  `json:"progress,omitempty"`
	ProgressNEQ   *int64  `json:"progressNEQ,omitempty"`
	ProgressIn    []int64 `json:"progressIn,omitempty"`
	ProgressNotIn []int64 `json:"progressNotIn,omitempty"`
	ProgressGT    *int64  `json:"progressGT,omitempty"`
	ProgressGTE   *int64  `json:"progressGTE,omitempty"`
	ProgressLT    *int64  `json:"progressLT,omitempty"`
	ProgressLTE   *int64  `json:"progressLTE,omitempty"`

	// "finishedAt" field predicates.
	FinishedAt       *time.Time  `json:"finishedat,omitempty"`
	FinishedAtNEQ    *time.Time  `json:"finishedatNEQ,omitempty"`
	FinishedAtIn     []time.Time `json:"finishedatIn,omitempty"`
	FinishedAtNotIn  []time.Time `json:"finishedatNotIn,omitempty"`
	FinishedAtGT     *time.Time  `json:"finishedatGT,omitempty"`
	FinishedAtGTE    *time.Time  `json:"finishedatGTE,omitempty"`
	FinishedAtLT     *time.Time  `json:"finishedatLT,omitempty"`
	FinishedAtLTE    *time.Time  `json:"finishedatLTE,omitempty"`
	FinishedAtIsNil  bool        `json:"finishedatIsNil,omitempty"`
	FinishedAtNotNil bool        `json:"finishedatNotNil,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "content" edge predicates.
	HasContent     *bool                `json:"hasContent,omitempty"`
	HasContentWith []*ContentWhereInput `json:"hasContentWith,omitempty"`

	// "episode" edge predicates.
	HasEpisode     *bool                       `json:"hasEpisode,omitempty"`
	HasEpisodeWith []*ContentEpisodeWhereInput `json:"hasEpisodeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContentProgressWhereInput) AddPredicates(predicates ...predicate.ContentProgress) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContentProgressWhereInput filter on the ContentProgressQuery builder.
func (i *ContentProgressWhereInput) Filter(q *ContentProgressQuery) (*ContentProgressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContentProgressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContentProgressWhereInput is returned in case the ContentProgressWhereInput is empty.
var ErrEmptyContentProgressWhereInput = errors.New("ent: empty predicate ContentProgressWhereInput")

// P returns a predicate for filtering contentprogresses.
// An error is returned if the input is empty or invalid.
func (i *ContentProgressWhereInput) P() (predicate.ContentProgress, error) {
	var predicates []predicate.ContentProgress
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contentprogress.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ContentProgress, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contentprogress.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ContentProgress, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contentprogress.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contentprogress.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contentprogress.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contentprogress.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contentprogress.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contentprogress.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contentprogress.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contentprogress.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contentprogress.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, contentprogress.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, contentprogress.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, contentprogress.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, contentprogress.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.ContentID != nil {
		predicates = append(predicates, contentprogress.ContentIDEQ(*i.ContentID))
	}
	if i.ContentIDNEQ != nil {
		predicates = append(predicates, contentprogress.ContentIDNEQ(*i.ContentIDNEQ))
	}
	if len(i.ContentIDIn) > 0 {
		predicates = append(predicates, contentprogress.ContentIDIn(i.ContentIDIn...))
	}
	if len(i.ContentIDNotIn) > 0 {
		predicates = append(predicates, contentprogress.ContentIDNotIn(i.ContentIDNotIn...))
	}
	if i.EpisodeID != nil {
		predicates = append(predicates, contentprogress.EpisodeIDEQ(*i.EpisodeID))
	}
	if i.EpisodeIDNEQ != nil {
		predicates = append(predicates, contentprogress.EpisodeIDNEQ(*i.EpisodeIDNEQ))
	}
	if len(i.EpisodeIDIn) > 0 {
		predicates = append(predicates, contentprogress.EpisodeIDIn(i.EpisodeIDIn...))
	}
	if len(i.EpisodeIDNotIn) > 0 {
		predicates = append(predicates, contentprogress.EpisodeIDNotIn(i.EpisodeIDNotIn...))
	}
	if i.ContentType != nil {
		predicates = append(predicates, contentprogress.ContentTypeEQ(*i.ContentType))
	}
	if i.ContentTypeNEQ != nil {
		predicates = append(predicates, contentprogress.ContentTypeNEQ(*i.ContentTypeNEQ))
	}
	if len(i.ContentTypeIn) > 0 {
		predicates = append(predicates, contentprogress.ContentTypeIn(i.ContentTypeIn...))
	}
	if len(i.ContentTypeNotIn) > 0 {
		predicates = append(predicates, contentprogress.ContentTypeNotIn(i.ContentTypeNotIn...))
	}
	if i.Progress != nil {
		predicates = append(predicates, contentprogress.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, contentprogress.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, contentprogress.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, contentprogress.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressGT != nil {
		predicates = append(predicates, contentprogress.ProgressGT(*i.ProgressGT))
	}
	if i.ProgressGTE != nil {
		predicates = append(predicates, contentprogress.ProgressGTE(*i.ProgressGTE))
	}
	if i.ProgressLT != nil {
		predicates = append(predicates, contentprogress.ProgressLT(*i.ProgressLT))
	}
	if i.ProgressLTE != nil {
		predicates = append(predicates, contentprogress.ProgressLTE(*i.ProgressLTE))
	}
	if i.FinishedAt != nil {
		predicates = append(predicates, contentprogress.FinishedAtEQ(*i.FinishedAt))
	}
	if i.FinishedAtNEQ != nil {
		predicates = append(predicates, contentprogress.FinishedAtNEQ(*i.FinishedAtNEQ))
	}
	if len(i.FinishedAtIn) > 0 {
		predicates = append(predicates, contentprogress.FinishedAtIn(i.FinishedAtIn...))
	}
	if len(i.FinishedAtNotIn) > 0 {
		predicates = append(predicates, contentprogress.FinishedAtNotIn(i.FinishedAtNotIn...))
	}
	if i.FinishedAtGT != nil {
		predicates = append(predicates, contentprogress.FinishedAtGT(*i.FinishedAtGT))
	}
	if i.FinishedAtGTE != nil {
		predicates = append(predicates, contentprogress.FinishedAtGTE(*i.FinishedAtGTE))
	}
	if i.FinishedAtLT != nil {
		predicates = append(predicates, contentprogress.FinishedAtLT(*i.FinishedAtLT))
	}
	if i.FinishedAtLTE != nil {
		predicates = append(predicates, contentprogress.FinishedAtLTE(*i.FinishedAtLTE))
	}
	if i.FinishedAtIsNil {
		predicates = append(predicates, contentprogress.FinishedAtIsNil())
	}
	if i.FinishedAtNotNil {
		predicates = append(predicates, contentprogress.FinishedAtNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contentprogress.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contentprogress.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contentprogress.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contentprogress.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contentprogress.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contentprogress.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contentprogress.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contentprogress.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contentprogress.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contentprogress.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contentprogress.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contentprogress.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contentprogress.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contentprogress.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contentprogress.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contentprogress.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasUser != nil {
		p := contentprogress.HasUser()
		if !*i.HasUser {
			p = contentprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contentprogress.HasUserWith(with...))
	}
	if i.HasContent != nil {
		p := contentprogress.HasContent()
		if !*i.HasContent {
			p = contentprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContentWith) > 0 {
		with := make([]predicate.Content, 0, len(i.HasContentWith))
		for _, w := range i.HasContentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contentprogress.HasContentWith(with...))
	}
	if i.HasEpisode != nil {
		p := contentprogress.HasEpisode()
		if !*i.HasEpisode {
			p = contentprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpisodeWith) > 0 {
		with := make([]predicate.ContentEpisode, 0, len(i.HasEpisodeWith))
		for _, w := range i.HasEpisodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpisodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contentprogress.HasEpisodeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContentProgressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contentprogress.And(predicates...), nil
	}
}

// CourseWhereInput represents a where input for filtering Course queries.
type CourseWhereInput struct {
	Predicates []predicate.Course  `json:"-"`
	Not        *CourseWhereInput   `json:"not,omitempty"`
	Or         []*CourseWhereInput `json:"or,omitempty"`
	And        []*CourseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.CourseID  `json:"id,omitempty"`
	IDNEQ   *gqlid.CourseID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.CourseID `json:"idIn,omitempty"`
	IDNotIn []gqlid.CourseID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.CourseID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.CourseID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.CourseID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.CourseID  `json:"idLTE,omitempty"`

	// "iconImage" field predicates.
	IconImage             *string  `json:"iconimage,omitempty"`
	IconImageNEQ          *string  `json:"iconimageNEQ,omitempty"`
	IconImageIn           []string `json:"iconimageIn,omitempty"`
	IconImageNotIn        []string `json:"iconimageNotIn,omitempty"`
	IconImageGT           *string  `json:"iconimageGT,omitempty"`
	IconImageGTE          *string  `json:"iconimageGTE,omitempty"`
	IconImageLT           *string  `json:"iconimageLT,omitempty"`
	IconImageLTE          *string  `json:"iconimageLTE,omitempty"`
	IconImageContains     *string  `json:"iconimageContains,omitempty"`
	IconImageHasPrefix    *string  `json:"iconimageHasPrefix,omitempty"`
	IconImageHasSuffix    *string  `json:"iconimageHasSuffix,omitempty"`
	IconImageEqualFold    *string  `json:"iconimageEqualFold,omitempty"`
	IconImageContainsFold *string  `json:"iconimageContainsFold,omitempty"`

	// "coverImage" field predicates.
	CoverImage             *string  `json:"coverimage,omitempty"`
	CoverImageNEQ          *string  `json:"coverimageNEQ,omitempty"`
	CoverImageIn           []string `json:"coverimageIn,omitempty"`
	CoverImageNotIn        []string `json:"coverimageNotIn,omitempty"`
	CoverImageGT           *string  `json:"coverimageGT,omitempty"`
	CoverImageGTE          *string  `json:"coverimageGTE,omitempty"`
	CoverImageLT           *string  `json:"coverimageLT,omitempty"`
	CoverImageLTE          *string  `json:"coverimageLTE,omitempty"`
	CoverImageContains     *string  `json:"coverimageContains,omitempty"`
	CoverImageHasPrefix    *string  `json:"coverimageHasPrefix,omitempty"`
	CoverImageHasSuffix    *string  `json:"coverimageHasSuffix,omitempty"`
	CoverImageEqualFold    *string  `json:"coverimageEqualFold,omitempty"`
	CoverImageContainsFold *string  `json:"coverimageContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "units" edge predicates.
	HasUnits     *bool             `json:"hasUnits,omitempty"`
	HasUnitsWith []*UnitWhereInput `json:"hasUnitsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CourseWhereInput) AddPredicates(predicates ...predicate.Course) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CourseWhereInput filter on the CourseQuery builder.
func (i *CourseWhereInput) Filter(q *CourseQuery) (*CourseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCourseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCourseWhereInput is returned in case the CourseWhereInput is empty.
var ErrEmptyCourseWhereInput = errors.New("ent: empty predicate CourseWhereInput")

// P returns a predicate for filtering courses.
// An error is returned if the input is empty or invalid.
func (i *CourseWhereInput) P() (predicate.Course, error) {
	var predicates []predicate.Course
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, course.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Course, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, course.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Course, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, course.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, course.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, course.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, course.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, course.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, course.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, course.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, course.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, course.IDLTE(*i.IDLTE))
	}
	if i.IconImage != nil {
		predicates = append(predicates, course.IconImageEQ(*i.IconImage))
	}
	if i.IconImageNEQ != nil {
		predicates = append(predicates, course.IconImageNEQ(*i.IconImageNEQ))
	}
	if len(i.IconImageIn) > 0 {
		predicates = append(predicates, course.IconImageIn(i.IconImageIn...))
	}
	if len(i.IconImageNotIn) > 0 {
		predicates = append(predicates, course.IconImageNotIn(i.IconImageNotIn...))
	}
	if i.IconImageGT != nil {
		predicates = append(predicates, course.IconImageGT(*i.IconImageGT))
	}
	if i.IconImageGTE != nil {
		predicates = append(predicates, course.IconImageGTE(*i.IconImageGTE))
	}
	if i.IconImageLT != nil {
		predicates = append(predicates, course.IconImageLT(*i.IconImageLT))
	}
	if i.IconImageLTE != nil {
		predicates = append(predicates, course.IconImageLTE(*i.IconImageLTE))
	}
	if i.IconImageContains != nil {
		predicates = append(predicates, course.IconImageContains(*i.IconImageContains))
	}
	if i.IconImageHasPrefix != nil {
		predicates = append(predicates, course.IconImageHasPrefix(*i.IconImageHasPrefix))
	}
	if i.IconImageHasSuffix != nil {
		predicates = append(predicates, course.IconImageHasSuffix(*i.IconImageHasSuffix))
	}
	if i.IconImageEqualFold != nil {
		predicates = append(predicates, course.IconImageEqualFold(*i.IconImageEqualFold))
	}
	if i.IconImageContainsFold != nil {
		predicates = append(predicates, course.IconImageContainsFold(*i.IconImageContainsFold))
	}
	if i.CoverImage != nil {
		predicates = append(predicates, course.CoverImageEQ(*i.CoverImage))
	}
	if i.CoverImageNEQ != nil {
		predicates = append(predicates, course.CoverImageNEQ(*i.CoverImageNEQ))
	}
	if len(i.CoverImageIn) > 0 {
		predicates = append(predicates, course.CoverImageIn(i.CoverImageIn...))
	}
	if len(i.CoverImageNotIn) > 0 {
		predicates = append(predicates, course.CoverImageNotIn(i.CoverImageNotIn...))
	}
	if i.CoverImageGT != nil {
		predicates = append(predicates, course.CoverImageGT(*i.CoverImageGT))
	}
	if i.CoverImageGTE != nil {
		predicates = append(predicates, course.CoverImageGTE(*i.CoverImageGTE))
	}
	if i.CoverImageLT != nil {
		predicates = append(predicates, course.CoverImageLT(*i.CoverImageLT))
	}
	if i.CoverImageLTE != nil {
		predicates = append(predicates, course.CoverImageLTE(*i.CoverImageLTE))
	}
	if i.CoverImageContains != nil {
		predicates = append(predicates, course.CoverImageContains(*i.CoverImageContains))
	}
	if i.CoverImageHasPrefix != nil {
		predicates = append(predicates, course.CoverImageHasPrefix(*i.CoverImageHasPrefix))
	}
	if i.CoverImageHasSuffix != nil {
		predicates = append(predicates, course.CoverImageHasSuffix(*i.CoverImageHasSuffix))
	}
	if i.CoverImageEqualFold != nil {
		predicates = append(predicates, course.CoverImageEqualFold(*i.CoverImageEqualFold))
	}
	if i.CoverImageContainsFold != nil {
		predicates = append(predicates, course.CoverImageContainsFold(*i.CoverImageContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, course.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, course.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, course.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, course.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, course.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, course.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, course.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, course.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, course.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, course.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, course.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, course.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, course.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, course.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, course.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, course.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, course.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, course.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, course.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, course.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, course.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, course.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, course.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, course.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, course.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, course.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, course.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, course.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, course.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, course.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, course.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, course.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, course.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, course.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, course.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, course.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, course.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, course.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, course.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, course.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, course.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Order != nil {
		predicates = append(predicates, course.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, course.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, course.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, course.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, course.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, course.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, course.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, course.OrderLTE(*i.OrderLTE))
	}

	if i.HasUnits != nil {
		p := course.HasUnits()
		if !*i.HasUnits {
			p = course.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUnitsWith) > 0 {
		with := make([]predicate.Unit, 0, len(i.HasUnitsWith))
		for _, w := range i.HasUnitsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUnitsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, course.HasUnitsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCourseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return course.And(predicates...), nil
	}
}

// JournalRecordWhereInput represents a where input for filtering JournalRecord queries.
type JournalRecordWhereInput struct {
	Predicates []predicate.JournalRecord  `json:"-"`
	Not        *JournalRecordWhereInput   `json:"not,omitempty"`
	Or         []*JournalRecordWhereInput `json:"or,omitempty"`
	And        []*JournalRecordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.JournalRecordID  `json:"id,omitempty"`
	IDNEQ   *gqlid.JournalRecordID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.JournalRecordID `json:"idIn,omitempty"`
	IDNotIn []gqlid.JournalRecordID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.JournalRecordID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.JournalRecordID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.JournalRecordID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.JournalRecordID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *gqlid.UserID  `json:"userID,omitempty"`
	UserIDNEQ   *gqlid.UserID  `json:"userIDNEQ,omitempty"`
	UserIDIn    []gqlid.UserID `json:"userIDIn,omitempty"`
	UserIDNotIn []gqlid.UserID `json:"userIDNotIn,omitempty"`

	// "lesson_id" field predicates.
	LessonID       *gqlid.LessonID  `json:"lessonID,omitempty"`
	LessonIDNEQ    *gqlid.LessonID  `json:"lessonIDNEQ,omitempty"`
	LessonIDIn     []gqlid.LessonID `json:"lessonIDIn,omitempty"`
	LessonIDNotIn  []gqlid.LessonID `json:"lessonIDNotIn,omitempty"`
	LessonIDIsNil  bool             `json:"lessonIDIsNil,omitempty"`
	LessonIDNotNil bool             `json:"lessonIDNotNil,omitempty"`

	// "dateTime" field predicates.
	DateTime      *time.Time  `json:"datetime,omitempty"`
	DateTimeNEQ   *time.Time  `json:"datetimeNEQ,omitempty"`
	DateTimeIn    []time.Time `json:"datetimeIn,omitempty"`
	DateTimeNotIn []time.Time `json:"datetimeNotIn,omitempty"`
	DateTimeGT    *time.Time  `json:"datetimeGT,omitempty"`
	DateTimeGTE   *time.Time  `json:"datetimeGTE,omitempty"`
	DateTimeLT    *time.Time  `json:"datetimeLT,omitempty"`
	DateTimeLTE   *time.Time  `json:"datetimeLTE,omitempty"`

	// "duration" field predicates.
	Duration      *int  `json:"duration,omitempty"`
	DurationNEQ   *int  `json:"durationNEQ,omitempty"`
	DurationIn    []int `json:"durationIn,omitempty"`
	DurationNotIn []int `json:"durationNotIn,omitempty"`
	DurationGT    *int  `json:"durationGT,omitempty"`
	DurationGTE   *int  `json:"durationGTE,omitempty"`
	DurationLT    *int  `json:"durationLT,omitempty"`
	DurationLTE   *int  `json:"durationLTE,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "lesson" edge predicates.
	HasLesson     *bool               `json:"hasLesson,omitempty"`
	HasLessonWith []*LessonWhereInput `json:"hasLessonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JournalRecordWhereInput) AddPredicates(predicates ...predicate.JournalRecord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JournalRecordWhereInput filter on the JournalRecordQuery builder.
func (i *JournalRecordWhereInput) Filter(q *JournalRecordQuery) (*JournalRecordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJournalRecordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJournalRecordWhereInput is returned in case the JournalRecordWhereInput is empty.
var ErrEmptyJournalRecordWhereInput = errors.New("ent: empty predicate JournalRecordWhereInput")

// P returns a predicate for filtering journalrecords.
// An error is returned if the input is empty or invalid.
func (i *JournalRecordWhereInput) P() (predicate.JournalRecord, error) {
	var predicates []predicate.JournalRecord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, journalrecord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JournalRecord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, journalrecord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JournalRecord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, journalrecord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, journalrecord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, journalrecord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, journalrecord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, journalrecord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, journalrecord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, journalrecord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, journalrecord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, journalrecord.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, journalrecord.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, journalrecord.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, journalrecord.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, journalrecord.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.LessonID != nil {
		predicates = append(predicates, journalrecord.LessonIDEQ(*i.LessonID))
	}
	if i.LessonIDNEQ != nil {
		predicates = append(predicates, journalrecord.LessonIDNEQ(*i.LessonIDNEQ))
	}
	if len(i.LessonIDIn) > 0 {
		predicates = append(predicates, journalrecord.LessonIDIn(i.LessonIDIn...))
	}
	if len(i.LessonIDNotIn) > 0 {
		predicates = append(predicates, journalrecord.LessonIDNotIn(i.LessonIDNotIn...))
	}
	if i.LessonIDIsNil {
		predicates = append(predicates, journalrecord.LessonIDIsNil())
	}
	if i.LessonIDNotNil {
		predicates = append(predicates, journalrecord.LessonIDNotNil())
	}
	if i.DateTime != nil {
		predicates = append(predicates, journalrecord.DateTimeEQ(*i.DateTime))
	}
	if i.DateTimeNEQ != nil {
		predicates = append(predicates, journalrecord.DateTimeNEQ(*i.DateTimeNEQ))
	}
	if len(i.DateTimeIn) > 0 {
		predicates = append(predicates, journalrecord.DateTimeIn(i.DateTimeIn...))
	}
	if len(i.DateTimeNotIn) > 0 {
		predicates = append(predicates, journalrecord.DateTimeNotIn(i.DateTimeNotIn...))
	}
	if i.DateTimeGT != nil {
		predicates = append(predicates, journalrecord.DateTimeGT(*i.DateTimeGT))
	}
	if i.DateTimeGTE != nil {
		predicates = append(predicates, journalrecord.DateTimeGTE(*i.DateTimeGTE))
	}
	if i.DateTimeLT != nil {
		predicates = append(predicates, journalrecord.DateTimeLT(*i.DateTimeLT))
	}
	if i.DateTimeLTE != nil {
		predicates = append(predicates, journalrecord.DateTimeLTE(*i.DateTimeLTE))
	}
	if i.Duration != nil {
		predicates = append(predicates, journalrecord.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, journalrecord.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, journalrecord.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, journalrecord.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, journalrecord.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, journalrecord.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, journalrecord.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, journalrecord.DurationLTE(*i.DurationLTE))
	}
	if i.Note != nil {
		predicates = append(predicates, journalrecord.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, journalrecord.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, journalrecord.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, journalrecord.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, journalrecord.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, journalrecord.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, journalrecord.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, journalrecord.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, journalrecord.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, journalrecord.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, journalrecord.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, journalrecord.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, journalrecord.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, journalrecord.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, journalrecord.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, journalrecord.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, journalrecord.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, journalrecord.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, journalrecord.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, journalrecord.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, journalrecord.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, journalrecord.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, journalrecord.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, journalrecord.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, journalrecord.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, journalrecord.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, journalrecord.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, journalrecord.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, journalrecord.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasUser != nil {
		p := journalrecord.HasUser()
		if !*i.HasUser {
			p = journalrecord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, journalrecord.HasUserWith(with...))
	}
	if i.HasLesson != nil {
		p := journalrecord.HasLesson()
		if !*i.HasLesson {
			p = journalrecord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLessonWith) > 0 {
		with := make([]predicate.Lesson, 0, len(i.HasLessonWith))
		for _, w := range i.HasLessonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLessonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, journalrecord.HasLessonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJournalRecordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return journalrecord.And(predicates...), nil
	}
}

// LessonWhereInput represents a where input for filtering Lesson queries.
type LessonWhereInput struct {
	Predicates []predicate.Lesson  `json:"-"`
	Not        *LessonWhereInput   `json:"not,omitempty"`
	Or         []*LessonWhereInput `json:"or,omitempty"`
	And        []*LessonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.LessonID  `json:"id,omitempty"`
	IDNEQ   *gqlid.LessonID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.LessonID `json:"idIn,omitempty"`
	IDNotIn []gqlid.LessonID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.LessonID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.LessonID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.LessonID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.LessonID  `json:"idLTE,omitempty"`

	// "unit_id" field predicates.
	UnitID      *gqlid.UnitID  `json:"unitID,omitempty"`
	UnitIDNEQ   *gqlid.UnitID  `json:"unitIDNEQ,omitempty"`
	UnitIDIn    []gqlid.UnitID `json:"unitIDIn,omitempty"`
	UnitIDNotIn []gqlid.UnitID `json:"unitIDNotIn,omitempty"`

	// "type" field predicates.
	Type      *property.LessonType  `json:"type,omitempty"`
	TypeNEQ   *property.LessonType  `json:"typeNEQ,omitempty"`
	TypeIn    []property.LessonType `json:"typeIn,omitempty"`
	TypeNotIn []property.LessonType `json:"typeNotIn,omitempty"`

	// "iconImage" field predicates.
	IconImage             *string  `json:"iconimage,omitempty"`
	IconImageNEQ          *string  `json:"iconimageNEQ,omitempty"`
	IconImageIn           []string `json:"iconimageIn,omitempty"`
	IconImageNotIn        []string `json:"iconimageNotIn,omitempty"`
	IconImageGT           *string  `json:"iconimageGT,omitempty"`
	IconImageGTE          *string  `json:"iconimageGTE,omitempty"`
	IconImageLT           *string  `json:"iconimageLT,omitempty"`
	IconImageLTE          *string  `json:"iconimageLTE,omitempty"`
	IconImageContains     *string  `json:"iconimageContains,omitempty"`
	IconImageHasPrefix    *string  `json:"iconimageHasPrefix,omitempty"`
	IconImageHasSuffix    *string  `json:"iconimageHasSuffix,omitempty"`
	IconImageEqualFold    *string  `json:"iconimageEqualFold,omitempty"`
	IconImageContainsFold *string  `json:"iconimageContainsFold,omitempty"`

	// "coverImage" field predicates.
	CoverImage             *string  `json:"coverimage,omitempty"`
	CoverImageNEQ          *string  `json:"coverimageNEQ,omitempty"`
	CoverImageIn           []string `json:"coverimageIn,omitempty"`
	CoverImageNotIn        []string `json:"coverimageNotIn,omitempty"`
	CoverImageGT           *string  `json:"coverimageGT,omitempty"`
	CoverImageGTE          *string  `json:"coverimageGTE,omitempty"`
	CoverImageLT           *string  `json:"coverimageLT,omitempty"`
	CoverImageLTE          *string  `json:"coverimageLTE,omitempty"`
	CoverImageContains     *string  `json:"coverimageContains,omitempty"`
	CoverImageHasPrefix    *string  `json:"coverimageHasPrefix,omitempty"`
	CoverImageHasSuffix    *string  `json:"coverimageHasSuffix,omitempty"`
	CoverImageEqualFold    *string  `json:"coverimageEqualFold,omitempty"`
	CoverImageContainsFold *string  `json:"coverimageContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "unit" edge predicates.
	HasUnit     *bool             `json:"hasUnit,omitempty"`
	HasUnitWith []*UnitWhereInput `json:"hasUnitWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LessonWhereInput) AddPredicates(predicates ...predicate.Lesson) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LessonWhereInput filter on the LessonQuery builder.
func (i *LessonWhereInput) Filter(q *LessonQuery) (*LessonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLessonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLessonWhereInput is returned in case the LessonWhereInput is empty.
var ErrEmptyLessonWhereInput = errors.New("ent: empty predicate LessonWhereInput")

// P returns a predicate for filtering lessons.
// An error is returned if the input is empty or invalid.
func (i *LessonWhereInput) P() (predicate.Lesson, error) {
	var predicates []predicate.Lesson
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, lesson.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Lesson, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, lesson.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Lesson, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, lesson.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, lesson.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, lesson.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, lesson.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, lesson.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, lesson.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, lesson.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, lesson.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, lesson.IDLTE(*i.IDLTE))
	}
	if i.UnitID != nil {
		predicates = append(predicates, lesson.UnitIDEQ(*i.UnitID))
	}
	if i.UnitIDNEQ != nil {
		predicates = append(predicates, lesson.UnitIDNEQ(*i.UnitIDNEQ))
	}
	if len(i.UnitIDIn) > 0 {
		predicates = append(predicates, lesson.UnitIDIn(i.UnitIDIn...))
	}
	if len(i.UnitIDNotIn) > 0 {
		predicates = append(predicates, lesson.UnitIDNotIn(i.UnitIDNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, lesson.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, lesson.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, lesson.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, lesson.TypeNotIn(i.TypeNotIn...))
	}
	if i.IconImage != nil {
		predicates = append(predicates, lesson.IconImageEQ(*i.IconImage))
	}
	if i.IconImageNEQ != nil {
		predicates = append(predicates, lesson.IconImageNEQ(*i.IconImageNEQ))
	}
	if len(i.IconImageIn) > 0 {
		predicates = append(predicates, lesson.IconImageIn(i.IconImageIn...))
	}
	if len(i.IconImageNotIn) > 0 {
		predicates = append(predicates, lesson.IconImageNotIn(i.IconImageNotIn...))
	}
	if i.IconImageGT != nil {
		predicates = append(predicates, lesson.IconImageGT(*i.IconImageGT))
	}
	if i.IconImageGTE != nil {
		predicates = append(predicates, lesson.IconImageGTE(*i.IconImageGTE))
	}
	if i.IconImageLT != nil {
		predicates = append(predicates, lesson.IconImageLT(*i.IconImageLT))
	}
	if i.IconImageLTE != nil {
		predicates = append(predicates, lesson.IconImageLTE(*i.IconImageLTE))
	}
	if i.IconImageContains != nil {
		predicates = append(predicates, lesson.IconImageContains(*i.IconImageContains))
	}
	if i.IconImageHasPrefix != nil {
		predicates = append(predicates, lesson.IconImageHasPrefix(*i.IconImageHasPrefix))
	}
	if i.IconImageHasSuffix != nil {
		predicates = append(predicates, lesson.IconImageHasSuffix(*i.IconImageHasSuffix))
	}
	if i.IconImageEqualFold != nil {
		predicates = append(predicates, lesson.IconImageEqualFold(*i.IconImageEqualFold))
	}
	if i.IconImageContainsFold != nil {
		predicates = append(predicates, lesson.IconImageContainsFold(*i.IconImageContainsFold))
	}
	if i.CoverImage != nil {
		predicates = append(predicates, lesson.CoverImageEQ(*i.CoverImage))
	}
	if i.CoverImageNEQ != nil {
		predicates = append(predicates, lesson.CoverImageNEQ(*i.CoverImageNEQ))
	}
	if len(i.CoverImageIn) > 0 {
		predicates = append(predicates, lesson.CoverImageIn(i.CoverImageIn...))
	}
	if len(i.CoverImageNotIn) > 0 {
		predicates = append(predicates, lesson.CoverImageNotIn(i.CoverImageNotIn...))
	}
	if i.CoverImageGT != nil {
		predicates = append(predicates, lesson.CoverImageGT(*i.CoverImageGT))
	}
	if i.CoverImageGTE != nil {
		predicates = append(predicates, lesson.CoverImageGTE(*i.CoverImageGTE))
	}
	if i.CoverImageLT != nil {
		predicates = append(predicates, lesson.CoverImageLT(*i.CoverImageLT))
	}
	if i.CoverImageLTE != nil {
		predicates = append(predicates, lesson.CoverImageLTE(*i.CoverImageLTE))
	}
	if i.CoverImageContains != nil {
		predicates = append(predicates, lesson.CoverImageContains(*i.CoverImageContains))
	}
	if i.CoverImageHasPrefix != nil {
		predicates = append(predicates, lesson.CoverImageHasPrefix(*i.CoverImageHasPrefix))
	}
	if i.CoverImageHasSuffix != nil {
		predicates = append(predicates, lesson.CoverImageHasSuffix(*i.CoverImageHasSuffix))
	}
	if i.CoverImageEqualFold != nil {
		predicates = append(predicates, lesson.CoverImageEqualFold(*i.CoverImageEqualFold))
	}
	if i.CoverImageContainsFold != nil {
		predicates = append(predicates, lesson.CoverImageContainsFold(*i.CoverImageContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, lesson.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, lesson.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, lesson.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, lesson.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, lesson.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, lesson.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, lesson.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, lesson.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, lesson.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, lesson.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, lesson.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, lesson.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, lesson.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, lesson.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, lesson.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, lesson.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, lesson.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, lesson.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, lesson.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, lesson.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, lesson.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, lesson.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, lesson.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, lesson.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, lesson.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, lesson.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, lesson.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, lesson.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, lesson.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, lesson.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, lesson.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, lesson.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, lesson.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, lesson.OrderLTE(*i.OrderLTE))
	}

	if i.HasUnit != nil {
		p := lesson.HasUnit()
		if !*i.HasUnit {
			p = lesson.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUnitWith) > 0 {
		with := make([]predicate.Unit, 0, len(i.HasUnitWith))
		for _, w := range i.HasUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUnitWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, lesson.HasUnitWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLessonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return lesson.And(predicates...), nil
	}
}

// LessonAudioWhereInput represents a where input for filtering LessonAudio queries.
type LessonAudioWhereInput struct {
	Predicates []predicate.LessonAudio  `json:"-"`
	Not        *LessonAudioWhereInput   `json:"not,omitempty"`
	Or         []*LessonAudioWhereInput `json:"or,omitempty"`
	And        []*LessonAudioWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.LessonAudioID  `json:"id,omitempty"`
	IDNEQ   *gqlid.LessonAudioID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.LessonAudioID `json:"idIn,omitempty"`
	IDNotIn []gqlid.LessonAudioID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.LessonAudioID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.LessonAudioID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.LessonAudioID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.LessonAudioID  `json:"idLTE,omitempty"`

	// "lesson_id" field predicates.
	LessonID      *gqlid.LessonID  `json:"lessonID,omitempty"`
	LessonIDNEQ   *gqlid.LessonID  `json:"lessonIDNEQ,omitempty"`
	LessonIDIn    []gqlid.LessonID `json:"lessonIDIn,omitempty"`
	LessonIDNotIn []gqlid.LessonID `json:"lessonIDNotIn,omitempty"`

	// "audioURL" field predicates.
	AudioURL             *string  `json:"audiourl,omitempty"`
	AudioURLNEQ          *string  `json:"audiourlNEQ,omitempty"`
	AudioURLIn           []string `json:"audiourlIn,omitempty"`
	AudioURLNotIn        []string `json:"audiourlNotIn,omitempty"`
	AudioURLGT           *string  `json:"audiourlGT,omitempty"`
	AudioURLGTE          *string  `json:"audiourlGTE,omitempty"`
	AudioURLLT           *string  `json:"audiourlLT,omitempty"`
	AudioURLLTE          *string  `json:"audiourlLTE,omitempty"`
	AudioURLContains     *string  `json:"audiourlContains,omitempty"`
	AudioURLHasPrefix    *string  `json:"audiourlHasPrefix,omitempty"`
	AudioURLHasSuffix    *string  `json:"audiourlHasSuffix,omitempty"`
	AudioURLEqualFold    *string  `json:"audiourlEqualFold,omitempty"`
	AudioURLContainsFold *string  `json:"audiourlContainsFold,omitempty"`

	// "duration" field predicates.
	Duration      *int  `json:"duration,omitempty"`
	DurationNEQ   *int  `json:"durationNEQ,omitempty"`
	DurationIn    []int `json:"durationIn,omitempty"`
	DurationNotIn []int `json:"durationNotIn,omitempty"`
	DurationGT    *int  `json:"durationGT,omitempty"`
	DurationGTE   *int  `json:"durationGTE,omitempty"`
	DurationLT    *int  `json:"durationLT,omitempty"`
	DurationLTE   *int  `json:"durationLTE,omitempty"`

	// "lesson" edge predicates.
	HasLesson     *bool               `json:"hasLesson,omitempty"`
	HasLessonWith []*LessonWhereInput `json:"hasLessonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LessonAudioWhereInput) AddPredicates(predicates ...predicate.LessonAudio) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LessonAudioWhereInput filter on the LessonAudioQuery builder.
func (i *LessonAudioWhereInput) Filter(q *LessonAudioQuery) (*LessonAudioQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLessonAudioWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLessonAudioWhereInput is returned in case the LessonAudioWhereInput is empty.
var ErrEmptyLessonAudioWhereInput = errors.New("ent: empty predicate LessonAudioWhereInput")

// P returns a predicate for filtering lessonaudios.
// An error is returned if the input is empty or invalid.
func (i *LessonAudioWhereInput) P() (predicate.LessonAudio, error) {
	var predicates []predicate.LessonAudio
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, lessonaudio.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.LessonAudio, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, lessonaudio.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.LessonAudio, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, lessonaudio.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, lessonaudio.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, lessonaudio.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, lessonaudio.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, lessonaudio.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, lessonaudio.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, lessonaudio.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, lessonaudio.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, lessonaudio.IDLTE(*i.IDLTE))
	}
	if i.LessonID != nil {
		predicates = append(predicates, lessonaudio.LessonIDEQ(*i.LessonID))
	}
	if i.LessonIDNEQ != nil {
		predicates = append(predicates, lessonaudio.LessonIDNEQ(*i.LessonIDNEQ))
	}
	if len(i.LessonIDIn) > 0 {
		predicates = append(predicates, lessonaudio.LessonIDIn(i.LessonIDIn...))
	}
	if len(i.LessonIDNotIn) > 0 {
		predicates = append(predicates, lessonaudio.LessonIDNotIn(i.LessonIDNotIn...))
	}
	if i.AudioURL != nil {
		predicates = append(predicates, lessonaudio.AudioURLEQ(*i.AudioURL))
	}
	if i.AudioURLNEQ != nil {
		predicates = append(predicates, lessonaudio.AudioURLNEQ(*i.AudioURLNEQ))
	}
	if len(i.AudioURLIn) > 0 {
		predicates = append(predicates, lessonaudio.AudioURLIn(i.AudioURLIn...))
	}
	if len(i.AudioURLNotIn) > 0 {
		predicates = append(predicates, lessonaudio.AudioURLNotIn(i.AudioURLNotIn...))
	}
	if i.AudioURLGT != nil {
		predicates = append(predicates, lessonaudio.AudioURLGT(*i.AudioURLGT))
	}
	if i.AudioURLGTE != nil {
		predicates = append(predicates, lessonaudio.AudioURLGTE(*i.AudioURLGTE))
	}
	if i.AudioURLLT != nil {
		predicates = append(predicates, lessonaudio.AudioURLLT(*i.AudioURLLT))
	}
	if i.AudioURLLTE != nil {
		predicates = append(predicates, lessonaudio.AudioURLLTE(*i.AudioURLLTE))
	}
	if i.AudioURLContains != nil {
		predicates = append(predicates, lessonaudio.AudioURLContains(*i.AudioURLContains))
	}
	if i.AudioURLHasPrefix != nil {
		predicates = append(predicates, lessonaudio.AudioURLHasPrefix(*i.AudioURLHasPrefix))
	}
	if i.AudioURLHasSuffix != nil {
		predicates = append(predicates, lessonaudio.AudioURLHasSuffix(*i.AudioURLHasSuffix))
	}
	if i.AudioURLEqualFold != nil {
		predicates = append(predicates, lessonaudio.AudioURLEqualFold(*i.AudioURLEqualFold))
	}
	if i.AudioURLContainsFold != nil {
		predicates = append(predicates, lessonaudio.AudioURLContainsFold(*i.AudioURLContainsFold))
	}
	if i.Duration != nil {
		predicates = append(predicates, lessonaudio.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, lessonaudio.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, lessonaudio.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, lessonaudio.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, lessonaudio.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, lessonaudio.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, lessonaudio.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, lessonaudio.DurationLTE(*i.DurationLTE))
	}

	if i.HasLesson != nil {
		p := lessonaudio.HasLesson()
		if !*i.HasLesson {
			p = lessonaudio.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLessonWith) > 0 {
		with := make([]predicate.Lesson, 0, len(i.HasLessonWith))
		for _, w := range i.HasLessonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLessonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, lessonaudio.HasLessonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLessonAudioWhereInput
	case 1:
		return predicates[0], nil
	default:
		return lessonaudio.And(predicates...), nil
	}
}

// TechniqueWhereInput represents a where input for filtering Technique queries.
type TechniqueWhereInput struct {
	Predicates []predicate.Technique  `json:"-"`
	Not        *TechniqueWhereInput   `json:"not,omitempty"`
	Or         []*TechniqueWhereInput `json:"or,omitempty"`
	And        []*TechniqueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.TechniqueID  `json:"id,omitempty"`
	IDNEQ   *gqlid.TechniqueID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.TechniqueID `json:"idIn,omitempty"`
	IDNotIn []gqlid.TechniqueID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.TechniqueID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.TechniqueID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.TechniqueID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.TechniqueID  `json:"idLTE,omitempty"`

	// "unit_id" field predicates.
	UnitID      *gqlid.UnitID  `json:"unitID,omitempty"`
	UnitIDNEQ   *gqlid.UnitID  `json:"unitIDNEQ,omitempty"`
	UnitIDIn    []gqlid.UnitID `json:"unitIDIn,omitempty"`
	UnitIDNotIn []gqlid.UnitID `json:"unitIDNotIn,omitempty"`

	// "iconImage" field predicates.
	IconImage             *string  `json:"iconimage,omitempty"`
	IconImageNEQ          *string  `json:"iconimageNEQ,omitempty"`
	IconImageIn           []string `json:"iconimageIn,omitempty"`
	IconImageNotIn        []string `json:"iconimageNotIn,omitempty"`
	IconImageGT           *string  `json:"iconimageGT,omitempty"`
	IconImageGTE          *string  `json:"iconimageGTE,omitempty"`
	IconImageLT           *string  `json:"iconimageLT,omitempty"`
	IconImageLTE          *string  `json:"iconimageLTE,omitempty"`
	IconImageContains     *string  `json:"iconimageContains,omitempty"`
	IconImageHasPrefix    *string  `json:"iconimageHasPrefix,omitempty"`
	IconImageHasSuffix    *string  `json:"iconimageHasSuffix,omitempty"`
	IconImageEqualFold    *string  `json:"iconimageEqualFold,omitempty"`
	IconImageContainsFold *string  `json:"iconimageContainsFold,omitempty"`

	// "coverImage" field predicates.
	CoverImage             *string  `json:"coverimage,omitempty"`
	CoverImageNEQ          *string  `json:"coverimageNEQ,omitempty"`
	CoverImageIn           []string `json:"coverimageIn,omitempty"`
	CoverImageNotIn        []string `json:"coverimageNotIn,omitempty"`
	CoverImageGT           *string  `json:"coverimageGT,omitempty"`
	CoverImageGTE          *string  `json:"coverimageGTE,omitempty"`
	CoverImageLT           *string  `json:"coverimageLT,omitempty"`
	CoverImageLTE          *string  `json:"coverimageLTE,omitempty"`
	CoverImageContains     *string  `json:"coverimageContains,omitempty"`
	CoverImageHasPrefix    *string  `json:"coverimageHasPrefix,omitempty"`
	CoverImageHasSuffix    *string  `json:"coverimageHasSuffix,omitempty"`
	CoverImageEqualFold    *string  `json:"coverimageEqualFold,omitempty"`
	CoverImageContainsFold *string  `json:"coverimageContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "subtitle" field predicates.
	Subtitle             *string  `json:"subtitle,omitempty"`
	SubtitleNEQ          *string  `json:"subtitleNEQ,omitempty"`
	SubtitleIn           []string `json:"subtitleIn,omitempty"`
	SubtitleNotIn        []string `json:"subtitleNotIn,omitempty"`
	SubtitleGT           *string  `json:"subtitleGT,omitempty"`
	SubtitleGTE          *string  `json:"subtitleGTE,omitempty"`
	SubtitleLT           *string  `json:"subtitleLT,omitempty"`
	SubtitleLTE          *string  `json:"subtitleLTE,omitempty"`
	SubtitleContains     *string  `json:"subtitleContains,omitempty"`
	SubtitleHasPrefix    *string  `json:"subtitleHasPrefix,omitempty"`
	SubtitleHasSuffix    *string  `json:"subtitleHasSuffix,omitempty"`
	SubtitleEqualFold    *string  `json:"subtitleEqualFold,omitempty"`
	SubtitleContainsFold *string  `json:"subtitleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "unit" edge predicates.
	HasUnit     *bool             `json:"hasUnit,omitempty"`
	HasUnitWith []*UnitWhereInput `json:"hasUnitWith,omitempty"`

	// "lessons" edge predicates.
	HasLessons     *bool               `json:"hasLessons,omitempty"`
	HasLessonsWith []*LessonWhereInput `json:"hasLessonsWith,omitempty"`

	// "techniques" edge predicates.
	HasTechniques     *bool             `json:"hasTechniques,omitempty"`
	HasTechniquesWith []*UnitWhereInput `json:"hasTechniquesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TechniqueWhereInput) AddPredicates(predicates ...predicate.Technique) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TechniqueWhereInput filter on the TechniqueQuery builder.
func (i *TechniqueWhereInput) Filter(q *TechniqueQuery) (*TechniqueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTechniqueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTechniqueWhereInput is returned in case the TechniqueWhereInput is empty.
var ErrEmptyTechniqueWhereInput = errors.New("ent: empty predicate TechniqueWhereInput")

// P returns a predicate for filtering techniques.
// An error is returned if the input is empty or invalid.
func (i *TechniqueWhereInput) P() (predicate.Technique, error) {
	var predicates []predicate.Technique
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, technique.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Technique, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, technique.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Technique, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, technique.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, technique.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, technique.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, technique.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, technique.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, technique.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, technique.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, technique.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, technique.IDLTE(*i.IDLTE))
	}
	if i.UnitID != nil {
		predicates = append(predicates, technique.UnitIDEQ(*i.UnitID))
	}
	if i.UnitIDNEQ != nil {
		predicates = append(predicates, technique.UnitIDNEQ(*i.UnitIDNEQ))
	}
	if len(i.UnitIDIn) > 0 {
		predicates = append(predicates, technique.UnitIDIn(i.UnitIDIn...))
	}
	if len(i.UnitIDNotIn) > 0 {
		predicates = append(predicates, technique.UnitIDNotIn(i.UnitIDNotIn...))
	}
	if i.IconImage != nil {
		predicates = append(predicates, technique.IconImageEQ(*i.IconImage))
	}
	if i.IconImageNEQ != nil {
		predicates = append(predicates, technique.IconImageNEQ(*i.IconImageNEQ))
	}
	if len(i.IconImageIn) > 0 {
		predicates = append(predicates, technique.IconImageIn(i.IconImageIn...))
	}
	if len(i.IconImageNotIn) > 0 {
		predicates = append(predicates, technique.IconImageNotIn(i.IconImageNotIn...))
	}
	if i.IconImageGT != nil {
		predicates = append(predicates, technique.IconImageGT(*i.IconImageGT))
	}
	if i.IconImageGTE != nil {
		predicates = append(predicates, technique.IconImageGTE(*i.IconImageGTE))
	}
	if i.IconImageLT != nil {
		predicates = append(predicates, technique.IconImageLT(*i.IconImageLT))
	}
	if i.IconImageLTE != nil {
		predicates = append(predicates, technique.IconImageLTE(*i.IconImageLTE))
	}
	if i.IconImageContains != nil {
		predicates = append(predicates, technique.IconImageContains(*i.IconImageContains))
	}
	if i.IconImageHasPrefix != nil {
		predicates = append(predicates, technique.IconImageHasPrefix(*i.IconImageHasPrefix))
	}
	if i.IconImageHasSuffix != nil {
		predicates = append(predicates, technique.IconImageHasSuffix(*i.IconImageHasSuffix))
	}
	if i.IconImageEqualFold != nil {
		predicates = append(predicates, technique.IconImageEqualFold(*i.IconImageEqualFold))
	}
	if i.IconImageContainsFold != nil {
		predicates = append(predicates, technique.IconImageContainsFold(*i.IconImageContainsFold))
	}
	if i.CoverImage != nil {
		predicates = append(predicates, technique.CoverImageEQ(*i.CoverImage))
	}
	if i.CoverImageNEQ != nil {
		predicates = append(predicates, technique.CoverImageNEQ(*i.CoverImageNEQ))
	}
	if len(i.CoverImageIn) > 0 {
		predicates = append(predicates, technique.CoverImageIn(i.CoverImageIn...))
	}
	if len(i.CoverImageNotIn) > 0 {
		predicates = append(predicates, technique.CoverImageNotIn(i.CoverImageNotIn...))
	}
	if i.CoverImageGT != nil {
		predicates = append(predicates, technique.CoverImageGT(*i.CoverImageGT))
	}
	if i.CoverImageGTE != nil {
		predicates = append(predicates, technique.CoverImageGTE(*i.CoverImageGTE))
	}
	if i.CoverImageLT != nil {
		predicates = append(predicates, technique.CoverImageLT(*i.CoverImageLT))
	}
	if i.CoverImageLTE != nil {
		predicates = append(predicates, technique.CoverImageLTE(*i.CoverImageLTE))
	}
	if i.CoverImageContains != nil {
		predicates = append(predicates, technique.CoverImageContains(*i.CoverImageContains))
	}
	if i.CoverImageHasPrefix != nil {
		predicates = append(predicates, technique.CoverImageHasPrefix(*i.CoverImageHasPrefix))
	}
	if i.CoverImageHasSuffix != nil {
		predicates = append(predicates, technique.CoverImageHasSuffix(*i.CoverImageHasSuffix))
	}
	if i.CoverImageEqualFold != nil {
		predicates = append(predicates, technique.CoverImageEqualFold(*i.CoverImageEqualFold))
	}
	if i.CoverImageContainsFold != nil {
		predicates = append(predicates, technique.CoverImageContainsFold(*i.CoverImageContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, technique.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, technique.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, technique.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, technique.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, technique.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, technique.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, technique.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, technique.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, technique.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, technique.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, technique.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, technique.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, technique.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Subtitle != nil {
		predicates = append(predicates, technique.SubtitleEQ(*i.Subtitle))
	}
	if i.SubtitleNEQ != nil {
		predicates = append(predicates, technique.SubtitleNEQ(*i.SubtitleNEQ))
	}
	if len(i.SubtitleIn) > 0 {
		predicates = append(predicates, technique.SubtitleIn(i.SubtitleIn...))
	}
	if len(i.SubtitleNotIn) > 0 {
		predicates = append(predicates, technique.SubtitleNotIn(i.SubtitleNotIn...))
	}
	if i.SubtitleGT != nil {
		predicates = append(predicates, technique.SubtitleGT(*i.SubtitleGT))
	}
	if i.SubtitleGTE != nil {
		predicates = append(predicates, technique.SubtitleGTE(*i.SubtitleGTE))
	}
	if i.SubtitleLT != nil {
		predicates = append(predicates, technique.SubtitleLT(*i.SubtitleLT))
	}
	if i.SubtitleLTE != nil {
		predicates = append(predicates, technique.SubtitleLTE(*i.SubtitleLTE))
	}
	if i.SubtitleContains != nil {
		predicates = append(predicates, technique.SubtitleContains(*i.SubtitleContains))
	}
	if i.SubtitleHasPrefix != nil {
		predicates = append(predicates, technique.SubtitleHasPrefix(*i.SubtitleHasPrefix))
	}
	if i.SubtitleHasSuffix != nil {
		predicates = append(predicates, technique.SubtitleHasSuffix(*i.SubtitleHasSuffix))
	}
	if i.SubtitleEqualFold != nil {
		predicates = append(predicates, technique.SubtitleEqualFold(*i.SubtitleEqualFold))
	}
	if i.SubtitleContainsFold != nil {
		predicates = append(predicates, technique.SubtitleContainsFold(*i.SubtitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, technique.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, technique.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, technique.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, technique.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, technique.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, technique.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, technique.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, technique.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, technique.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, technique.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, technique.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, technique.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, technique.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, technique.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, technique.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, technique.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, technique.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, technique.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, technique.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, technique.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, technique.OrderLTE(*i.OrderLTE))
	}

	if i.HasUnit != nil {
		p := technique.HasUnit()
		if !*i.HasUnit {
			p = technique.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUnitWith) > 0 {
		with := make([]predicate.Unit, 0, len(i.HasUnitWith))
		for _, w := range i.HasUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUnitWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, technique.HasUnitWith(with...))
	}
	if i.HasLessons != nil {
		p := technique.HasLessons()
		if !*i.HasLessons {
			p = technique.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLessonsWith) > 0 {
		with := make([]predicate.Lesson, 0, len(i.HasLessonsWith))
		for _, w := range i.HasLessonsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLessonsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, technique.HasLessonsWith(with...))
	}
	if i.HasTechniques != nil {
		p := technique.HasTechniques()
		if !*i.HasTechniques {
			p = technique.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTechniquesWith) > 0 {
		with := make([]predicate.Unit, 0, len(i.HasTechniquesWith))
		for _, w := range i.HasTechniquesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTechniquesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, technique.HasTechniquesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTechniqueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return technique.And(predicates...), nil
	}
}

// UnitWhereInput represents a where input for filtering Unit queries.
type UnitWhereInput struct {
	Predicates []predicate.Unit  `json:"-"`
	Not        *UnitWhereInput   `json:"not,omitempty"`
	Or         []*UnitWhereInput `json:"or,omitempty"`
	And        []*UnitWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.UnitID  `json:"id,omitempty"`
	IDNEQ   *gqlid.UnitID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.UnitID `json:"idIn,omitempty"`
	IDNotIn []gqlid.UnitID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.UnitID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.UnitID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.UnitID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.UnitID  `json:"idLTE,omitempty"`

	// "course_id" field predicates.
	CourseID      *gqlid.CourseID  `json:"courseID,omitempty"`
	CourseIDNEQ   *gqlid.CourseID  `json:"courseIDNEQ,omitempty"`
	CourseIDIn    []gqlid.CourseID `json:"courseIDIn,omitempty"`
	CourseIDNotIn []gqlid.CourseID `json:"courseIDNotIn,omitempty"`

	// "iconImage" field predicates.
	IconImage             *string  `json:"iconimage,omitempty"`
	IconImageNEQ          *string  `json:"iconimageNEQ,omitempty"`
	IconImageIn           []string `json:"iconimageIn,omitempty"`
	IconImageNotIn        []string `json:"iconimageNotIn,omitempty"`
	IconImageGT           *string  `json:"iconimageGT,omitempty"`
	IconImageGTE          *string  `json:"iconimageGTE,omitempty"`
	IconImageLT           *string  `json:"iconimageLT,omitempty"`
	IconImageLTE          *string  `json:"iconimageLTE,omitempty"`
	IconImageContains     *string  `json:"iconimageContains,omitempty"`
	IconImageHasPrefix    *string  `json:"iconimageHasPrefix,omitempty"`
	IconImageHasSuffix    *string  `json:"iconimageHasSuffix,omitempty"`
	IconImageEqualFold    *string  `json:"iconimageEqualFold,omitempty"`
	IconImageContainsFold *string  `json:"iconimageContainsFold,omitempty"`

	// "coverImage" field predicates.
	CoverImage             *string  `json:"coverimage,omitempty"`
	CoverImageNEQ          *string  `json:"coverimageNEQ,omitempty"`
	CoverImageIn           []string `json:"coverimageIn,omitempty"`
	CoverImageNotIn        []string `json:"coverimageNotIn,omitempty"`
	CoverImageGT           *string  `json:"coverimageGT,omitempty"`
	CoverImageGTE          *string  `json:"coverimageGTE,omitempty"`
	CoverImageLT           *string  `json:"coverimageLT,omitempty"`
	CoverImageLTE          *string  `json:"coverimageLTE,omitempty"`
	CoverImageContains     *string  `json:"coverimageContains,omitempty"`
	CoverImageHasPrefix    *string  `json:"coverimageHasPrefix,omitempty"`
	CoverImageHasSuffix    *string  `json:"coverimageHasSuffix,omitempty"`
	CoverImageEqualFold    *string  `json:"coverimageEqualFold,omitempty"`
	CoverImageContainsFold *string  `json:"coverimageContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "subtitle" field predicates.
	Subtitle             *string  `json:"subtitle,omitempty"`
	SubtitleNEQ          *string  `json:"subtitleNEQ,omitempty"`
	SubtitleIn           []string `json:"subtitleIn,omitempty"`
	SubtitleNotIn        []string `json:"subtitleNotIn,omitempty"`
	SubtitleGT           *string  `json:"subtitleGT,omitempty"`
	SubtitleGTE          *string  `json:"subtitleGTE,omitempty"`
	SubtitleLT           *string  `json:"subtitleLT,omitempty"`
	SubtitleLTE          *string  `json:"subtitleLTE,omitempty"`
	SubtitleContains     *string  `json:"subtitleContains,omitempty"`
	SubtitleHasPrefix    *string  `json:"subtitleHasPrefix,omitempty"`
	SubtitleHasSuffix    *string  `json:"subtitleHasSuffix,omitempty"`
	SubtitleEqualFold    *string  `json:"subtitleEqualFold,omitempty"`
	SubtitleContainsFold *string  `json:"subtitleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "mastering" field predicates.
	Mastering             *string  `json:"mastering,omitempty"`
	MasteringNEQ          *string  `json:"masteringNEQ,omitempty"`
	MasteringIn           []string `json:"masteringIn,omitempty"`
	MasteringNotIn        []string `json:"masteringNotIn,omitempty"`
	MasteringGT           *string  `json:"masteringGT,omitempty"`
	MasteringGTE          *string  `json:"masteringGTE,omitempty"`
	MasteringLT           *string  `json:"masteringLT,omitempty"`
	MasteringLTE          *string  `json:"masteringLTE,omitempty"`
	MasteringContains     *string  `json:"masteringContains,omitempty"`
	MasteringHasPrefix    *string  `json:"masteringHasPrefix,omitempty"`
	MasteringHasSuffix    *string  `json:"masteringHasSuffix,omitempty"`
	MasteringEqualFold    *string  `json:"masteringEqualFold,omitempty"`
	MasteringContainsFold *string  `json:"masteringContainsFold,omitempty"`

	// "days" field predicates.
	Days      *int  `json:"days,omitempty"`
	DaysNEQ   *int  `json:"daysNEQ,omitempty"`
	DaysIn    []int `json:"daysIn,omitempty"`
	DaysNotIn []int `json:"daysNotIn,omitempty"`
	DaysGT    *int  `json:"daysGT,omitempty"`
	DaysGTE   *int  `json:"daysGTE,omitempty"`
	DaysLT    *int  `json:"daysLT,omitempty"`
	DaysLTE   *int  `json:"daysLTE,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "course" edge predicates.
	HasCourse     *bool               `json:"hasCourse,omitempty"`
	HasCourseWith []*CourseWhereInput `json:"hasCourseWith,omitempty"`

	// "lessons" edge predicates.
	HasLessons     *bool               `json:"hasLessons,omitempty"`
	HasLessonsWith []*LessonWhereInput `json:"hasLessonsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UnitWhereInput) AddPredicates(predicates ...predicate.Unit) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UnitWhereInput filter on the UnitQuery builder.
func (i *UnitWhereInput) Filter(q *UnitQuery) (*UnitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUnitWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUnitWhereInput is returned in case the UnitWhereInput is empty.
var ErrEmptyUnitWhereInput = errors.New("ent: empty predicate UnitWhereInput")

// P returns a predicate for filtering units.
// An error is returned if the input is empty or invalid.
func (i *UnitWhereInput) P() (predicate.Unit, error) {
	var predicates []predicate.Unit
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, unit.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Unit, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, unit.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Unit, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, unit.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, unit.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, unit.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, unit.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, unit.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, unit.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, unit.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, unit.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, unit.IDLTE(*i.IDLTE))
	}
	if i.CourseID != nil {
		predicates = append(predicates, unit.CourseIDEQ(*i.CourseID))
	}
	if i.CourseIDNEQ != nil {
		predicates = append(predicates, unit.CourseIDNEQ(*i.CourseIDNEQ))
	}
	if len(i.CourseIDIn) > 0 {
		predicates = append(predicates, unit.CourseIDIn(i.CourseIDIn...))
	}
	if len(i.CourseIDNotIn) > 0 {
		predicates = append(predicates, unit.CourseIDNotIn(i.CourseIDNotIn...))
	}
	if i.IconImage != nil {
		predicates = append(predicates, unit.IconImageEQ(*i.IconImage))
	}
	if i.IconImageNEQ != nil {
		predicates = append(predicates, unit.IconImageNEQ(*i.IconImageNEQ))
	}
	if len(i.IconImageIn) > 0 {
		predicates = append(predicates, unit.IconImageIn(i.IconImageIn...))
	}
	if len(i.IconImageNotIn) > 0 {
		predicates = append(predicates, unit.IconImageNotIn(i.IconImageNotIn...))
	}
	if i.IconImageGT != nil {
		predicates = append(predicates, unit.IconImageGT(*i.IconImageGT))
	}
	if i.IconImageGTE != nil {
		predicates = append(predicates, unit.IconImageGTE(*i.IconImageGTE))
	}
	if i.IconImageLT != nil {
		predicates = append(predicates, unit.IconImageLT(*i.IconImageLT))
	}
	if i.IconImageLTE != nil {
		predicates = append(predicates, unit.IconImageLTE(*i.IconImageLTE))
	}
	if i.IconImageContains != nil {
		predicates = append(predicates, unit.IconImageContains(*i.IconImageContains))
	}
	if i.IconImageHasPrefix != nil {
		predicates = append(predicates, unit.IconImageHasPrefix(*i.IconImageHasPrefix))
	}
	if i.IconImageHasSuffix != nil {
		predicates = append(predicates, unit.IconImageHasSuffix(*i.IconImageHasSuffix))
	}
	if i.IconImageEqualFold != nil {
		predicates = append(predicates, unit.IconImageEqualFold(*i.IconImageEqualFold))
	}
	if i.IconImageContainsFold != nil {
		predicates = append(predicates, unit.IconImageContainsFold(*i.IconImageContainsFold))
	}
	if i.CoverImage != nil {
		predicates = append(predicates, unit.CoverImageEQ(*i.CoverImage))
	}
	if i.CoverImageNEQ != nil {
		predicates = append(predicates, unit.CoverImageNEQ(*i.CoverImageNEQ))
	}
	if len(i.CoverImageIn) > 0 {
		predicates = append(predicates, unit.CoverImageIn(i.CoverImageIn...))
	}
	if len(i.CoverImageNotIn) > 0 {
		predicates = append(predicates, unit.CoverImageNotIn(i.CoverImageNotIn...))
	}
	if i.CoverImageGT != nil {
		predicates = append(predicates, unit.CoverImageGT(*i.CoverImageGT))
	}
	if i.CoverImageGTE != nil {
		predicates = append(predicates, unit.CoverImageGTE(*i.CoverImageGTE))
	}
	if i.CoverImageLT != nil {
		predicates = append(predicates, unit.CoverImageLT(*i.CoverImageLT))
	}
	if i.CoverImageLTE != nil {
		predicates = append(predicates, unit.CoverImageLTE(*i.CoverImageLTE))
	}
	if i.CoverImageContains != nil {
		predicates = append(predicates, unit.CoverImageContains(*i.CoverImageContains))
	}
	if i.CoverImageHasPrefix != nil {
		predicates = append(predicates, unit.CoverImageHasPrefix(*i.CoverImageHasPrefix))
	}
	if i.CoverImageHasSuffix != nil {
		predicates = append(predicates, unit.CoverImageHasSuffix(*i.CoverImageHasSuffix))
	}
	if i.CoverImageEqualFold != nil {
		predicates = append(predicates, unit.CoverImageEqualFold(*i.CoverImageEqualFold))
	}
	if i.CoverImageContainsFold != nil {
		predicates = append(predicates, unit.CoverImageContainsFold(*i.CoverImageContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, unit.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, unit.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, unit.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, unit.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, unit.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, unit.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, unit.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, unit.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, unit.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, unit.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, unit.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, unit.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, unit.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Subtitle != nil {
		predicates = append(predicates, unit.SubtitleEQ(*i.Subtitle))
	}
	if i.SubtitleNEQ != nil {
		predicates = append(predicates, unit.SubtitleNEQ(*i.SubtitleNEQ))
	}
	if len(i.SubtitleIn) > 0 {
		predicates = append(predicates, unit.SubtitleIn(i.SubtitleIn...))
	}
	if len(i.SubtitleNotIn) > 0 {
		predicates = append(predicates, unit.SubtitleNotIn(i.SubtitleNotIn...))
	}
	if i.SubtitleGT != nil {
		predicates = append(predicates, unit.SubtitleGT(*i.SubtitleGT))
	}
	if i.SubtitleGTE != nil {
		predicates = append(predicates, unit.SubtitleGTE(*i.SubtitleGTE))
	}
	if i.SubtitleLT != nil {
		predicates = append(predicates, unit.SubtitleLT(*i.SubtitleLT))
	}
	if i.SubtitleLTE != nil {
		predicates = append(predicates, unit.SubtitleLTE(*i.SubtitleLTE))
	}
	if i.SubtitleContains != nil {
		predicates = append(predicates, unit.SubtitleContains(*i.SubtitleContains))
	}
	if i.SubtitleHasPrefix != nil {
		predicates = append(predicates, unit.SubtitleHasPrefix(*i.SubtitleHasPrefix))
	}
	if i.SubtitleHasSuffix != nil {
		predicates = append(predicates, unit.SubtitleHasSuffix(*i.SubtitleHasSuffix))
	}
	if i.SubtitleEqualFold != nil {
		predicates = append(predicates, unit.SubtitleEqualFold(*i.SubtitleEqualFold))
	}
	if i.SubtitleContainsFold != nil {
		predicates = append(predicates, unit.SubtitleContainsFold(*i.SubtitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, unit.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, unit.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, unit.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, unit.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, unit.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, unit.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, unit.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, unit.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, unit.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, unit.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, unit.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, unit.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, unit.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Mastering != nil {
		predicates = append(predicates, unit.MasteringEQ(*i.Mastering))
	}
	if i.MasteringNEQ != nil {
		predicates = append(predicates, unit.MasteringNEQ(*i.MasteringNEQ))
	}
	if len(i.MasteringIn) > 0 {
		predicates = append(predicates, unit.MasteringIn(i.MasteringIn...))
	}
	if len(i.MasteringNotIn) > 0 {
		predicates = append(predicates, unit.MasteringNotIn(i.MasteringNotIn...))
	}
	if i.MasteringGT != nil {
		predicates = append(predicates, unit.MasteringGT(*i.MasteringGT))
	}
	if i.MasteringGTE != nil {
		predicates = append(predicates, unit.MasteringGTE(*i.MasteringGTE))
	}
	if i.MasteringLT != nil {
		predicates = append(predicates, unit.MasteringLT(*i.MasteringLT))
	}
	if i.MasteringLTE != nil {
		predicates = append(predicates, unit.MasteringLTE(*i.MasteringLTE))
	}
	if i.MasteringContains != nil {
		predicates = append(predicates, unit.MasteringContains(*i.MasteringContains))
	}
	if i.MasteringHasPrefix != nil {
		predicates = append(predicates, unit.MasteringHasPrefix(*i.MasteringHasPrefix))
	}
	if i.MasteringHasSuffix != nil {
		predicates = append(predicates, unit.MasteringHasSuffix(*i.MasteringHasSuffix))
	}
	if i.MasteringEqualFold != nil {
		predicates = append(predicates, unit.MasteringEqualFold(*i.MasteringEqualFold))
	}
	if i.MasteringContainsFold != nil {
		predicates = append(predicates, unit.MasteringContainsFold(*i.MasteringContainsFold))
	}
	if i.Days != nil {
		predicates = append(predicates, unit.DaysEQ(*i.Days))
	}
	if i.DaysNEQ != nil {
		predicates = append(predicates, unit.DaysNEQ(*i.DaysNEQ))
	}
	if len(i.DaysIn) > 0 {
		predicates = append(predicates, unit.DaysIn(i.DaysIn...))
	}
	if len(i.DaysNotIn) > 0 {
		predicates = append(predicates, unit.DaysNotIn(i.DaysNotIn...))
	}
	if i.DaysGT != nil {
		predicates = append(predicates, unit.DaysGT(*i.DaysGT))
	}
	if i.DaysGTE != nil {
		predicates = append(predicates, unit.DaysGTE(*i.DaysGTE))
	}
	if i.DaysLT != nil {
		predicates = append(predicates, unit.DaysLT(*i.DaysLT))
	}
	if i.DaysLTE != nil {
		predicates = append(predicates, unit.DaysLTE(*i.DaysLTE))
	}
	if i.Color != nil {
		predicates = append(predicates, unit.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, unit.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, unit.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, unit.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, unit.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, unit.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, unit.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, unit.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, unit.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, unit.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, unit.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, unit.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, unit.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.Order != nil {
		predicates = append(predicates, unit.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, unit.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, unit.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, unit.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, unit.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, unit.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, unit.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, unit.OrderLTE(*i.OrderLTE))
	}

	if i.HasCourse != nil {
		p := unit.HasCourse()
		if !*i.HasCourse {
			p = unit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseWith) > 0 {
		with := make([]predicate.Course, 0, len(i.HasCourseWith))
		for _, w := range i.HasCourseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCourseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, unit.HasCourseWith(with...))
	}
	if i.HasLessons != nil {
		p := unit.HasLessons()
		if !*i.HasLessons {
			p = unit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLessonsWith) > 0 {
		with := make([]predicate.Lesson, 0, len(i.HasLessonsWith))
		for _, w := range i.HasLessonsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLessonsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, unit.HasLessonsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUnitWhereInput
	case 1:
		return predicates[0], nil
	default:
		return unit.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.UserID  `json:"id,omitempty"`
	IDNEQ   *gqlid.UserID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.UserID `json:"idIn,omitempty"`
	IDNotIn []gqlid.UserID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.UserID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.UserID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.UserID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.UserID  `json:"idLTE,omitempty"`

	// "firebaseUid" field predicates.
	FirebaseUid             *string  `json:"firebaseuid,omitempty"`
	FirebaseUidNEQ          *string  `json:"firebaseuidNEQ,omitempty"`
	FirebaseUidIn           []string `json:"firebaseuidIn,omitempty"`
	FirebaseUidNotIn        []string `json:"firebaseuidNotIn,omitempty"`
	FirebaseUidGT           *string  `json:"firebaseuidGT,omitempty"`
	FirebaseUidGTE          *string  `json:"firebaseuidGTE,omitempty"`
	FirebaseUidLT           *string  `json:"firebaseuidLT,omitempty"`
	FirebaseUidLTE          *string  `json:"firebaseuidLTE,omitempty"`
	FirebaseUidContains     *string  `json:"firebaseuidContains,omitempty"`
	FirebaseUidHasPrefix    *string  `json:"firebaseuidHasPrefix,omitempty"`
	FirebaseUidHasSuffix    *string  `json:"firebaseuidHasSuffix,omitempty"`
	FirebaseUidIsNil        bool     `json:"firebaseuidIsNil,omitempty"`
	FirebaseUidNotNil       bool     `json:"firebaseuidNotNil,omitempty"`
	FirebaseUidEqualFold    *string  `json:"firebaseuidEqualFold,omitempty"`
	FirebaseUidContainsFold *string  `json:"firebaseuidContainsFold,omitempty"`

	// "displayName" field predicates.
	DisplayName             *string  `json:"displayname,omitempty"`
	DisplayNameNEQ          *string  `json:"displaynameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displaynameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displaynameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displaynameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displaynameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displaynameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displaynameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displaynameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displaynameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displaynameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displaynameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displaynameContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "auth_method" field predicates.
	AuthMethod      *property.AuthMethod  `json:"authMethod,omitempty"`
	AuthMethodNEQ   *property.AuthMethod  `json:"authMethodNEQ,omitempty"`
	AuthMethodIn    []property.AuthMethod `json:"authMethodIn,omitempty"`
	AuthMethodNotIn []property.AuthMethod `json:"authMethodNotIn,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "email_verified" field predicates.
	EmailVerified    *bool `json:"emailVerified,omitempty"`
	EmailVerifiedNEQ *bool `json:"emailVerifiedNEQ,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.FirebaseUid != nil {
		predicates = append(predicates, user.FirebaseUidEQ(*i.FirebaseUid))
	}
	if i.FirebaseUidNEQ != nil {
		predicates = append(predicates, user.FirebaseUidNEQ(*i.FirebaseUidNEQ))
	}
	if len(i.FirebaseUidIn) > 0 {
		predicates = append(predicates, user.FirebaseUidIn(i.FirebaseUidIn...))
	}
	if len(i.FirebaseUidNotIn) > 0 {
		predicates = append(predicates, user.FirebaseUidNotIn(i.FirebaseUidNotIn...))
	}
	if i.FirebaseUidGT != nil {
		predicates = append(predicates, user.FirebaseUidGT(*i.FirebaseUidGT))
	}
	if i.FirebaseUidGTE != nil {
		predicates = append(predicates, user.FirebaseUidGTE(*i.FirebaseUidGTE))
	}
	if i.FirebaseUidLT != nil {
		predicates = append(predicates, user.FirebaseUidLT(*i.FirebaseUidLT))
	}
	if i.FirebaseUidLTE != nil {
		predicates = append(predicates, user.FirebaseUidLTE(*i.FirebaseUidLTE))
	}
	if i.FirebaseUidContains != nil {
		predicates = append(predicates, user.FirebaseUidContains(*i.FirebaseUidContains))
	}
	if i.FirebaseUidHasPrefix != nil {
		predicates = append(predicates, user.FirebaseUidHasPrefix(*i.FirebaseUidHasPrefix))
	}
	if i.FirebaseUidHasSuffix != nil {
		predicates = append(predicates, user.FirebaseUidHasSuffix(*i.FirebaseUidHasSuffix))
	}
	if i.FirebaseUidIsNil {
		predicates = append(predicates, user.FirebaseUidIsNil())
	}
	if i.FirebaseUidNotNil {
		predicates = append(predicates, user.FirebaseUidNotNil())
	}
	if i.FirebaseUidEqualFold != nil {
		predicates = append(predicates, user.FirebaseUidEqualFold(*i.FirebaseUidEqualFold))
	}
	if i.FirebaseUidContainsFold != nil {
		predicates = append(predicates, user.FirebaseUidContainsFold(*i.FirebaseUidContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.AuthMethod != nil {
		predicates = append(predicates, user.AuthMethodEQ(*i.AuthMethod))
	}
	if i.AuthMethodNEQ != nil {
		predicates = append(predicates, user.AuthMethodNEQ(*i.AuthMethodNEQ))
	}
	if len(i.AuthMethodIn) > 0 {
		predicates = append(predicates, user.AuthMethodIn(i.AuthMethodIn...))
	}
	if len(i.AuthMethodNotIn) > 0 {
		predicates = append(predicates, user.AuthMethodNotIn(i.AuthMethodNotIn...))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, user.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, user.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.EmailVerified != nil {
		predicates = append(predicates, user.EmailVerifiedEQ(*i.EmailVerified))
	}
	if i.EmailVerifiedNEQ != nil {
		predicates = append(predicates, user.EmailVerifiedNEQ(*i.EmailVerifiedNEQ))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserProgressWhereInput represents a where input for filtering UserProgress queries.
type UserProgressWhereInput struct {
	Predicates []predicate.UserProgress  `json:"-"`
	Not        *UserProgressWhereInput   `json:"not,omitempty"`
	Or         []*UserProgressWhereInput `json:"or,omitempty"`
	And        []*UserProgressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *gqlid.UserProgressID  `json:"id,omitempty"`
	IDNEQ   *gqlid.UserProgressID  `json:"idNEQ,omitempty"`
	IDIn    []gqlid.UserProgressID `json:"idIn,omitempty"`
	IDNotIn []gqlid.UserProgressID `json:"idNotIn,omitempty"`
	IDGT    *gqlid.UserProgressID  `json:"idGT,omitempty"`
	IDGTE   *gqlid.UserProgressID  `json:"idGTE,omitempty"`
	IDLT    *gqlid.UserProgressID  `json:"idLT,omitempty"`
	IDLTE   *gqlid.UserProgressID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *gqlid.UserID  `json:"userID,omitempty"`
	UserIDNEQ   *gqlid.UserID  `json:"userIDNEQ,omitempty"`
	UserIDIn    []gqlid.UserID `json:"userIDIn,omitempty"`
	UserIDNotIn []gqlid.UserID `json:"userIDNotIn,omitempty"`

	// "course_id" field predicates.
	CourseID      *gqlid.CourseID  `json:"courseID,omitempty"`
	CourseIDNEQ   *gqlid.CourseID  `json:"courseIDNEQ,omitempty"`
	CourseIDIn    []gqlid.CourseID `json:"courseIDIn,omitempty"`
	CourseIDNotIn []gqlid.CourseID `json:"courseIDNotIn,omitempty"`

	// "unit_id" field predicates.
	UnitID      *gqlid.UnitID  `json:"unitID,omitempty"`
	UnitIDNEQ   *gqlid.UnitID  `json:"unitIDNEQ,omitempty"`
	UnitIDIn    []gqlid.UnitID `json:"unitIDIn,omitempty"`
	UnitIDNotIn []gqlid.UnitID `json:"unitIDNotIn,omitempty"`

	// "lesson_id" field predicates.
	LessonID      *gqlid.LessonID  `json:"lessonID,omitempty"`
	LessonIDNEQ   *gqlid.LessonID  `json:"lessonIDNEQ,omitempty"`
	LessonIDIn    []gqlid.LessonID `json:"lessonIDIn,omitempty"`
	LessonIDNotIn []gqlid.LessonID `json:"lessonIDNotIn,omitempty"`

	// "lesson_type" field predicates.
	LessonType      *property.LessonType  `json:"lessonType,omitempty"`
	LessonTypeNEQ   *property.LessonType  `json:"lessonTypeNEQ,omitempty"`
	LessonTypeIn    []property.LessonType `json:"lessonTypeIn,omitempty"`
	LessonTypeNotIn []property.LessonType `json:"lessonTypeNotIn,omitempty"`

	// "isLast" field predicates.
	IsLast    *bool `json:"islast,omitempty"`
	IsLastNEQ *bool `json:"islastNEQ,omitempty"`

	// "isNext" field predicates.
	IsNext    *bool `json:"isnext,omitempty"`
	IsNextNEQ *bool `json:"isnextNEQ,omitempty"`

	// "progress" field predicates.
	Progress      *int64  `json:"progress,omitempty"`
	ProgressNEQ   *int64  `json:"progressNEQ,omitempty"`
	ProgressIn    []int64 `json:"progressIn,omitempty"`
	ProgressNotIn []int64 `json:"progressNotIn,omitempty"`
	ProgressGT    *int64  `json:"progressGT,omitempty"`
	ProgressGTE   *int64  `json:"progressGTE,omitempty"`
	ProgressLT    *int64  `json:"progressLT,omitempty"`
	ProgressLTE   *int64  `json:"progressLTE,omitempty"`

	// "finishedAt" field predicates.
	FinishedAt       *time.Time  `json:"finishedat,omitempty"`
	FinishedAtNEQ    *time.Time  `json:"finishedatNEQ,omitempty"`
	FinishedAtIn     []time.Time `json:"finishedatIn,omitempty"`
	FinishedAtNotIn  []time.Time `json:"finishedatNotIn,omitempty"`
	FinishedAtGT     *time.Time  `json:"finishedatGT,omitempty"`
	FinishedAtGTE    *time.Time  `json:"finishedatGTE,omitempty"`
	FinishedAtLT     *time.Time  `json:"finishedatLT,omitempty"`
	FinishedAtLTE    *time.Time  `json:"finishedatLTE,omitempty"`
	FinishedAtIsNil  bool        `json:"finishedatIsNil,omitempty"`
	FinishedAtNotNil bool        `json:"finishedatNotNil,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "course" edge predicates.
	HasCourse     *bool               `json:"hasCourse,omitempty"`
	HasCourseWith []*CourseWhereInput `json:"hasCourseWith,omitempty"`

	// "unit" edge predicates.
	HasUnit     *bool             `json:"hasUnit,omitempty"`
	HasUnitWith []*UnitWhereInput `json:"hasUnitWith,omitempty"`

	// "lesson" edge predicates.
	HasLesson     *bool               `json:"hasLesson,omitempty"`
	HasLessonWith []*LessonWhereInput `json:"hasLessonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserProgressWhereInput) AddPredicates(predicates ...predicate.UserProgress) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserProgressWhereInput filter on the UserProgressQuery builder.
func (i *UserProgressWhereInput) Filter(q *UserProgressQuery) (*UserProgressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserProgressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserProgressWhereInput is returned in case the UserProgressWhereInput is empty.
var ErrEmptyUserProgressWhereInput = errors.New("ent: empty predicate UserProgressWhereInput")

// P returns a predicate for filtering userprogresses.
// An error is returned if the input is empty or invalid.
func (i *UserProgressWhereInput) P() (predicate.UserProgress, error) {
	var predicates []predicate.UserProgress
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userprogress.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserProgress, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userprogress.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserProgress, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userprogress.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userprogress.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userprogress.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userprogress.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userprogress.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userprogress.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userprogress.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userprogress.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userprogress.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, userprogress.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userprogress.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userprogress.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userprogress.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.CourseID != nil {
		predicates = append(predicates, userprogress.CourseIDEQ(*i.CourseID))
	}
	if i.CourseIDNEQ != nil {
		predicates = append(predicates, userprogress.CourseIDNEQ(*i.CourseIDNEQ))
	}
	if len(i.CourseIDIn) > 0 {
		predicates = append(predicates, userprogress.CourseIDIn(i.CourseIDIn...))
	}
	if len(i.CourseIDNotIn) > 0 {
		predicates = append(predicates, userprogress.CourseIDNotIn(i.CourseIDNotIn...))
	}
	if i.UnitID != nil {
		predicates = append(predicates, userprogress.UnitIDEQ(*i.UnitID))
	}
	if i.UnitIDNEQ != nil {
		predicates = append(predicates, userprogress.UnitIDNEQ(*i.UnitIDNEQ))
	}
	if len(i.UnitIDIn) > 0 {
		predicates = append(predicates, userprogress.UnitIDIn(i.UnitIDIn...))
	}
	if len(i.UnitIDNotIn) > 0 {
		predicates = append(predicates, userprogress.UnitIDNotIn(i.UnitIDNotIn...))
	}
	if i.LessonID != nil {
		predicates = append(predicates, userprogress.LessonIDEQ(*i.LessonID))
	}
	if i.LessonIDNEQ != nil {
		predicates = append(predicates, userprogress.LessonIDNEQ(*i.LessonIDNEQ))
	}
	if len(i.LessonIDIn) > 0 {
		predicates = append(predicates, userprogress.LessonIDIn(i.LessonIDIn...))
	}
	if len(i.LessonIDNotIn) > 0 {
		predicates = append(predicates, userprogress.LessonIDNotIn(i.LessonIDNotIn...))
	}
	if i.LessonType != nil {
		predicates = append(predicates, userprogress.LessonTypeEQ(*i.LessonType))
	}
	if i.LessonTypeNEQ != nil {
		predicates = append(predicates, userprogress.LessonTypeNEQ(*i.LessonTypeNEQ))
	}
	if len(i.LessonTypeIn) > 0 {
		predicates = append(predicates, userprogress.LessonTypeIn(i.LessonTypeIn...))
	}
	if len(i.LessonTypeNotIn) > 0 {
		predicates = append(predicates, userprogress.LessonTypeNotIn(i.LessonTypeNotIn...))
	}
	if i.IsLast != nil {
		predicates = append(predicates, userprogress.IsLastEQ(*i.IsLast))
	}
	if i.IsLastNEQ != nil {
		predicates = append(predicates, userprogress.IsLastNEQ(*i.IsLastNEQ))
	}
	if i.IsNext != nil {
		predicates = append(predicates, userprogress.IsNextEQ(*i.IsNext))
	}
	if i.IsNextNEQ != nil {
		predicates = append(predicates, userprogress.IsNextNEQ(*i.IsNextNEQ))
	}
	if i.Progress != nil {
		predicates = append(predicates, userprogress.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, userprogress.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, userprogress.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, userprogress.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressGT != nil {
		predicates = append(predicates, userprogress.ProgressGT(*i.ProgressGT))
	}
	if i.ProgressGTE != nil {
		predicates = append(predicates, userprogress.ProgressGTE(*i.ProgressGTE))
	}
	if i.ProgressLT != nil {
		predicates = append(predicates, userprogress.ProgressLT(*i.ProgressLT))
	}
	if i.ProgressLTE != nil {
		predicates = append(predicates, userprogress.ProgressLTE(*i.ProgressLTE))
	}
	if i.FinishedAt != nil {
		predicates = append(predicates, userprogress.FinishedAtEQ(*i.FinishedAt))
	}
	if i.FinishedAtNEQ != nil {
		predicates = append(predicates, userprogress.FinishedAtNEQ(*i.FinishedAtNEQ))
	}
	if len(i.FinishedAtIn) > 0 {
		predicates = append(predicates, userprogress.FinishedAtIn(i.FinishedAtIn...))
	}
	if len(i.FinishedAtNotIn) > 0 {
		predicates = append(predicates, userprogress.FinishedAtNotIn(i.FinishedAtNotIn...))
	}
	if i.FinishedAtGT != nil {
		predicates = append(predicates, userprogress.FinishedAtGT(*i.FinishedAtGT))
	}
	if i.FinishedAtGTE != nil {
		predicates = append(predicates, userprogress.FinishedAtGTE(*i.FinishedAtGTE))
	}
	if i.FinishedAtLT != nil {
		predicates = append(predicates, userprogress.FinishedAtLT(*i.FinishedAtLT))
	}
	if i.FinishedAtLTE != nil {
		predicates = append(predicates, userprogress.FinishedAtLTE(*i.FinishedAtLTE))
	}
	if i.FinishedAtIsNil {
		predicates = append(predicates, userprogress.FinishedAtIsNil())
	}
	if i.FinishedAtNotNil {
		predicates = append(predicates, userprogress.FinishedAtNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userprogress.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userprogress.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userprogress.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userprogress.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userprogress.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userprogress.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userprogress.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userprogress.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userprogress.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userprogress.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userprogress.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userprogress.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userprogress.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userprogress.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userprogress.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userprogress.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasUser != nil {
		p := userprogress.HasUser()
		if !*i.HasUser {
			p = userprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userprogress.HasUserWith(with...))
	}
	if i.HasCourse != nil {
		p := userprogress.HasCourse()
		if !*i.HasCourse {
			p = userprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseWith) > 0 {
		with := make([]predicate.Course, 0, len(i.HasCourseWith))
		for _, w := range i.HasCourseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCourseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userprogress.HasCourseWith(with...))
	}
	if i.HasUnit != nil {
		p := userprogress.HasUnit()
		if !*i.HasUnit {
			p = userprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUnitWith) > 0 {
		with := make([]predicate.Unit, 0, len(i.HasUnitWith))
		for _, w := range i.HasUnitWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUnitWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userprogress.HasUnitWith(with...))
	}
	if i.HasLesson != nil {
		p := userprogress.HasLesson()
		if !*i.HasLesson {
			p = userprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLessonWith) > 0 {
		with := make([]predicate.Lesson, 0, len(i.HasLessonWith))
		for _, w := range i.HasLessonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLessonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userprogress.HasLessonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserProgressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userprogress.And(predicates...), nil
	}
}
