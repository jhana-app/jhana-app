// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jhana-app/jhana-app/ent/authtoken"
	"github.com/jhana-app/jhana-app/ent/content"
	"github.com/jhana-app/jhana-app/ent/contentepisode"
	"github.com/jhana-app/jhana-app/ent/contentprogress"
	"github.com/jhana-app/jhana-app/ent/course"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/journalrecord"
	"github.com/jhana-app/jhana-app/ent/lesson"
	"github.com/jhana-app/jhana-app/ent/lessonaudio"
	"github.com/jhana-app/jhana-app/ent/lessontechnique"
	"github.com/jhana-app/jhana-app/ent/predicate"
	"github.com/jhana-app/jhana-app/ent/property"
	"github.com/jhana-app/jhana-app/ent/technique"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/ent/unittechnique"
	"github.com/jhana-app/jhana-app/ent/user"
	"github.com/jhana-app/jhana-app/ent/userprogress"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthToken       = "AuthToken"
	TypeContent         = "Content"
	TypeContentEpisode  = "ContentEpisode"
	TypeContentProgress = "ContentProgress"
	TypeCourse          = "Course"
	TypeJournalRecord   = "JournalRecord"
	TypeLesson          = "Lesson"
	TypeLessonAudio     = "LessonAudio"
	TypeLessonTechnique = "LessonTechnique"
	TypeTechnique       = "Technique"
	TypeUnit            = "Unit"
	TypeUnitTechnique   = "UnitTechnique"
	TypeUser            = "User"
	TypeUserProgress    = "UserProgress"
)

// AuthTokenMutation represents an operation that mutates the AuthToken nodes in the graph.
type AuthTokenMutation struct {
	config
	op            Op
	typ           string
	id            *gqlid.AuthTokenID
	jwt_id        *string
	issued_at     *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *gqlid.UserID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AuthToken, error)
	predicates    []predicate.AuthToken
}

var _ ent.Mutation = (*AuthTokenMutation)(nil)

// authtokenOption allows management of the mutation configuration using functional options.
type authtokenOption func(*AuthTokenMutation)

// newAuthTokenMutation creates new mutation for the AuthToken entity.
func newAuthTokenMutation(c config, op Op, opts ...authtokenOption) *AuthTokenMutation {
	m := &AuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokenID sets the ID field of the mutation.
func withAuthTokenID(id gqlid.AuthTokenID) authtokenOption {
	return func(m *AuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthToken
		)
		m.oldValue = func(ctx context.Context) (*AuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthToken sets the old AuthToken of the mutation.
func withAuthToken(node *AuthToken) authtokenOption {
	return func(m *AuthTokenMutation) {
		m.oldValue = func(context.Context) (*AuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthToken entities.
func (m *AuthTokenMutation) SetID(id gqlid.AuthTokenID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokenMutation) ID() (id gqlid.AuthTokenID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokenMutation) IDs(ctx context.Context) ([]gqlid.AuthTokenID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.AuthTokenID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJwtID sets the "jwt_id" field.
func (m *AuthTokenMutation) SetJwtID(s string) {
	m.jwt_id = &s
}

// JwtID returns the value of the "jwt_id" field in the mutation.
func (m *AuthTokenMutation) JwtID() (r string, exists bool) {
	v := m.jwt_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJwtID returns the old "jwt_id" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldJwtID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJwtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJwtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJwtID: %w", err)
	}
	return oldValue.JwtID, nil
}

// ResetJwtID resets all changes to the "jwt_id" field.
func (m *AuthTokenMutation) ResetJwtID() {
	m.jwt_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AuthTokenMutation) SetUserID(gi gqlid.UserID) {
	m.user = &gi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthTokenMutation) UserID() (r gqlid.UserID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldUserID(ctx context.Context) (v gqlid.UserID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthTokenMutation) ResetUserID() {
	m.user = nil
}

// SetIssuedAt sets the "issued_at" field.
func (m *AuthTokenMutation) SetIssuedAt(t time.Time) {
	m.issued_at = &t
}

// IssuedAt returns the value of the "issued_at" field in the mutation.
func (m *AuthTokenMutation) IssuedAt() (r time.Time, exists bool) {
	v := m.issued_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedAt returns the old "issued_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldIssuedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedAt: %w", err)
	}
	return oldValue.IssuedAt, nil
}

// ResetIssuedAt resets all changes to the "issued_at" field.
func (m *AuthTokenMutation) ResetIssuedAt() {
	m.issued_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuthTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[authtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuthTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuthTokenMutation) UserIDs() (ids []gqlid.UserID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuthTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuthTokenMutation builder.
func (m *AuthTokenMutation) Where(ps ...predicate.AuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthToken).
func (m *AuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.jwt_id != nil {
		fields = append(fields, authtoken.FieldJwtID)
	}
	if m.user != nil {
		fields = append(fields, authtoken.FieldUserID)
	}
	if m.issued_at != nil {
		fields = append(fields, authtoken.FieldIssuedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, authtoken.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtoken.FieldJwtID:
		return m.JwtID()
	case authtoken.FieldUserID:
		return m.UserID()
	case authtoken.FieldIssuedAt:
		return m.IssuedAt()
	case authtoken.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtoken.FieldJwtID:
		return m.OldJwtID(ctx)
	case authtoken.FieldUserID:
		return m.OldUserID(ctx)
	case authtoken.FieldIssuedAt:
		return m.OldIssuedAt(ctx)
	case authtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtoken.FieldJwtID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJwtID(v)
		return nil
	case authtoken.FieldUserID:
		v, ok := value.(gqlid.UserID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case authtoken.FieldIssuedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedAt(v)
		return nil
	case authtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokenMutation) ResetField(name string) error {
	switch name {
	case authtoken.FieldJwtID:
		m.ResetJwtID()
		return nil
	case authtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case authtoken.FieldIssuedAt:
		m.ResetIssuedAt()
		return nil
	case authtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, authtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, authtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case authtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case authtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case authtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AuthToken edge %s", name)
}

// ContentMutation represents an operation that mutates the Content nodes in the graph.
type ContentMutation struct {
	config
	op               Op
	typ              string
	id               *gqlid.ContentID
	_type            *property.ContentType
	iconImage        *string
	coverImage       *string
	title            *string
	subtitle         *string
	description      *string
	source           *string
	sourceURL        *string
	licence          *string
	licenceURL       *string
	isHidden         *bool
	_order           *int
	add_order        *int
	episodesCount    *int
	addepisodesCount *int
	clearedFields    map[string]struct{}
	episodes         map[gqlid.ContentEpisodeID]struct{}
	removedepisodes  map[gqlid.ContentEpisodeID]struct{}
	clearedepisodes  bool
	done             bool
	oldValue         func(context.Context) (*Content, error)
	predicates       []predicate.Content
}

var _ ent.Mutation = (*ContentMutation)(nil)

// contentOption allows management of the mutation configuration using functional options.
type contentOption func(*ContentMutation)

// newContentMutation creates new mutation for the Content entity.
func newContentMutation(c config, op Op, opts ...contentOption) *ContentMutation {
	m := &ContentMutation{
		config:        c,
		op:            op,
		typ:           TypeContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentID sets the ID field of the mutation.
func withContentID(id gqlid.ContentID) contentOption {
	return func(m *ContentMutation) {
		var (
			err   error
			once  sync.Once
			value *Content
		)
		m.oldValue = func(ctx context.Context) (*Content, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Content.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContent sets the old Content of the mutation.
func withContent(node *Content) contentOption {
	return func(m *ContentMutation) {
		m.oldValue = func(context.Context) (*Content, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Content entities.
func (m *ContentMutation) SetID(id gqlid.ContentID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentMutation) ID() (id gqlid.ContentID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContentMutation) IDs(ctx context.Context) ([]gqlid.ContentID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.ContentID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Content.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ContentMutation) SetType(pt property.ContentType) {
	m._type = &pt
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContentMutation) GetType() (r property.ContentType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldType(ctx context.Context) (v property.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContentMutation) ResetType() {
	m._type = nil
}

// SetIconImage sets the "iconImage" field.
func (m *ContentMutation) SetIconImage(s string) {
	m.iconImage = &s
}

// IconImage returns the value of the "iconImage" field in the mutation.
func (m *ContentMutation) IconImage() (r string, exists bool) {
	v := m.iconImage
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImage returns the old "iconImage" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldIconImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImage: %w", err)
	}
	return oldValue.IconImage, nil
}

// ResetIconImage resets all changes to the "iconImage" field.
func (m *ContentMutation) ResetIconImage() {
	m.iconImage = nil
}

// SetCoverImage sets the "coverImage" field.
func (m *ContentMutation) SetCoverImage(s string) {
	m.coverImage = &s
}

// CoverImage returns the value of the "coverImage" field in the mutation.
func (m *ContentMutation) CoverImage() (r string, exists bool) {
	v := m.coverImage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "coverImage" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ResetCoverImage resets all changes to the "coverImage" field.
func (m *ContentMutation) ResetCoverImage() {
	m.coverImage = nil
}

// SetTitle sets the "title" field.
func (m *ContentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ContentMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *ContentMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *ContentMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *ContentMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetDescription sets the "description" field.
func (m *ContentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ContentMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *ContentMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ContentMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ContentMutation) ResetSource() {
	m.source = nil
}

// SetSourceURL sets the "sourceURL" field.
func (m *ContentMutation) SetSourceURL(s string) {
	m.sourceURL = &s
}

// SourceURL returns the value of the "sourceURL" field in the mutation.
func (m *ContentMutation) SourceURL() (r string, exists bool) {
	v := m.sourceURL
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "sourceURL" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ResetSourceURL resets all changes to the "sourceURL" field.
func (m *ContentMutation) ResetSourceURL() {
	m.sourceURL = nil
}

// SetLicence sets the "licence" field.
func (m *ContentMutation) SetLicence(s string) {
	m.licence = &s
}

// Licence returns the value of the "licence" field in the mutation.
func (m *ContentMutation) Licence() (r string, exists bool) {
	v := m.licence
	if v == nil {
		return
	}
	return *v, true
}

// OldLicence returns the old "licence" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldLicence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicence: %w", err)
	}
	return oldValue.Licence, nil
}

// ResetLicence resets all changes to the "licence" field.
func (m *ContentMutation) ResetLicence() {
	m.licence = nil
}

// SetLicenceURL sets the "licenceURL" field.
func (m *ContentMutation) SetLicenceURL(s string) {
	m.licenceURL = &s
}

// LicenceURL returns the value of the "licenceURL" field in the mutation.
func (m *ContentMutation) LicenceURL() (r string, exists bool) {
	v := m.licenceURL
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenceURL returns the old "licenceURL" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldLicenceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenceURL: %w", err)
	}
	return oldValue.LicenceURL, nil
}

// ResetLicenceURL resets all changes to the "licenceURL" field.
func (m *ContentMutation) ResetLicenceURL() {
	m.licenceURL = nil
}

// SetIsHidden sets the "isHidden" field.
func (m *ContentMutation) SetIsHidden(b bool) {
	m.isHidden = &b
}

// IsHidden returns the value of the "isHidden" field in the mutation.
func (m *ContentMutation) IsHidden() (r bool, exists bool) {
	v := m.isHidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "isHidden" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "isHidden" field.
func (m *ContentMutation) ResetIsHidden() {
	m.isHidden = nil
}

// SetOrder sets the "order" field.
func (m *ContentMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ContentMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ContentMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ContentMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ContentMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetEpisodesCount sets the "episodesCount" field.
func (m *ContentMutation) SetEpisodesCount(i int) {
	m.episodesCount = &i
	m.addepisodesCount = nil
}

// EpisodesCount returns the value of the "episodesCount" field in the mutation.
func (m *ContentMutation) EpisodesCount() (r int, exists bool) {
	v := m.episodesCount
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodesCount returns the old "episodesCount" field's value of the Content entity.
// If the Content object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentMutation) OldEpisodesCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodesCount: %w", err)
	}
	return oldValue.EpisodesCount, nil
}

// AddEpisodesCount adds i to the "episodesCount" field.
func (m *ContentMutation) AddEpisodesCount(i int) {
	if m.addepisodesCount != nil {
		*m.addepisodesCount += i
	} else {
		m.addepisodesCount = &i
	}
}

// AddedEpisodesCount returns the value that was added to the "episodesCount" field in this mutation.
func (m *ContentMutation) AddedEpisodesCount() (r int, exists bool) {
	v := m.addepisodesCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodesCount resets all changes to the "episodesCount" field.
func (m *ContentMutation) ResetEpisodesCount() {
	m.episodesCount = nil
	m.addepisodesCount = nil
}

// AddEpisodeIDs adds the "episodes" edge to the ContentEpisode entity by ids.
func (m *ContentMutation) AddEpisodeIDs(ids ...gqlid.ContentEpisodeID) {
	if m.episodes == nil {
		m.episodes = make(map[gqlid.ContentEpisodeID]struct{})
	}
	for i := range ids {
		m.episodes[ids[i]] = struct{}{}
	}
}

// ClearEpisodes clears the "episodes" edge to the ContentEpisode entity.
func (m *ContentMutation) ClearEpisodes() {
	m.clearedepisodes = true
}

// EpisodesCleared reports if the "episodes" edge to the ContentEpisode entity was cleared.
func (m *ContentMutation) EpisodesCleared() bool {
	return m.clearedepisodes
}

// RemoveEpisodeIDs removes the "episodes" edge to the ContentEpisode entity by IDs.
func (m *ContentMutation) RemoveEpisodeIDs(ids ...gqlid.ContentEpisodeID) {
	if m.removedepisodes == nil {
		m.removedepisodes = make(map[gqlid.ContentEpisodeID]struct{})
	}
	for i := range ids {
		delete(m.episodes, ids[i])
		m.removedepisodes[ids[i]] = struct{}{}
	}
}

// RemovedEpisodes returns the removed IDs of the "episodes" edge to the ContentEpisode entity.
func (m *ContentMutation) RemovedEpisodesIDs() (ids []gqlid.ContentEpisodeID) {
	for id := range m.removedepisodes {
		ids = append(ids, id)
	}
	return
}

// EpisodesIDs returns the "episodes" edge IDs in the mutation.
func (m *ContentMutation) EpisodesIDs() (ids []gqlid.ContentEpisodeID) {
	for id := range m.episodes {
		ids = append(ids, id)
	}
	return
}

// ResetEpisodes resets all changes to the "episodes" edge.
func (m *ContentMutation) ResetEpisodes() {
	m.episodes = nil
	m.clearedepisodes = false
	m.removedepisodes = nil
}

// Where appends a list predicates to the ContentMutation builder.
func (m *ContentMutation) Where(ps ...predicate.Content) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Content, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Content).
func (m *ContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._type != nil {
		fields = append(fields, content.FieldType)
	}
	if m.iconImage != nil {
		fields = append(fields, content.FieldIconImage)
	}
	if m.coverImage != nil {
		fields = append(fields, content.FieldCoverImage)
	}
	if m.title != nil {
		fields = append(fields, content.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, content.FieldSubtitle)
	}
	if m.description != nil {
		fields = append(fields, content.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, content.FieldSource)
	}
	if m.sourceURL != nil {
		fields = append(fields, content.FieldSourceURL)
	}
	if m.licence != nil {
		fields = append(fields, content.FieldLicence)
	}
	if m.licenceURL != nil {
		fields = append(fields, content.FieldLicenceURL)
	}
	if m.isHidden != nil {
		fields = append(fields, content.FieldIsHidden)
	}
	if m._order != nil {
		fields = append(fields, content.FieldOrder)
	}
	if m.episodesCount != nil {
		fields = append(fields, content.FieldEpisodesCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case content.FieldType:
		return m.GetType()
	case content.FieldIconImage:
		return m.IconImage()
	case content.FieldCoverImage:
		return m.CoverImage()
	case content.FieldTitle:
		return m.Title()
	case content.FieldSubtitle:
		return m.Subtitle()
	case content.FieldDescription:
		return m.Description()
	case content.FieldSource:
		return m.Source()
	case content.FieldSourceURL:
		return m.SourceURL()
	case content.FieldLicence:
		return m.Licence()
	case content.FieldLicenceURL:
		return m.LicenceURL()
	case content.FieldIsHidden:
		return m.IsHidden()
	case content.FieldOrder:
		return m.Order()
	case content.FieldEpisodesCount:
		return m.EpisodesCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case content.FieldType:
		return m.OldType(ctx)
	case content.FieldIconImage:
		return m.OldIconImage(ctx)
	case content.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case content.FieldTitle:
		return m.OldTitle(ctx)
	case content.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case content.FieldDescription:
		return m.OldDescription(ctx)
	case content.FieldSource:
		return m.OldSource(ctx)
	case content.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case content.FieldLicence:
		return m.OldLicence(ctx)
	case content.FieldLicenceURL:
		return m.OldLicenceURL(ctx)
	case content.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case content.FieldOrder:
		return m.OldOrder(ctx)
	case content.FieldEpisodesCount:
		return m.OldEpisodesCount(ctx)
	}
	return nil, fmt.Errorf("unknown Content field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case content.FieldType:
		v, ok := value.(property.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case content.FieldIconImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImage(v)
		return nil
	case content.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case content.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case content.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case content.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case content.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case content.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case content.FieldLicence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicence(v)
		return nil
	case content.FieldLicenceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenceURL(v)
		return nil
	case content.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case content.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case content.FieldEpisodesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Content field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, content.FieldOrder)
	}
	if m.addepisodesCount != nil {
		fields = append(fields, content.FieldEpisodesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case content.FieldOrder:
		return m.AddedOrder()
	case content.FieldEpisodesCount:
		return m.AddedEpisodesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case content.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case content.FieldEpisodesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Content numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Content nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentMutation) ResetField(name string) error {
	switch name {
	case content.FieldType:
		m.ResetType()
		return nil
	case content.FieldIconImage:
		m.ResetIconImage()
		return nil
	case content.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case content.FieldTitle:
		m.ResetTitle()
		return nil
	case content.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case content.FieldDescription:
		m.ResetDescription()
		return nil
	case content.FieldSource:
		m.ResetSource()
		return nil
	case content.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case content.FieldLicence:
		m.ResetLicence()
		return nil
	case content.FieldLicenceURL:
		m.ResetLicenceURL()
		return nil
	case content.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case content.FieldOrder:
		m.ResetOrder()
		return nil
	case content.FieldEpisodesCount:
		m.ResetEpisodesCount()
		return nil
	}
	return fmt.Errorf("unknown Content field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.episodes != nil {
		edges = append(edges, content.EdgeEpisodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case content.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.episodes))
		for id := range m.episodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedepisodes != nil {
		edges = append(edges, content.EdgeEpisodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case content.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.removedepisodes))
		for id := range m.removedepisodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedepisodes {
		edges = append(edges, content.EdgeEpisodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentMutation) EdgeCleared(name string) bool {
	switch name {
	case content.EdgeEpisodes:
		return m.clearedepisodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Content unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentMutation) ResetEdge(name string) error {
	switch name {
	case content.EdgeEpisodes:
		m.ResetEpisodes()
		return nil
	}
	return fmt.Errorf("unknown Content edge %s", name)
}

// ContentEpisodeMutation represents an operation that mutates the ContentEpisode nodes in the graph.
type ContentEpisodeMutation struct {
	config
	op             Op
	typ            string
	id             *gqlid.ContentEpisodeID
	_type          *property.ContentType
	title          *string
	subtitle       *string
	description    *string
	duration       *int
	addduration    *int
	streamURL      *string
	downloadURL    *string
	source         *string
	sourceURL      *string
	licence        *string
	licenceURL     *string
	isHidden       *bool
	_order         *int
	add_order      *int
	clearedFields  map[string]struct{}
	content        *gqlid.ContentID
	clearedcontent bool
	done           bool
	oldValue       func(context.Context) (*ContentEpisode, error)
	predicates     []predicate.ContentEpisode
}

var _ ent.Mutation = (*ContentEpisodeMutation)(nil)

// contentepisodeOption allows management of the mutation configuration using functional options.
type contentepisodeOption func(*ContentEpisodeMutation)

// newContentEpisodeMutation creates new mutation for the ContentEpisode entity.
func newContentEpisodeMutation(c config, op Op, opts ...contentepisodeOption) *ContentEpisodeMutation {
	m := &ContentEpisodeMutation{
		config:        c,
		op:            op,
		typ:           TypeContentEpisode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentEpisodeID sets the ID field of the mutation.
func withContentEpisodeID(id gqlid.ContentEpisodeID) contentepisodeOption {
	return func(m *ContentEpisodeMutation) {
		var (
			err   error
			once  sync.Once
			value *ContentEpisode
		)
		m.oldValue = func(ctx context.Context) (*ContentEpisode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContentEpisode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContentEpisode sets the old ContentEpisode of the mutation.
func withContentEpisode(node *ContentEpisode) contentepisodeOption {
	return func(m *ContentEpisodeMutation) {
		m.oldValue = func(context.Context) (*ContentEpisode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentEpisodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentEpisodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContentEpisode entities.
func (m *ContentEpisodeMutation) SetID(id gqlid.ContentEpisodeID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentEpisodeMutation) ID() (id gqlid.ContentEpisodeID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContentEpisodeMutation) IDs(ctx context.Context) ([]gqlid.ContentEpisodeID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.ContentEpisodeID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContentEpisode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContentID sets the "content_id" field.
func (m *ContentEpisodeMutation) SetContentID(gi gqlid.ContentID) {
	m.content = &gi
}

// ContentID returns the value of the "content_id" field in the mutation.
func (m *ContentEpisodeMutation) ContentID() (r gqlid.ContentID, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContentID returns the old "content_id" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldContentID(ctx context.Context) (v gqlid.ContentID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentID: %w", err)
	}
	return oldValue.ContentID, nil
}

// ResetContentID resets all changes to the "content_id" field.
func (m *ContentEpisodeMutation) ResetContentID() {
	m.content = nil
}

// SetType sets the "type" field.
func (m *ContentEpisodeMutation) SetType(pt property.ContentType) {
	m._type = &pt
}

// GetType returns the value of the "type" field in the mutation.
func (m *ContentEpisodeMutation) GetType() (r property.ContentType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldType(ctx context.Context) (v property.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ContentEpisodeMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *ContentEpisodeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContentEpisodeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ContentEpisodeMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *ContentEpisodeMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *ContentEpisodeMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *ContentEpisodeMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetDescription sets the "description" field.
func (m *ContentEpisodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContentEpisodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ContentEpisodeMutation) ResetDescription() {
	m.description = nil
}

// SetDuration sets the "duration" field.
func (m *ContentEpisodeMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ContentEpisodeMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ContentEpisodeMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ContentEpisodeMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ContentEpisodeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetStreamURL sets the "streamURL" field.
func (m *ContentEpisodeMutation) SetStreamURL(s string) {
	m.streamURL = &s
}

// StreamURL returns the value of the "streamURL" field in the mutation.
func (m *ContentEpisodeMutation) StreamURL() (r string, exists bool) {
	v := m.streamURL
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamURL returns the old "streamURL" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldStreamURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamURL: %w", err)
	}
	return oldValue.StreamURL, nil
}

// ResetStreamURL resets all changes to the "streamURL" field.
func (m *ContentEpisodeMutation) ResetStreamURL() {
	m.streamURL = nil
}

// SetDownloadURL sets the "downloadURL" field.
func (m *ContentEpisodeMutation) SetDownloadURL(s string) {
	m.downloadURL = &s
}

// DownloadURL returns the value of the "downloadURL" field in the mutation.
func (m *ContentEpisodeMutation) DownloadURL() (r string, exists bool) {
	v := m.downloadURL
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "downloadURL" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ResetDownloadURL resets all changes to the "downloadURL" field.
func (m *ContentEpisodeMutation) ResetDownloadURL() {
	m.downloadURL = nil
}

// SetSource sets the "source" field.
func (m *ContentEpisodeMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ContentEpisodeMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ContentEpisodeMutation) ResetSource() {
	m.source = nil
}

// SetSourceURL sets the "sourceURL" field.
func (m *ContentEpisodeMutation) SetSourceURL(s string) {
	m.sourceURL = &s
}

// SourceURL returns the value of the "sourceURL" field in the mutation.
func (m *ContentEpisodeMutation) SourceURL() (r string, exists bool) {
	v := m.sourceURL
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "sourceURL" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ResetSourceURL resets all changes to the "sourceURL" field.
func (m *ContentEpisodeMutation) ResetSourceURL() {
	m.sourceURL = nil
}

// SetLicence sets the "licence" field.
func (m *ContentEpisodeMutation) SetLicence(s string) {
	m.licence = &s
}

// Licence returns the value of the "licence" field in the mutation.
func (m *ContentEpisodeMutation) Licence() (r string, exists bool) {
	v := m.licence
	if v == nil {
		return
	}
	return *v, true
}

// OldLicence returns the old "licence" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldLicence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicence: %w", err)
	}
	return oldValue.Licence, nil
}

// ResetLicence resets all changes to the "licence" field.
func (m *ContentEpisodeMutation) ResetLicence() {
	m.licence = nil
}

// SetLicenceURL sets the "licenceURL" field.
func (m *ContentEpisodeMutation) SetLicenceURL(s string) {
	m.licenceURL = &s
}

// LicenceURL returns the value of the "licenceURL" field in the mutation.
func (m *ContentEpisodeMutation) LicenceURL() (r string, exists bool) {
	v := m.licenceURL
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenceURL returns the old "licenceURL" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldLicenceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenceURL: %w", err)
	}
	return oldValue.LicenceURL, nil
}

// ResetLicenceURL resets all changes to the "licenceURL" field.
func (m *ContentEpisodeMutation) ResetLicenceURL() {
	m.licenceURL = nil
}

// SetIsHidden sets the "isHidden" field.
func (m *ContentEpisodeMutation) SetIsHidden(b bool) {
	m.isHidden = &b
}

// IsHidden returns the value of the "isHidden" field in the mutation.
func (m *ContentEpisodeMutation) IsHidden() (r bool, exists bool) {
	v := m.isHidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "isHidden" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldIsHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ResetIsHidden resets all changes to the "isHidden" field.
func (m *ContentEpisodeMutation) ResetIsHidden() {
	m.isHidden = nil
}

// SetOrder sets the "order" field.
func (m *ContentEpisodeMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ContentEpisodeMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ContentEpisode entity.
// If the ContentEpisode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentEpisodeMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ContentEpisodeMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ContentEpisodeMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ContentEpisodeMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearContent clears the "content" edge to the Content entity.
func (m *ContentEpisodeMutation) ClearContent() {
	m.clearedcontent = true
	m.clearedFields[contentepisode.FieldContentID] = struct{}{}
}

// ContentCleared reports if the "content" edge to the Content entity was cleared.
func (m *ContentEpisodeMutation) ContentCleared() bool {
	return m.clearedcontent
}

// ContentIDs returns the "content" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentID instead. It exists only for internal usage by the builders.
func (m *ContentEpisodeMutation) ContentIDs() (ids []gqlid.ContentID) {
	if id := m.content; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *ContentEpisodeMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
}

// Where appends a list predicates to the ContentEpisodeMutation builder.
func (m *ContentEpisodeMutation) Where(ps ...predicate.ContentEpisode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContentEpisodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContentEpisodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContentEpisode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContentEpisodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContentEpisodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContentEpisode).
func (m *ContentEpisodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentEpisodeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.content != nil {
		fields = append(fields, contentepisode.FieldContentID)
	}
	if m._type != nil {
		fields = append(fields, contentepisode.FieldType)
	}
	if m.title != nil {
		fields = append(fields, contentepisode.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, contentepisode.FieldSubtitle)
	}
	if m.description != nil {
		fields = append(fields, contentepisode.FieldDescription)
	}
	if m.duration != nil {
		fields = append(fields, contentepisode.FieldDuration)
	}
	if m.streamURL != nil {
		fields = append(fields, contentepisode.FieldStreamURL)
	}
	if m.downloadURL != nil {
		fields = append(fields, contentepisode.FieldDownloadURL)
	}
	if m.source != nil {
		fields = append(fields, contentepisode.FieldSource)
	}
	if m.sourceURL != nil {
		fields = append(fields, contentepisode.FieldSourceURL)
	}
	if m.licence != nil {
		fields = append(fields, contentepisode.FieldLicence)
	}
	if m.licenceURL != nil {
		fields = append(fields, contentepisode.FieldLicenceURL)
	}
	if m.isHidden != nil {
		fields = append(fields, contentepisode.FieldIsHidden)
	}
	if m._order != nil {
		fields = append(fields, contentepisode.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentEpisodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contentepisode.FieldContentID:
		return m.ContentID()
	case contentepisode.FieldType:
		return m.GetType()
	case contentepisode.FieldTitle:
		return m.Title()
	case contentepisode.FieldSubtitle:
		return m.Subtitle()
	case contentepisode.FieldDescription:
		return m.Description()
	case contentepisode.FieldDuration:
		return m.Duration()
	case contentepisode.FieldStreamURL:
		return m.StreamURL()
	case contentepisode.FieldDownloadURL:
		return m.DownloadURL()
	case contentepisode.FieldSource:
		return m.Source()
	case contentepisode.FieldSourceURL:
		return m.SourceURL()
	case contentepisode.FieldLicence:
		return m.Licence()
	case contentepisode.FieldLicenceURL:
		return m.LicenceURL()
	case contentepisode.FieldIsHidden:
		return m.IsHidden()
	case contentepisode.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentEpisodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contentepisode.FieldContentID:
		return m.OldContentID(ctx)
	case contentepisode.FieldType:
		return m.OldType(ctx)
	case contentepisode.FieldTitle:
		return m.OldTitle(ctx)
	case contentepisode.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case contentepisode.FieldDescription:
		return m.OldDescription(ctx)
	case contentepisode.FieldDuration:
		return m.OldDuration(ctx)
	case contentepisode.FieldStreamURL:
		return m.OldStreamURL(ctx)
	case contentepisode.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case contentepisode.FieldSource:
		return m.OldSource(ctx)
	case contentepisode.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case contentepisode.FieldLicence:
		return m.OldLicence(ctx)
	case contentepisode.FieldLicenceURL:
		return m.OldLicenceURL(ctx)
	case contentepisode.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case contentepisode.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown ContentEpisode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentEpisodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contentepisode.FieldContentID:
		v, ok := value.(gqlid.ContentID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentID(v)
		return nil
	case contentepisode.FieldType:
		v, ok := value.(property.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case contentepisode.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contentepisode.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case contentepisode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case contentepisode.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case contentepisode.FieldStreamURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamURL(v)
		return nil
	case contentepisode.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case contentepisode.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case contentepisode.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case contentepisode.FieldLicence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicence(v)
		return nil
	case contentepisode.FieldLicenceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenceURL(v)
		return nil
	case contentepisode.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case contentepisode.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ContentEpisode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentEpisodeMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, contentepisode.FieldDuration)
	}
	if m.add_order != nil {
		fields = append(fields, contentepisode.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentEpisodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contentepisode.FieldDuration:
		return m.AddedDuration()
	case contentepisode.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentEpisodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contentepisode.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case contentepisode.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ContentEpisode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentEpisodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentEpisodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentEpisodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ContentEpisode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentEpisodeMutation) ResetField(name string) error {
	switch name {
	case contentepisode.FieldContentID:
		m.ResetContentID()
		return nil
	case contentepisode.FieldType:
		m.ResetType()
		return nil
	case contentepisode.FieldTitle:
		m.ResetTitle()
		return nil
	case contentepisode.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case contentepisode.FieldDescription:
		m.ResetDescription()
		return nil
	case contentepisode.FieldDuration:
		m.ResetDuration()
		return nil
	case contentepisode.FieldStreamURL:
		m.ResetStreamURL()
		return nil
	case contentepisode.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case contentepisode.FieldSource:
		m.ResetSource()
		return nil
	case contentepisode.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case contentepisode.FieldLicence:
		m.ResetLicence()
		return nil
	case contentepisode.FieldLicenceURL:
		m.ResetLicenceURL()
		return nil
	case contentepisode.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case contentepisode.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown ContentEpisode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentEpisodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content != nil {
		edges = append(edges, contentepisode.EdgeContent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentEpisodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contentepisode.EdgeContent:
		if id := m.content; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentEpisodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentEpisodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentEpisodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent {
		edges = append(edges, contentepisode.EdgeContent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentEpisodeMutation) EdgeCleared(name string) bool {
	switch name {
	case contentepisode.EdgeContent:
		return m.clearedcontent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentEpisodeMutation) ClearEdge(name string) error {
	switch name {
	case contentepisode.EdgeContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown ContentEpisode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentEpisodeMutation) ResetEdge(name string) error {
	switch name {
	case contentepisode.EdgeContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown ContentEpisode edge %s", name)
}

// ContentProgressMutation represents an operation that mutates the ContentProgress nodes in the graph.
type ContentProgressMutation struct {
	config
	op             Op
	typ            string
	id             *gqlid.ContentProgressID
	content_type   *property.ContentType
	progress       *int64
	addprogress    *int64
	finishedAt     *time.Time
	createdAt      *time.Time
	updatedAt      *time.Time
	clearedFields  map[string]struct{}
	user           *gqlid.UserID
	cleareduser    bool
	content        *gqlid.ContentID
	clearedcontent bool
	episode        *gqlid.ContentEpisodeID
	clearedepisode bool
	done           bool
	oldValue       func(context.Context) (*ContentProgress, error)
	predicates     []predicate.ContentProgress
}

var _ ent.Mutation = (*ContentProgressMutation)(nil)

// contentprogressOption allows management of the mutation configuration using functional options.
type contentprogressOption func(*ContentProgressMutation)

// newContentProgressMutation creates new mutation for the ContentProgress entity.
func newContentProgressMutation(c config, op Op, opts ...contentprogressOption) *ContentProgressMutation {
	m := &ContentProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeContentProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentProgressID sets the ID field of the mutation.
func withContentProgressID(id gqlid.ContentProgressID) contentprogressOption {
	return func(m *ContentProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *ContentProgress
		)
		m.oldValue = func(ctx context.Context) (*ContentProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContentProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContentProgress sets the old ContentProgress of the mutation.
func withContentProgress(node *ContentProgress) contentprogressOption {
	return func(m *ContentProgressMutation) {
		m.oldValue = func(context.Context) (*ContentProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContentProgress entities.
func (m *ContentProgressMutation) SetID(id gqlid.ContentProgressID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentProgressMutation) ID() (id gqlid.ContentProgressID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContentProgressMutation) IDs(ctx context.Context) ([]gqlid.ContentProgressID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.ContentProgressID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContentProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ContentProgressMutation) SetUserID(gi gqlid.UserID) {
	m.user = &gi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ContentProgressMutation) UserID() (r gqlid.UserID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldUserID(ctx context.Context) (v gqlid.UserID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ContentProgressMutation) ResetUserID() {
	m.user = nil
}

// SetContentID sets the "content_id" field.
func (m *ContentProgressMutation) SetContentID(gi gqlid.ContentID) {
	m.content = &gi
}

// ContentID returns the value of the "content_id" field in the mutation.
func (m *ContentProgressMutation) ContentID() (r gqlid.ContentID, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContentID returns the old "content_id" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldContentID(ctx context.Context) (v gqlid.ContentID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentID: %w", err)
	}
	return oldValue.ContentID, nil
}

// ResetContentID resets all changes to the "content_id" field.
func (m *ContentProgressMutation) ResetContentID() {
	m.content = nil
}

// SetEpisodeID sets the "episode_id" field.
func (m *ContentProgressMutation) SetEpisodeID(gei gqlid.ContentEpisodeID) {
	m.episode = &gei
}

// EpisodeID returns the value of the "episode_id" field in the mutation.
func (m *ContentProgressMutation) EpisodeID() (r gqlid.ContentEpisodeID, exists bool) {
	v := m.episode
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeID returns the old "episode_id" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldEpisodeID(ctx context.Context) (v gqlid.ContentEpisodeID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeID: %w", err)
	}
	return oldValue.EpisodeID, nil
}

// ResetEpisodeID resets all changes to the "episode_id" field.
func (m *ContentProgressMutation) ResetEpisodeID() {
	m.episode = nil
}

// SetContentType sets the "content_type" field.
func (m *ContentProgressMutation) SetContentType(pt property.ContentType) {
	m.content_type = &pt
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *ContentProgressMutation) ContentType() (r property.ContentType, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldContentType(ctx context.Context) (v property.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *ContentProgressMutation) ResetContentType() {
	m.content_type = nil
}

// SetProgress sets the "progress" field.
func (m *ContentProgressMutation) SetProgress(i int64) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *ContentProgressMutation) Progress() (r int64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldProgress(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *ContentProgressMutation) AddProgress(i int64) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *ContentProgressMutation) AddedProgress() (r int64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *ContentProgressMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetFinishedAt sets the "finishedAt" field.
func (m *ContentProgressMutation) SetFinishedAt(t time.Time) {
	m.finishedAt = &t
}

// FinishedAt returns the value of the "finishedAt" field in the mutation.
func (m *ContentProgressMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finishedAt" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finishedAt" field.
func (m *ContentProgressMutation) ClearFinishedAt() {
	m.finishedAt = nil
	m.clearedFields[contentprogress.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finishedAt" field was cleared in this mutation.
func (m *ContentProgressMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[contentprogress.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finishedAt" field.
func (m *ContentProgressMutation) ResetFinishedAt() {
	m.finishedAt = nil
	delete(m.clearedFields, contentprogress.FieldFinishedAt)
}

// SetCreatedAt sets the "createdAt" field.
func (m *ContentProgressMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ContentProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ContentProgressMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ContentProgressMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ContentProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the ContentProgress entity.
// If the ContentProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ContentProgressMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ContentProgressMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[contentprogress.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ContentProgressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ContentProgressMutation) UserIDs() (ids []gqlid.UserID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ContentProgressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearContent clears the "content" edge to the Content entity.
func (m *ContentProgressMutation) ClearContent() {
	m.clearedcontent = true
	m.clearedFields[contentprogress.FieldContentID] = struct{}{}
}

// ContentCleared reports if the "content" edge to the Content entity was cleared.
func (m *ContentProgressMutation) ContentCleared() bool {
	return m.clearedcontent
}

// ContentIDs returns the "content" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentID instead. It exists only for internal usage by the builders.
func (m *ContentProgressMutation) ContentIDs() (ids []gqlid.ContentID) {
	if id := m.content; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *ContentProgressMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
}

// ClearEpisode clears the "episode" edge to the ContentEpisode entity.
func (m *ContentProgressMutation) ClearEpisode() {
	m.clearedepisode = true
	m.clearedFields[contentprogress.FieldEpisodeID] = struct{}{}
}

// EpisodeCleared reports if the "episode" edge to the ContentEpisode entity was cleared.
func (m *ContentProgressMutation) EpisodeCleared() bool {
	return m.clearedepisode
}

// EpisodeIDs returns the "episode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EpisodeID instead. It exists only for internal usage by the builders.
func (m *ContentProgressMutation) EpisodeIDs() (ids []gqlid.ContentEpisodeID) {
	if id := m.episode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEpisode resets all changes to the "episode" edge.
func (m *ContentProgressMutation) ResetEpisode() {
	m.episode = nil
	m.clearedepisode = false
}

// Where appends a list predicates to the ContentProgressMutation builder.
func (m *ContentProgressMutation) Where(ps ...predicate.ContentProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContentProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContentProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContentProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContentProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContentProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContentProgress).
func (m *ContentProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentProgressMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user != nil {
		fields = append(fields, contentprogress.FieldUserID)
	}
	if m.content != nil {
		fields = append(fields, contentprogress.FieldContentID)
	}
	if m.episode != nil {
		fields = append(fields, contentprogress.FieldEpisodeID)
	}
	if m.content_type != nil {
		fields = append(fields, contentprogress.FieldContentType)
	}
	if m.progress != nil {
		fields = append(fields, contentprogress.FieldProgress)
	}
	if m.finishedAt != nil {
		fields = append(fields, contentprogress.FieldFinishedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, contentprogress.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, contentprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contentprogress.FieldUserID:
		return m.UserID()
	case contentprogress.FieldContentID:
		return m.ContentID()
	case contentprogress.FieldEpisodeID:
		return m.EpisodeID()
	case contentprogress.FieldContentType:
		return m.ContentType()
	case contentprogress.FieldProgress:
		return m.Progress()
	case contentprogress.FieldFinishedAt:
		return m.FinishedAt()
	case contentprogress.FieldCreatedAt:
		return m.CreatedAt()
	case contentprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contentprogress.FieldUserID:
		return m.OldUserID(ctx)
	case contentprogress.FieldContentID:
		return m.OldContentID(ctx)
	case contentprogress.FieldEpisodeID:
		return m.OldEpisodeID(ctx)
	case contentprogress.FieldContentType:
		return m.OldContentType(ctx)
	case contentprogress.FieldProgress:
		return m.OldProgress(ctx)
	case contentprogress.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case contentprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contentprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ContentProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contentprogress.FieldUserID:
		v, ok := value.(gqlid.UserID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case contentprogress.FieldContentID:
		v, ok := value.(gqlid.ContentID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentID(v)
		return nil
	case contentprogress.FieldEpisodeID:
		v, ok := value.(gqlid.ContentEpisodeID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeID(v)
		return nil
	case contentprogress.FieldContentType:
		v, ok := value.(property.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case contentprogress.FieldProgress:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case contentprogress.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case contentprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contentprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ContentProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentProgressMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, contentprogress.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contentprogress.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contentprogress.FieldProgress:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown ContentProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contentprogress.FieldFinishedAt) {
		fields = append(fields, contentprogress.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentProgressMutation) ClearField(name string) error {
	switch name {
	case contentprogress.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ContentProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentProgressMutation) ResetField(name string) error {
	switch name {
	case contentprogress.FieldUserID:
		m.ResetUserID()
		return nil
	case contentprogress.FieldContentID:
		m.ResetContentID()
		return nil
	case contentprogress.FieldEpisodeID:
		m.ResetEpisodeID()
		return nil
	case contentprogress.FieldContentType:
		m.ResetContentType()
		return nil
	case contentprogress.FieldProgress:
		m.ResetProgress()
		return nil
	case contentprogress.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case contentprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contentprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ContentProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, contentprogress.EdgeUser)
	}
	if m.content != nil {
		edges = append(edges, contentprogress.EdgeContent)
	}
	if m.episode != nil {
		edges = append(edges, contentprogress.EdgeEpisode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contentprogress.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case contentprogress.EdgeContent:
		if id := m.content; id != nil {
			return []ent.Value{*id}
		}
	case contentprogress.EdgeEpisode:
		if id := m.episode; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, contentprogress.EdgeUser)
	}
	if m.clearedcontent {
		edges = append(edges, contentprogress.EdgeContent)
	}
	if m.clearedepisode {
		edges = append(edges, contentprogress.EdgeEpisode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case contentprogress.EdgeUser:
		return m.cleareduser
	case contentprogress.EdgeContent:
		return m.clearedcontent
	case contentprogress.EdgeEpisode:
		return m.clearedepisode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentProgressMutation) ClearEdge(name string) error {
	switch name {
	case contentprogress.EdgeUser:
		m.ClearUser()
		return nil
	case contentprogress.EdgeContent:
		m.ClearContent()
		return nil
	case contentprogress.EdgeEpisode:
		m.ClearEpisode()
		return nil
	}
	return fmt.Errorf("unknown ContentProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentProgressMutation) ResetEdge(name string) error {
	switch name {
	case contentprogress.EdgeUser:
		m.ResetUser()
		return nil
	case contentprogress.EdgeContent:
		m.ResetContent()
		return nil
	case contentprogress.EdgeEpisode:
		m.ResetEpisode()
		return nil
	}
	return fmt.Errorf("unknown ContentProgress edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op            Op
	typ           string
	id            *gqlid.CourseID
	iconImage     *string
	coverImage    *string
	title         *string
	description   *string
	color         *string
	active        *bool
	_order        *int
	add_order     *int
	clearedFields map[string]struct{}
	units         map[gqlid.UnitID]struct{}
	removedunits  map[gqlid.UnitID]struct{}
	clearedunits  bool
	done          bool
	oldValue      func(context.Context) (*Course, error)
	predicates    []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id gqlid.CourseID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id gqlid.CourseID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id gqlid.CourseID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]gqlid.CourseID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.CourseID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIconImage sets the "iconImage" field.
func (m *CourseMutation) SetIconImage(s string) {
	m.iconImage = &s
}

// IconImage returns the value of the "iconImage" field in the mutation.
func (m *CourseMutation) IconImage() (r string, exists bool) {
	v := m.iconImage
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImage returns the old "iconImage" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIconImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImage: %w", err)
	}
	return oldValue.IconImage, nil
}

// ResetIconImage resets all changes to the "iconImage" field.
func (m *CourseMutation) ResetIconImage() {
	m.iconImage = nil
}

// SetCoverImage sets the "coverImage" field.
func (m *CourseMutation) SetCoverImage(s string) {
	m.coverImage = &s
}

// CoverImage returns the value of the "coverImage" field in the mutation.
func (m *CourseMutation) CoverImage() (r string, exists bool) {
	v := m.coverImage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "coverImage" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ResetCoverImage resets all changes to the "coverImage" field.
func (m *CourseMutation) ResetCoverImage() {
	m.coverImage = nil
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
}

// SetColor sets the "color" field.
func (m *CourseMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *CourseMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *CourseMutation) ResetColor() {
	m.color = nil
}

// SetActive sets the "active" field.
func (m *CourseMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *CourseMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *CourseMutation) ResetActive() {
	m.active = nil
}

// SetOrder sets the "order" field.
func (m *CourseMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CourseMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CourseMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CourseMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CourseMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// AddUnitIDs adds the "units" edge to the Unit entity by ids.
func (m *CourseMutation) AddUnitIDs(ids ...gqlid.UnitID) {
	if m.units == nil {
		m.units = make(map[gqlid.UnitID]struct{})
	}
	for i := range ids {
		m.units[ids[i]] = struct{}{}
	}
}

// ClearUnits clears the "units" edge to the Unit entity.
func (m *CourseMutation) ClearUnits() {
	m.clearedunits = true
}

// UnitsCleared reports if the "units" edge to the Unit entity was cleared.
func (m *CourseMutation) UnitsCleared() bool {
	return m.clearedunits
}

// RemoveUnitIDs removes the "units" edge to the Unit entity by IDs.
func (m *CourseMutation) RemoveUnitIDs(ids ...gqlid.UnitID) {
	if m.removedunits == nil {
		m.removedunits = make(map[gqlid.UnitID]struct{})
	}
	for i := range ids {
		delete(m.units, ids[i])
		m.removedunits[ids[i]] = struct{}{}
	}
}

// RemovedUnits returns the removed IDs of the "units" edge to the Unit entity.
func (m *CourseMutation) RemovedUnitsIDs() (ids []gqlid.UnitID) {
	for id := range m.removedunits {
		ids = append(ids, id)
	}
	return
}

// UnitsIDs returns the "units" edge IDs in the mutation.
func (m *CourseMutation) UnitsIDs() (ids []gqlid.UnitID) {
	for id := range m.units {
		ids = append(ids, id)
	}
	return
}

// ResetUnits resets all changes to the "units" edge.
func (m *CourseMutation) ResetUnits() {
	m.units = nil
	m.clearedunits = false
	m.removedunits = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.iconImage != nil {
		fields = append(fields, course.FieldIconImage)
	}
	if m.coverImage != nil {
		fields = append(fields, course.FieldCoverImage)
	}
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, course.FieldColor)
	}
	if m.active != nil {
		fields = append(fields, course.FieldActive)
	}
	if m._order != nil {
		fields = append(fields, course.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldIconImage:
		return m.IconImage()
	case course.FieldCoverImage:
		return m.CoverImage()
	case course.FieldTitle:
		return m.Title()
	case course.FieldDescription:
		return m.Description()
	case course.FieldColor:
		return m.Color()
	case course.FieldActive:
		return m.Active()
	case course.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldIconImage:
		return m.OldIconImage(ctx)
	case course.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldColor:
		return m.OldColor(ctx)
	case course.FieldActive:
		return m.OldActive(ctx)
	case course.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldIconImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImage(v)
		return nil
	case course.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case course.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case course.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, course.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldIconImage:
		m.ResetIconImage()
		return nil
	case course.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldColor:
		m.ResetColor()
		return nil
	case course.FieldActive:
		m.ResetActive()
		return nil
	case course.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.units != nil {
		edges = append(edges, course.EdgeUnits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeUnits:
		ids := make([]ent.Value, 0, len(m.units))
		for id := range m.units {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedunits != nil {
		edges = append(edges, course.EdgeUnits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeUnits:
		ids := make([]ent.Value, 0, len(m.removedunits))
		for id := range m.removedunits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedunits {
		edges = append(edges, course.EdgeUnits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeUnits:
		return m.clearedunits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeUnits:
		m.ResetUnits()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// JournalRecordMutation represents an operation that mutates the JournalRecord nodes in the graph.
type JournalRecordMutation struct {
	config
	op            Op
	typ           string
	id            *gqlid.JournalRecordID
	dateTime      *time.Time
	duration      *int
	addduration   *int
	note          *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	user          *gqlid.UserID
	cleareduser   bool
	lesson        *gqlid.LessonID
	clearedlesson bool
	done          bool
	oldValue      func(context.Context) (*JournalRecord, error)
	predicates    []predicate.JournalRecord
}

var _ ent.Mutation = (*JournalRecordMutation)(nil)

// journalrecordOption allows management of the mutation configuration using functional options.
type journalrecordOption func(*JournalRecordMutation)

// newJournalRecordMutation creates new mutation for the JournalRecord entity.
func newJournalRecordMutation(c config, op Op, opts ...journalrecordOption) *JournalRecordMutation {
	m := &JournalRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeJournalRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJournalRecordID sets the ID field of the mutation.
func withJournalRecordID(id gqlid.JournalRecordID) journalrecordOption {
	return func(m *JournalRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *JournalRecord
		)
		m.oldValue = func(ctx context.Context) (*JournalRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JournalRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJournalRecord sets the old JournalRecord of the mutation.
func withJournalRecord(node *JournalRecord) journalrecordOption {
	return func(m *JournalRecordMutation) {
		m.oldValue = func(context.Context) (*JournalRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JournalRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JournalRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JournalRecord entities.
func (m *JournalRecordMutation) SetID(id gqlid.JournalRecordID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JournalRecordMutation) ID() (id gqlid.JournalRecordID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JournalRecordMutation) IDs(ctx context.Context) ([]gqlid.JournalRecordID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.JournalRecordID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JournalRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *JournalRecordMutation) SetUserID(gi gqlid.UserID) {
	m.user = &gi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *JournalRecordMutation) UserID() (r gqlid.UserID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldUserID(ctx context.Context) (v gqlid.UserID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *JournalRecordMutation) ResetUserID() {
	m.user = nil
}

// SetLessonID sets the "lesson_id" field.
func (m *JournalRecordMutation) SetLessonID(gi gqlid.LessonID) {
	m.lesson = &gi
}

// LessonID returns the value of the "lesson_id" field in the mutation.
func (m *JournalRecordMutation) LessonID() (r gqlid.LessonID, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonID returns the old "lesson_id" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldLessonID(ctx context.Context) (v gqlid.LessonID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonID: %w", err)
	}
	return oldValue.LessonID, nil
}

// ClearLessonID clears the value of the "lesson_id" field.
func (m *JournalRecordMutation) ClearLessonID() {
	m.lesson = nil
	m.clearedFields[journalrecord.FieldLessonID] = struct{}{}
}

// LessonIDCleared returns if the "lesson_id" field was cleared in this mutation.
func (m *JournalRecordMutation) LessonIDCleared() bool {
	_, ok := m.clearedFields[journalrecord.FieldLessonID]
	return ok
}

// ResetLessonID resets all changes to the "lesson_id" field.
func (m *JournalRecordMutation) ResetLessonID() {
	m.lesson = nil
	delete(m.clearedFields, journalrecord.FieldLessonID)
}

// SetDateTime sets the "dateTime" field.
func (m *JournalRecordMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *JournalRecordMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *JournalRecordMutation) ResetDateTime() {
	m.dateTime = nil
}

// SetDuration sets the "duration" field.
func (m *JournalRecordMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *JournalRecordMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *JournalRecordMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *JournalRecordMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *JournalRecordMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetNote sets the "note" field.
func (m *JournalRecordMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *JournalRecordMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *JournalRecordMutation) ResetNote() {
	m.note = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *JournalRecordMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *JournalRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *JournalRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *JournalRecordMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *JournalRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the JournalRecord entity.
// If the JournalRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JournalRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *JournalRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *JournalRecordMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[journalrecord.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JournalRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JournalRecordMutation) UserIDs() (ids []gqlid.UserID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JournalRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearLesson clears the "lesson" edge to the Lesson entity.
func (m *JournalRecordMutation) ClearLesson() {
	m.clearedlesson = true
	m.clearedFields[journalrecord.FieldLessonID] = struct{}{}
}

// LessonCleared reports if the "lesson" edge to the Lesson entity was cleared.
func (m *JournalRecordMutation) LessonCleared() bool {
	return m.LessonIDCleared() || m.clearedlesson
}

// LessonIDs returns the "lesson" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonID instead. It exists only for internal usage by the builders.
func (m *JournalRecordMutation) LessonIDs() (ids []gqlid.LessonID) {
	if id := m.lesson; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLesson resets all changes to the "lesson" edge.
func (m *JournalRecordMutation) ResetLesson() {
	m.lesson = nil
	m.clearedlesson = false
}

// Where appends a list predicates to the JournalRecordMutation builder.
func (m *JournalRecordMutation) Where(ps ...predicate.JournalRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JournalRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JournalRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JournalRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JournalRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JournalRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JournalRecord).
func (m *JournalRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JournalRecordMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, journalrecord.FieldUserID)
	}
	if m.lesson != nil {
		fields = append(fields, journalrecord.FieldLessonID)
	}
	if m.dateTime != nil {
		fields = append(fields, journalrecord.FieldDateTime)
	}
	if m.duration != nil {
		fields = append(fields, journalrecord.FieldDuration)
	}
	if m.note != nil {
		fields = append(fields, journalrecord.FieldNote)
	}
	if m.createdAt != nil {
		fields = append(fields, journalrecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, journalrecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JournalRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case journalrecord.FieldUserID:
		return m.UserID()
	case journalrecord.FieldLessonID:
		return m.LessonID()
	case journalrecord.FieldDateTime:
		return m.DateTime()
	case journalrecord.FieldDuration:
		return m.Duration()
	case journalrecord.FieldNote:
		return m.Note()
	case journalrecord.FieldCreatedAt:
		return m.CreatedAt()
	case journalrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JournalRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case journalrecord.FieldUserID:
		return m.OldUserID(ctx)
	case journalrecord.FieldLessonID:
		return m.OldLessonID(ctx)
	case journalrecord.FieldDateTime:
		return m.OldDateTime(ctx)
	case journalrecord.FieldDuration:
		return m.OldDuration(ctx)
	case journalrecord.FieldNote:
		return m.OldNote(ctx)
	case journalrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case journalrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JournalRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case journalrecord.FieldUserID:
		v, ok := value.(gqlid.UserID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case journalrecord.FieldLessonID:
		v, ok := value.(gqlid.LessonID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonID(v)
		return nil
	case journalrecord.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case journalrecord.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case journalrecord.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case journalrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case journalrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JournalRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JournalRecordMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, journalrecord.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JournalRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case journalrecord.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JournalRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case journalrecord.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown JournalRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JournalRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(journalrecord.FieldLessonID) {
		fields = append(fields, journalrecord.FieldLessonID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JournalRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JournalRecordMutation) ClearField(name string) error {
	switch name {
	case journalrecord.FieldLessonID:
		m.ClearLessonID()
		return nil
	}
	return fmt.Errorf("unknown JournalRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JournalRecordMutation) ResetField(name string) error {
	switch name {
	case journalrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case journalrecord.FieldLessonID:
		m.ResetLessonID()
		return nil
	case journalrecord.FieldDateTime:
		m.ResetDateTime()
		return nil
	case journalrecord.FieldDuration:
		m.ResetDuration()
		return nil
	case journalrecord.FieldNote:
		m.ResetNote()
		return nil
	case journalrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case journalrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JournalRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JournalRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, journalrecord.EdgeUser)
	}
	if m.lesson != nil {
		edges = append(edges, journalrecord.EdgeLesson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JournalRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case journalrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case journalrecord.EdgeLesson:
		if id := m.lesson; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JournalRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JournalRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JournalRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, journalrecord.EdgeUser)
	}
	if m.clearedlesson {
		edges = append(edges, journalrecord.EdgeLesson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JournalRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case journalrecord.EdgeUser:
		return m.cleareduser
	case journalrecord.EdgeLesson:
		return m.clearedlesson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JournalRecordMutation) ClearEdge(name string) error {
	switch name {
	case journalrecord.EdgeUser:
		m.ClearUser()
		return nil
	case journalrecord.EdgeLesson:
		m.ClearLesson()
		return nil
	}
	return fmt.Errorf("unknown JournalRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JournalRecordMutation) ResetEdge(name string) error {
	switch name {
	case journalrecord.EdgeUser:
		m.ResetUser()
		return nil
	case journalrecord.EdgeLesson:
		m.ResetLesson()
		return nil
	}
	return fmt.Errorf("unknown JournalRecord edge %s", name)
}

// LessonMutation represents an operation that mutates the Lesson nodes in the graph.
type LessonMutation struct {
	config
	op                Op
	typ               string
	id                *gqlid.LessonID
	_type             *property.LessonType
	iconImage         *string
	coverImage        *string
	title             *string
	description       *string
	_order            *int
	add_order         *int
	clearedFields     map[string]struct{}
	unit              *gqlid.UnitID
	clearedunit       bool
	techniques        map[gqlid.TechniqueID]struct{}
	removedtechniques map[gqlid.TechniqueID]struct{}
	clearedtechniques bool
	audios            map[gqlid.LessonAudioID]struct{}
	removedaudios     map[gqlid.LessonAudioID]struct{}
	clearedaudios     bool
	done              bool
	oldValue          func(context.Context) (*Lesson, error)
	predicates        []predicate.Lesson
}

var _ ent.Mutation = (*LessonMutation)(nil)

// lessonOption allows management of the mutation configuration using functional options.
type lessonOption func(*LessonMutation)

// newLessonMutation creates new mutation for the Lesson entity.
func newLessonMutation(c config, op Op, opts ...lessonOption) *LessonMutation {
	m := &LessonMutation{
		config:        c,
		op:            op,
		typ:           TypeLesson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonID sets the ID field of the mutation.
func withLessonID(id gqlid.LessonID) lessonOption {
	return func(m *LessonMutation) {
		var (
			err   error
			once  sync.Once
			value *Lesson
		)
		m.oldValue = func(ctx context.Context) (*Lesson, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lesson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLesson sets the old Lesson of the mutation.
func withLesson(node *Lesson) lessonOption {
	return func(m *LessonMutation) {
		m.oldValue = func(context.Context) (*Lesson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lesson entities.
func (m *LessonMutation) SetID(id gqlid.LessonID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonMutation) ID() (id gqlid.LessonID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonMutation) IDs(ctx context.Context) ([]gqlid.LessonID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.LessonID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lesson.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUnitID sets the "unit_id" field.
func (m *LessonMutation) SetUnitID(gi gqlid.UnitID) {
	m.unit = &gi
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *LessonMutation) UnitID() (r gqlid.UnitID, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldUnitID(ctx context.Context) (v gqlid.UnitID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *LessonMutation) ResetUnitID() {
	m.unit = nil
}

// SetType sets the "type" field.
func (m *LessonMutation) SetType(pt property.LessonType) {
	m._type = &pt
}

// GetType returns the value of the "type" field in the mutation.
func (m *LessonMutation) GetType() (r property.LessonType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldType(ctx context.Context) (v property.LessonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LessonMutation) ResetType() {
	m._type = nil
}

// SetIconImage sets the "iconImage" field.
func (m *LessonMutation) SetIconImage(s string) {
	m.iconImage = &s
}

// IconImage returns the value of the "iconImage" field in the mutation.
func (m *LessonMutation) IconImage() (r string, exists bool) {
	v := m.iconImage
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImage returns the old "iconImage" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldIconImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImage: %w", err)
	}
	return oldValue.IconImage, nil
}

// ResetIconImage resets all changes to the "iconImage" field.
func (m *LessonMutation) ResetIconImage() {
	m.iconImage = nil
}

// SetCoverImage sets the "coverImage" field.
func (m *LessonMutation) SetCoverImage(s string) {
	m.coverImage = &s
}

// CoverImage returns the value of the "coverImage" field in the mutation.
func (m *LessonMutation) CoverImage() (r string, exists bool) {
	v := m.coverImage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "coverImage" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ResetCoverImage resets all changes to the "coverImage" field.
func (m *LessonMutation) ResetCoverImage() {
	m.coverImage = nil
}

// SetTitle sets the "title" field.
func (m *LessonMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LessonMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LessonMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LessonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LessonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *LessonMutation) ResetDescription() {
	m.description = nil
}

// SetOrder sets the "order" field.
func (m *LessonMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *LessonMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *LessonMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *LessonMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *LessonMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *LessonMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[lesson.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *LessonMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *LessonMutation) UnitIDs() (ids []gqlid.UnitID) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *LessonMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *LessonMutation) AddTechniqueIDs(ids ...gqlid.TechniqueID) {
	if m.techniques == nil {
		m.techniques = make(map[gqlid.TechniqueID]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *LessonMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *LessonMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *LessonMutation) RemoveTechniqueIDs(ids ...gqlid.TechniqueID) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[gqlid.TechniqueID]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *LessonMutation) RemovedTechniquesIDs() (ids []gqlid.TechniqueID) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *LessonMutation) TechniquesIDs() (ids []gqlid.TechniqueID) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *LessonMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// AddAudioIDs adds the "audios" edge to the LessonAudio entity by ids.
func (m *LessonMutation) AddAudioIDs(ids ...gqlid.LessonAudioID) {
	if m.audios == nil {
		m.audios = make(map[gqlid.LessonAudioID]struct{})
	}
	for i := range ids {
		m.audios[ids[i]] = struct{}{}
	}
}

// ClearAudios clears the "audios" edge to the LessonAudio entity.
func (m *LessonMutation) ClearAudios() {
	m.clearedaudios = true
}

// AudiosCleared reports if the "audios" edge to the LessonAudio entity was cleared.
func (m *LessonMutation) AudiosCleared() bool {
	return m.clearedaudios
}

// RemoveAudioIDs removes the "audios" edge to the LessonAudio entity by IDs.
func (m *LessonMutation) RemoveAudioIDs(ids ...gqlid.LessonAudioID) {
	if m.removedaudios == nil {
		m.removedaudios = make(map[gqlid.LessonAudioID]struct{})
	}
	for i := range ids {
		delete(m.audios, ids[i])
		m.removedaudios[ids[i]] = struct{}{}
	}
}

// RemovedAudios returns the removed IDs of the "audios" edge to the LessonAudio entity.
func (m *LessonMutation) RemovedAudiosIDs() (ids []gqlid.LessonAudioID) {
	for id := range m.removedaudios {
		ids = append(ids, id)
	}
	return
}

// AudiosIDs returns the "audios" edge IDs in the mutation.
func (m *LessonMutation) AudiosIDs() (ids []gqlid.LessonAudioID) {
	for id := range m.audios {
		ids = append(ids, id)
	}
	return
}

// ResetAudios resets all changes to the "audios" edge.
func (m *LessonMutation) ResetAudios() {
	m.audios = nil
	m.clearedaudios = false
	m.removedaudios = nil
}

// Where appends a list predicates to the LessonMutation builder.
func (m *LessonMutation) Where(ps ...predicate.Lesson) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lesson, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lesson).
func (m *LessonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.unit != nil {
		fields = append(fields, lesson.FieldUnitID)
	}
	if m._type != nil {
		fields = append(fields, lesson.FieldType)
	}
	if m.iconImage != nil {
		fields = append(fields, lesson.FieldIconImage)
	}
	if m.coverImage != nil {
		fields = append(fields, lesson.FieldCoverImage)
	}
	if m.title != nil {
		fields = append(fields, lesson.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, lesson.FieldDescription)
	}
	if m._order != nil {
		fields = append(fields, lesson.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldUnitID:
		return m.UnitID()
	case lesson.FieldType:
		return m.GetType()
	case lesson.FieldIconImage:
		return m.IconImage()
	case lesson.FieldCoverImage:
		return m.CoverImage()
	case lesson.FieldTitle:
		return m.Title()
	case lesson.FieldDescription:
		return m.Description()
	case lesson.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lesson.FieldUnitID:
		return m.OldUnitID(ctx)
	case lesson.FieldType:
		return m.OldType(ctx)
	case lesson.FieldIconImage:
		return m.OldIconImage(ctx)
	case lesson.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case lesson.FieldTitle:
		return m.OldTitle(ctx)
	case lesson.FieldDescription:
		return m.OldDescription(ctx)
	case lesson.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Lesson field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldUnitID:
		v, ok := value.(gqlid.UnitID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case lesson.FieldType:
		v, ok := value.(property.LessonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lesson.FieldIconImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImage(v)
		return nil
	case lesson.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case lesson.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case lesson.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lesson.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, lesson.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lesson nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonMutation) ResetField(name string) error {
	switch name {
	case lesson.FieldUnitID:
		m.ResetUnitID()
		return nil
	case lesson.FieldType:
		m.ResetType()
		return nil
	case lesson.FieldIconImage:
		m.ResetIconImage()
		return nil
	case lesson.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case lesson.FieldTitle:
		m.ResetTitle()
		return nil
	case lesson.FieldDescription:
		m.ResetDescription()
		return nil
	case lesson.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.unit != nil {
		edges = append(edges, lesson.EdgeUnit)
	}
	if m.techniques != nil {
		edges = append(edges, lesson.EdgeTechniques)
	}
	if m.audios != nil {
		edges = append(edges, lesson.EdgeAudios)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lesson.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case lesson.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	case lesson.EdgeAudios:
		ids := make([]ent.Value, 0, len(m.audios))
		for id := range m.audios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtechniques != nil {
		edges = append(edges, lesson.EdgeTechniques)
	}
	if m.removedaudios != nil {
		edges = append(edges, lesson.EdgeAudios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lesson.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	case lesson.EdgeAudios:
		ids := make([]ent.Value, 0, len(m.removedaudios))
		for id := range m.removedaudios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedunit {
		edges = append(edges, lesson.EdgeUnit)
	}
	if m.clearedtechniques {
		edges = append(edges, lesson.EdgeTechniques)
	}
	if m.clearedaudios {
		edges = append(edges, lesson.EdgeAudios)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonMutation) EdgeCleared(name string) bool {
	switch name {
	case lesson.EdgeUnit:
		return m.clearedunit
	case lesson.EdgeTechniques:
		return m.clearedtechniques
	case lesson.EdgeAudios:
		return m.clearedaudios
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonMutation) ClearEdge(name string) error {
	switch name {
	case lesson.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Lesson unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonMutation) ResetEdge(name string) error {
	switch name {
	case lesson.EdgeUnit:
		m.ResetUnit()
		return nil
	case lesson.EdgeTechniques:
		m.ResetTechniques()
		return nil
	case lesson.EdgeAudios:
		m.ResetAudios()
		return nil
	}
	return fmt.Errorf("unknown Lesson edge %s", name)
}

// LessonAudioMutation represents an operation that mutates the LessonAudio nodes in the graph.
type LessonAudioMutation struct {
	config
	op            Op
	typ           string
	id            *gqlid.LessonAudioID
	audioURL      *string
	duration      *int
	addduration   *int
	clearedFields map[string]struct{}
	lesson        *gqlid.LessonID
	clearedlesson bool
	done          bool
	oldValue      func(context.Context) (*LessonAudio, error)
	predicates    []predicate.LessonAudio
}

var _ ent.Mutation = (*LessonAudioMutation)(nil)

// lessonaudioOption allows management of the mutation configuration using functional options.
type lessonaudioOption func(*LessonAudioMutation)

// newLessonAudioMutation creates new mutation for the LessonAudio entity.
func newLessonAudioMutation(c config, op Op, opts ...lessonaudioOption) *LessonAudioMutation {
	m := &LessonAudioMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonAudio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonAudioID sets the ID field of the mutation.
func withLessonAudioID(id gqlid.LessonAudioID) lessonaudioOption {
	return func(m *LessonAudioMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonAudio
		)
		m.oldValue = func(ctx context.Context) (*LessonAudio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonAudio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonAudio sets the old LessonAudio of the mutation.
func withLessonAudio(node *LessonAudio) lessonaudioOption {
	return func(m *LessonAudioMutation) {
		m.oldValue = func(context.Context) (*LessonAudio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonAudioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonAudioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LessonAudio entities.
func (m *LessonAudioMutation) SetID(id gqlid.LessonAudioID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonAudioMutation) ID() (id gqlid.LessonAudioID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonAudioMutation) IDs(ctx context.Context) ([]gqlid.LessonAudioID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.LessonAudioID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonAudio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLessonID sets the "lesson_id" field.
func (m *LessonAudioMutation) SetLessonID(gi gqlid.LessonID) {
	m.lesson = &gi
}

// LessonID returns the value of the "lesson_id" field in the mutation.
func (m *LessonAudioMutation) LessonID() (r gqlid.LessonID, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonID returns the old "lesson_id" field's value of the LessonAudio entity.
// If the LessonAudio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonAudioMutation) OldLessonID(ctx context.Context) (v gqlid.LessonID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonID: %w", err)
	}
	return oldValue.LessonID, nil
}

// ResetLessonID resets all changes to the "lesson_id" field.
func (m *LessonAudioMutation) ResetLessonID() {
	m.lesson = nil
}

// SetAudioURL sets the "audioURL" field.
func (m *LessonAudioMutation) SetAudioURL(s string) {
	m.audioURL = &s
}

// AudioURL returns the value of the "audioURL" field in the mutation.
func (m *LessonAudioMutation) AudioURL() (r string, exists bool) {
	v := m.audioURL
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioURL returns the old "audioURL" field's value of the LessonAudio entity.
// If the LessonAudio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonAudioMutation) OldAudioURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioURL: %w", err)
	}
	return oldValue.AudioURL, nil
}

// ResetAudioURL resets all changes to the "audioURL" field.
func (m *LessonAudioMutation) ResetAudioURL() {
	m.audioURL = nil
}

// SetDuration sets the "duration" field.
func (m *LessonAudioMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *LessonAudioMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the LessonAudio entity.
// If the LessonAudio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonAudioMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *LessonAudioMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *LessonAudioMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *LessonAudioMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// ClearLesson clears the "lesson" edge to the Lesson entity.
func (m *LessonAudioMutation) ClearLesson() {
	m.clearedlesson = true
	m.clearedFields[lessonaudio.FieldLessonID] = struct{}{}
}

// LessonCleared reports if the "lesson" edge to the Lesson entity was cleared.
func (m *LessonAudioMutation) LessonCleared() bool {
	return m.clearedlesson
}

// LessonIDs returns the "lesson" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonID instead. It exists only for internal usage by the builders.
func (m *LessonAudioMutation) LessonIDs() (ids []gqlid.LessonID) {
	if id := m.lesson; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLesson resets all changes to the "lesson" edge.
func (m *LessonAudioMutation) ResetLesson() {
	m.lesson = nil
	m.clearedlesson = false
}

// Where appends a list predicates to the LessonAudioMutation builder.
func (m *LessonAudioMutation) Where(ps ...predicate.LessonAudio) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonAudioMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonAudioMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonAudio, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonAudioMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonAudioMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonAudio).
func (m *LessonAudioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonAudioMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.lesson != nil {
		fields = append(fields, lessonaudio.FieldLessonID)
	}
	if m.audioURL != nil {
		fields = append(fields, lessonaudio.FieldAudioURL)
	}
	if m.duration != nil {
		fields = append(fields, lessonaudio.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonAudioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonaudio.FieldLessonID:
		return m.LessonID()
	case lessonaudio.FieldAudioURL:
		return m.AudioURL()
	case lessonaudio.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonAudioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonaudio.FieldLessonID:
		return m.OldLessonID(ctx)
	case lessonaudio.FieldAudioURL:
		return m.OldAudioURL(ctx)
	case lessonaudio.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown LessonAudio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonAudioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonaudio.FieldLessonID:
		v, ok := value.(gqlid.LessonID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonID(v)
		return nil
	case lessonaudio.FieldAudioURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioURL(v)
		return nil
	case lessonaudio.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown LessonAudio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonAudioMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, lessonaudio.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonAudioMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lessonaudio.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonAudioMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lessonaudio.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown LessonAudio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonAudioMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonAudioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonAudioMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LessonAudio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonAudioMutation) ResetField(name string) error {
	switch name {
	case lessonaudio.FieldLessonID:
		m.ResetLessonID()
		return nil
	case lessonaudio.FieldAudioURL:
		m.ResetAudioURL()
		return nil
	case lessonaudio.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown LessonAudio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonAudioMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lesson != nil {
		edges = append(edges, lessonaudio.EdgeLesson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonAudioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonaudio.EdgeLesson:
		if id := m.lesson; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonAudioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonAudioMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonAudioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlesson {
		edges = append(edges, lessonaudio.EdgeLesson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonAudioMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonaudio.EdgeLesson:
		return m.clearedlesson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonAudioMutation) ClearEdge(name string) error {
	switch name {
	case lessonaudio.EdgeLesson:
		m.ClearLesson()
		return nil
	}
	return fmt.Errorf("unknown LessonAudio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonAudioMutation) ResetEdge(name string) error {
	switch name {
	case lessonaudio.EdgeLesson:
		m.ResetLesson()
		return nil
	}
	return fmt.Errorf("unknown LessonAudio edge %s", name)
}

// LessonTechniqueMutation represents an operation that mutates the LessonTechnique nodes in the graph.
type LessonTechniqueMutation struct {
	config
	op               Op
	typ              string
	_order           *int64
	add_order        *int64
	clearedFields    map[string]struct{}
	lesson           *gqlid.LessonID
	clearedlesson    bool
	technique        *gqlid.TechniqueID
	clearedtechnique bool
	done             bool
	oldValue         func(context.Context) (*LessonTechnique, error)
	predicates       []predicate.LessonTechnique
}

var _ ent.Mutation = (*LessonTechniqueMutation)(nil)

// lessontechniqueOption allows management of the mutation configuration using functional options.
type lessontechniqueOption func(*LessonTechniqueMutation)

// newLessonTechniqueMutation creates new mutation for the LessonTechnique entity.
func newLessonTechniqueMutation(c config, op Op, opts ...lessontechniqueOption) *LessonTechniqueMutation {
	m := &LessonTechniqueMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonTechnique,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonTechniqueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonTechniqueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetLessonID sets the "lesson_id" field.
func (m *LessonTechniqueMutation) SetLessonID(gi gqlid.LessonID) {
	m.lesson = &gi
}

// LessonID returns the value of the "lesson_id" field in the mutation.
func (m *LessonTechniqueMutation) LessonID() (r gqlid.LessonID, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// ResetLessonID resets all changes to the "lesson_id" field.
func (m *LessonTechniqueMutation) ResetLessonID() {
	m.lesson = nil
}

// SetTechniqueID sets the "technique_id" field.
func (m *LessonTechniqueMutation) SetTechniqueID(gi gqlid.TechniqueID) {
	m.technique = &gi
}

// TechniqueID returns the value of the "technique_id" field in the mutation.
func (m *LessonTechniqueMutation) TechniqueID() (r gqlid.TechniqueID, exists bool) {
	v := m.technique
	if v == nil {
		return
	}
	return *v, true
}

// ResetTechniqueID resets all changes to the "technique_id" field.
func (m *LessonTechniqueMutation) ResetTechniqueID() {
	m.technique = nil
}

// SetOrder sets the "order" field.
func (m *LessonTechniqueMutation) SetOrder(i int64) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *LessonTechniqueMutation) Order() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// AddOrder adds i to the "order" field.
func (m *LessonTechniqueMutation) AddOrder(i int64) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *LessonTechniqueMutation) AddedOrder() (r int64, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *LessonTechniqueMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearLesson clears the "lesson" edge to the Lesson entity.
func (m *LessonTechniqueMutation) ClearLesson() {
	m.clearedlesson = true
	m.clearedFields[lessontechnique.FieldLessonID] = struct{}{}
}

// LessonCleared reports if the "lesson" edge to the Lesson entity was cleared.
func (m *LessonTechniqueMutation) LessonCleared() bool {
	return m.clearedlesson
}

// LessonIDs returns the "lesson" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonID instead. It exists only for internal usage by the builders.
func (m *LessonTechniqueMutation) LessonIDs() (ids []gqlid.LessonID) {
	if id := m.lesson; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLesson resets all changes to the "lesson" edge.
func (m *LessonTechniqueMutation) ResetLesson() {
	m.lesson = nil
	m.clearedlesson = false
}

// ClearTechnique clears the "technique" edge to the Technique entity.
func (m *LessonTechniqueMutation) ClearTechnique() {
	m.clearedtechnique = true
	m.clearedFields[lessontechnique.FieldTechniqueID] = struct{}{}
}

// TechniqueCleared reports if the "technique" edge to the Technique entity was cleared.
func (m *LessonTechniqueMutation) TechniqueCleared() bool {
	return m.clearedtechnique
}

// TechniqueIDs returns the "technique" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TechniqueID instead. It exists only for internal usage by the builders.
func (m *LessonTechniqueMutation) TechniqueIDs() (ids []gqlid.TechniqueID) {
	if id := m.technique; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTechnique resets all changes to the "technique" edge.
func (m *LessonTechniqueMutation) ResetTechnique() {
	m.technique = nil
	m.clearedtechnique = false
}

// Where appends a list predicates to the LessonTechniqueMutation builder.
func (m *LessonTechniqueMutation) Where(ps ...predicate.LessonTechnique) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonTechniqueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonTechniqueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonTechnique, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonTechniqueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonTechniqueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonTechnique).
func (m *LessonTechniqueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonTechniqueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.lesson != nil {
		fields = append(fields, lessontechnique.FieldLessonID)
	}
	if m.technique != nil {
		fields = append(fields, lessontechnique.FieldTechniqueID)
	}
	if m._order != nil {
		fields = append(fields, lessontechnique.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonTechniqueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessontechnique.FieldLessonID:
		return m.LessonID()
	case lessontechnique.FieldTechniqueID:
		return m.TechniqueID()
	case lessontechnique.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonTechniqueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema LessonTechnique does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonTechniqueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessontechnique.FieldLessonID:
		v, ok := value.(gqlid.LessonID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonID(v)
		return nil
	case lessontechnique.FieldTechniqueID:
		v, ok := value.(gqlid.TechniqueID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechniqueID(v)
		return nil
	case lessontechnique.FieldOrder:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown LessonTechnique field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonTechniqueMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, lessontechnique.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonTechniqueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lessontechnique.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonTechniqueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lessontechnique.FieldOrder:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown LessonTechnique numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonTechniqueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonTechniqueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonTechniqueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LessonTechnique nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonTechniqueMutation) ResetField(name string) error {
	switch name {
	case lessontechnique.FieldLessonID:
		m.ResetLessonID()
		return nil
	case lessontechnique.FieldTechniqueID:
		m.ResetTechniqueID()
		return nil
	case lessontechnique.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown LessonTechnique field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonTechniqueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lesson != nil {
		edges = append(edges, lessontechnique.EdgeLesson)
	}
	if m.technique != nil {
		edges = append(edges, lessontechnique.EdgeTechnique)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonTechniqueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessontechnique.EdgeLesson:
		if id := m.lesson; id != nil {
			return []ent.Value{*id}
		}
	case lessontechnique.EdgeTechnique:
		if id := m.technique; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonTechniqueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonTechniqueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonTechniqueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlesson {
		edges = append(edges, lessontechnique.EdgeLesson)
	}
	if m.clearedtechnique {
		edges = append(edges, lessontechnique.EdgeTechnique)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonTechniqueMutation) EdgeCleared(name string) bool {
	switch name {
	case lessontechnique.EdgeLesson:
		return m.clearedlesson
	case lessontechnique.EdgeTechnique:
		return m.clearedtechnique
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonTechniqueMutation) ClearEdge(name string) error {
	switch name {
	case lessontechnique.EdgeLesson:
		m.ClearLesson()
		return nil
	case lessontechnique.EdgeTechnique:
		m.ClearTechnique()
		return nil
	}
	return fmt.Errorf("unknown LessonTechnique unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonTechniqueMutation) ResetEdge(name string) error {
	switch name {
	case lessontechnique.EdgeLesson:
		m.ResetLesson()
		return nil
	case lessontechnique.EdgeTechnique:
		m.ResetTechnique()
		return nil
	}
	return fmt.Errorf("unknown LessonTechnique edge %s", name)
}

// TechniqueMutation represents an operation that mutates the Technique nodes in the graph.
type TechniqueMutation struct {
	config
	op                Op
	typ               string
	id                *gqlid.TechniqueID
	iconImage         *string
	coverImage        *string
	title             *string
	subtitle          *string
	description       *string
	_order            *int
	add_order         *int
	clearedFields     map[string]struct{}
	unit              *gqlid.UnitID
	clearedunit       bool
	lessons           map[gqlid.LessonID]struct{}
	removedlessons    map[gqlid.LessonID]struct{}
	clearedlessons    bool
	techniques        map[gqlid.UnitID]struct{}
	removedtechniques map[gqlid.UnitID]struct{}
	clearedtechniques bool
	done              bool
	oldValue          func(context.Context) (*Technique, error)
	predicates        []predicate.Technique
}

var _ ent.Mutation = (*TechniqueMutation)(nil)

// techniqueOption allows management of the mutation configuration using functional options.
type techniqueOption func(*TechniqueMutation)

// newTechniqueMutation creates new mutation for the Technique entity.
func newTechniqueMutation(c config, op Op, opts ...techniqueOption) *TechniqueMutation {
	m := &TechniqueMutation{
		config:        c,
		op:            op,
		typ:           TypeTechnique,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTechniqueID sets the ID field of the mutation.
func withTechniqueID(id gqlid.TechniqueID) techniqueOption {
	return func(m *TechniqueMutation) {
		var (
			err   error
			once  sync.Once
			value *Technique
		)
		m.oldValue = func(ctx context.Context) (*Technique, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Technique.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTechnique sets the old Technique of the mutation.
func withTechnique(node *Technique) techniqueOption {
	return func(m *TechniqueMutation) {
		m.oldValue = func(context.Context) (*Technique, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TechniqueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TechniqueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Technique entities.
func (m *TechniqueMutation) SetID(id gqlid.TechniqueID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TechniqueMutation) ID() (id gqlid.TechniqueID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TechniqueMutation) IDs(ctx context.Context) ([]gqlid.TechniqueID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.TechniqueID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Technique.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUnitID sets the "unit_id" field.
func (m *TechniqueMutation) SetUnitID(gi gqlid.UnitID) {
	m.unit = &gi
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *TechniqueMutation) UnitID() (r gqlid.UnitID, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldUnitID(ctx context.Context) (v gqlid.UnitID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *TechniqueMutation) ResetUnitID() {
	m.unit = nil
}

// SetIconImage sets the "iconImage" field.
func (m *TechniqueMutation) SetIconImage(s string) {
	m.iconImage = &s
}

// IconImage returns the value of the "iconImage" field in the mutation.
func (m *TechniqueMutation) IconImage() (r string, exists bool) {
	v := m.iconImage
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImage returns the old "iconImage" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldIconImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImage: %w", err)
	}
	return oldValue.IconImage, nil
}

// ResetIconImage resets all changes to the "iconImage" field.
func (m *TechniqueMutation) ResetIconImage() {
	m.iconImage = nil
}

// SetCoverImage sets the "coverImage" field.
func (m *TechniqueMutation) SetCoverImage(s string) {
	m.coverImage = &s
}

// CoverImage returns the value of the "coverImage" field in the mutation.
func (m *TechniqueMutation) CoverImage() (r string, exists bool) {
	v := m.coverImage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "coverImage" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ResetCoverImage resets all changes to the "coverImage" field.
func (m *TechniqueMutation) ResetCoverImage() {
	m.coverImage = nil
}

// SetTitle sets the "title" field.
func (m *TechniqueMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TechniqueMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TechniqueMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *TechniqueMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *TechniqueMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *TechniqueMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetDescription sets the "description" field.
func (m *TechniqueMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TechniqueMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TechniqueMutation) ResetDescription() {
	m.description = nil
}

// SetOrder sets the "order" field.
func (m *TechniqueMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TechniqueMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Technique entity.
// If the Technique object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TechniqueMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TechniqueMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TechniqueMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TechniqueMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *TechniqueMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[technique.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *TechniqueMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *TechniqueMutation) UnitIDs() (ids []gqlid.UnitID) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *TechniqueMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// AddLessonIDs adds the "lessons" edge to the Lesson entity by ids.
func (m *TechniqueMutation) AddLessonIDs(ids ...gqlid.LessonID) {
	if m.lessons == nil {
		m.lessons = make(map[gqlid.LessonID]struct{})
	}
	for i := range ids {
		m.lessons[ids[i]] = struct{}{}
	}
}

// ClearLessons clears the "lessons" edge to the Lesson entity.
func (m *TechniqueMutation) ClearLessons() {
	m.clearedlessons = true
}

// LessonsCleared reports if the "lessons" edge to the Lesson entity was cleared.
func (m *TechniqueMutation) LessonsCleared() bool {
	return m.clearedlessons
}

// RemoveLessonIDs removes the "lessons" edge to the Lesson entity by IDs.
func (m *TechniqueMutation) RemoveLessonIDs(ids ...gqlid.LessonID) {
	if m.removedlessons == nil {
		m.removedlessons = make(map[gqlid.LessonID]struct{})
	}
	for i := range ids {
		delete(m.lessons, ids[i])
		m.removedlessons[ids[i]] = struct{}{}
	}
}

// RemovedLessons returns the removed IDs of the "lessons" edge to the Lesson entity.
func (m *TechniqueMutation) RemovedLessonsIDs() (ids []gqlid.LessonID) {
	for id := range m.removedlessons {
		ids = append(ids, id)
	}
	return
}

// LessonsIDs returns the "lessons" edge IDs in the mutation.
func (m *TechniqueMutation) LessonsIDs() (ids []gqlid.LessonID) {
	for id := range m.lessons {
		ids = append(ids, id)
	}
	return
}

// ResetLessons resets all changes to the "lessons" edge.
func (m *TechniqueMutation) ResetLessons() {
	m.lessons = nil
	m.clearedlessons = false
	m.removedlessons = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Unit entity by ids.
func (m *TechniqueMutation) AddTechniqueIDs(ids ...gqlid.UnitID) {
	if m.techniques == nil {
		m.techniques = make(map[gqlid.UnitID]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Unit entity.
func (m *TechniqueMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Unit entity was cleared.
func (m *TechniqueMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Unit entity by IDs.
func (m *TechniqueMutation) RemoveTechniqueIDs(ids ...gqlid.UnitID) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[gqlid.UnitID]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Unit entity.
func (m *TechniqueMutation) RemovedTechniquesIDs() (ids []gqlid.UnitID) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *TechniqueMutation) TechniquesIDs() (ids []gqlid.UnitID) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *TechniqueMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// Where appends a list predicates to the TechniqueMutation builder.
func (m *TechniqueMutation) Where(ps ...predicate.Technique) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TechniqueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TechniqueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Technique, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TechniqueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TechniqueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Technique).
func (m *TechniqueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TechniqueMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.unit != nil {
		fields = append(fields, technique.FieldUnitID)
	}
	if m.iconImage != nil {
		fields = append(fields, technique.FieldIconImage)
	}
	if m.coverImage != nil {
		fields = append(fields, technique.FieldCoverImage)
	}
	if m.title != nil {
		fields = append(fields, technique.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, technique.FieldSubtitle)
	}
	if m.description != nil {
		fields = append(fields, technique.FieldDescription)
	}
	if m._order != nil {
		fields = append(fields, technique.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TechniqueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case technique.FieldUnitID:
		return m.UnitID()
	case technique.FieldIconImage:
		return m.IconImage()
	case technique.FieldCoverImage:
		return m.CoverImage()
	case technique.FieldTitle:
		return m.Title()
	case technique.FieldSubtitle:
		return m.Subtitle()
	case technique.FieldDescription:
		return m.Description()
	case technique.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TechniqueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case technique.FieldUnitID:
		return m.OldUnitID(ctx)
	case technique.FieldIconImage:
		return m.OldIconImage(ctx)
	case technique.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case technique.FieldTitle:
		return m.OldTitle(ctx)
	case technique.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case technique.FieldDescription:
		return m.OldDescription(ctx)
	case technique.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Technique field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case technique.FieldUnitID:
		v, ok := value.(gqlid.UnitID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case technique.FieldIconImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImage(v)
		return nil
	case technique.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case technique.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case technique.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case technique.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case technique.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TechniqueMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, technique.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TechniqueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case technique.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TechniqueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case technique.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Technique numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TechniqueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TechniqueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TechniqueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Technique nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TechniqueMutation) ResetField(name string) error {
	switch name {
	case technique.FieldUnitID:
		m.ResetUnitID()
		return nil
	case technique.FieldIconImage:
		m.ResetIconImage()
		return nil
	case technique.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case technique.FieldTitle:
		m.ResetTitle()
		return nil
	case technique.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case technique.FieldDescription:
		m.ResetDescription()
		return nil
	case technique.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Technique field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TechniqueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.unit != nil {
		edges = append(edges, technique.EdgeUnit)
	}
	if m.lessons != nil {
		edges = append(edges, technique.EdgeLessons)
	}
	if m.techniques != nil {
		edges = append(edges, technique.EdgeTechniques)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TechniqueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case technique.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.lessons))
		for id := range m.lessons {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TechniqueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlessons != nil {
		edges = append(edges, technique.EdgeLessons)
	}
	if m.removedtechniques != nil {
		edges = append(edges, technique.EdgeTechniques)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TechniqueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case technique.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.removedlessons))
		for id := range m.removedlessons {
			ids = append(ids, id)
		}
		return ids
	case technique.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TechniqueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedunit {
		edges = append(edges, technique.EdgeUnit)
	}
	if m.clearedlessons {
		edges = append(edges, technique.EdgeLessons)
	}
	if m.clearedtechniques {
		edges = append(edges, technique.EdgeTechniques)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TechniqueMutation) EdgeCleared(name string) bool {
	switch name {
	case technique.EdgeUnit:
		return m.clearedunit
	case technique.EdgeLessons:
		return m.clearedlessons
	case technique.EdgeTechniques:
		return m.clearedtechniques
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TechniqueMutation) ClearEdge(name string) error {
	switch name {
	case technique.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown Technique unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TechniqueMutation) ResetEdge(name string) error {
	switch name {
	case technique.EdgeUnit:
		m.ResetUnit()
		return nil
	case technique.EdgeLessons:
		m.ResetLessons()
		return nil
	case technique.EdgeTechniques:
		m.ResetTechniques()
		return nil
	}
	return fmt.Errorf("unknown Technique edge %s", name)
}

// UnitMutation represents an operation that mutates the Unit nodes in the graph.
type UnitMutation struct {
	config
	op                Op
	typ               string
	id                *gqlid.UnitID
	iconImage         *string
	coverImage        *string
	title             *string
	subtitle          *string
	description       *string
	mastering         *string
	days              *int
	adddays           *int
	color             *string
	_order            *int
	add_order         *int
	clearedFields     map[string]struct{}
	course            *gqlid.CourseID
	clearedcourse     bool
	lessons           map[gqlid.LessonID]struct{}
	removedlessons    map[gqlid.LessonID]struct{}
	clearedlessons    bool
	techniques        map[gqlid.TechniqueID]struct{}
	removedtechniques map[gqlid.TechniqueID]struct{}
	clearedtechniques bool
	done              bool
	oldValue          func(context.Context) (*Unit, error)
	predicates        []predicate.Unit
}

var _ ent.Mutation = (*UnitMutation)(nil)

// unitOption allows management of the mutation configuration using functional options.
type unitOption func(*UnitMutation)

// newUnitMutation creates new mutation for the Unit entity.
func newUnitMutation(c config, op Op, opts ...unitOption) *UnitMutation {
	m := &UnitMutation{
		config:        c,
		op:            op,
		typ:           TypeUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnitID sets the ID field of the mutation.
func withUnitID(id gqlid.UnitID) unitOption {
	return func(m *UnitMutation) {
		var (
			err   error
			once  sync.Once
			value *Unit
		)
		m.oldValue = func(ctx context.Context) (*Unit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Unit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnit sets the old Unit of the mutation.
func withUnit(node *Unit) unitOption {
	return func(m *UnitMutation) {
		m.oldValue = func(context.Context) (*Unit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Unit entities.
func (m *UnitMutation) SetID(id gqlid.UnitID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UnitMutation) ID() (id gqlid.UnitID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UnitMutation) IDs(ctx context.Context) ([]gqlid.UnitID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.UnitID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Unit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCourseID sets the "course_id" field.
func (m *UnitMutation) SetCourseID(gi gqlid.CourseID) {
	m.course = &gi
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *UnitMutation) CourseID() (r gqlid.CourseID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldCourseID(ctx context.Context) (v gqlid.CourseID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *UnitMutation) ResetCourseID() {
	m.course = nil
}

// SetIconImage sets the "iconImage" field.
func (m *UnitMutation) SetIconImage(s string) {
	m.iconImage = &s
}

// IconImage returns the value of the "iconImage" field in the mutation.
func (m *UnitMutation) IconImage() (r string, exists bool) {
	v := m.iconImage
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImage returns the old "iconImage" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldIconImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImage: %w", err)
	}
	return oldValue.IconImage, nil
}

// ResetIconImage resets all changes to the "iconImage" field.
func (m *UnitMutation) ResetIconImage() {
	m.iconImage = nil
}

// SetCoverImage sets the "coverImage" field.
func (m *UnitMutation) SetCoverImage(s string) {
	m.coverImage = &s
}

// CoverImage returns the value of the "coverImage" field in the mutation.
func (m *UnitMutation) CoverImage() (r string, exists bool) {
	v := m.coverImage
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "coverImage" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ResetCoverImage resets all changes to the "coverImage" field.
func (m *UnitMutation) ResetCoverImage() {
	m.coverImage = nil
}

// SetTitle sets the "title" field.
func (m *UnitMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UnitMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UnitMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *UnitMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *UnitMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *UnitMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetDescription sets the "description" field.
func (m *UnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UnitMutation) ResetDescription() {
	m.description = nil
}

// SetMastering sets the "mastering" field.
func (m *UnitMutation) SetMastering(s string) {
	m.mastering = &s
}

// Mastering returns the value of the "mastering" field in the mutation.
func (m *UnitMutation) Mastering() (r string, exists bool) {
	v := m.mastering
	if v == nil {
		return
	}
	return *v, true
}

// OldMastering returns the old "mastering" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldMastering(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMastering is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMastering requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMastering: %w", err)
	}
	return oldValue.Mastering, nil
}

// ResetMastering resets all changes to the "mastering" field.
func (m *UnitMutation) ResetMastering() {
	m.mastering = nil
}

// SetDays sets the "days" field.
func (m *UnitMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *UnitMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *UnitMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *UnitMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *UnitMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetColor sets the "color" field.
func (m *UnitMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *UnitMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *UnitMutation) ResetColor() {
	m.color = nil
}

// SetOrder sets the "order" field.
func (m *UnitMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *UnitMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Unit entity.
// If the Unit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UnitMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *UnitMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *UnitMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *UnitMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *UnitMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[unit.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *UnitMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *UnitMutation) CourseIDs() (ids []gqlid.CourseID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *UnitMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddLessonIDs adds the "lessons" edge to the Lesson entity by ids.
func (m *UnitMutation) AddLessonIDs(ids ...gqlid.LessonID) {
	if m.lessons == nil {
		m.lessons = make(map[gqlid.LessonID]struct{})
	}
	for i := range ids {
		m.lessons[ids[i]] = struct{}{}
	}
}

// ClearLessons clears the "lessons" edge to the Lesson entity.
func (m *UnitMutation) ClearLessons() {
	m.clearedlessons = true
}

// LessonsCleared reports if the "lessons" edge to the Lesson entity was cleared.
func (m *UnitMutation) LessonsCleared() bool {
	return m.clearedlessons
}

// RemoveLessonIDs removes the "lessons" edge to the Lesson entity by IDs.
func (m *UnitMutation) RemoveLessonIDs(ids ...gqlid.LessonID) {
	if m.removedlessons == nil {
		m.removedlessons = make(map[gqlid.LessonID]struct{})
	}
	for i := range ids {
		delete(m.lessons, ids[i])
		m.removedlessons[ids[i]] = struct{}{}
	}
}

// RemovedLessons returns the removed IDs of the "lessons" edge to the Lesson entity.
func (m *UnitMutation) RemovedLessonsIDs() (ids []gqlid.LessonID) {
	for id := range m.removedlessons {
		ids = append(ids, id)
	}
	return
}

// LessonsIDs returns the "lessons" edge IDs in the mutation.
func (m *UnitMutation) LessonsIDs() (ids []gqlid.LessonID) {
	for id := range m.lessons {
		ids = append(ids, id)
	}
	return
}

// ResetLessons resets all changes to the "lessons" edge.
func (m *UnitMutation) ResetLessons() {
	m.lessons = nil
	m.clearedlessons = false
	m.removedlessons = nil
}

// AddTechniqueIDs adds the "techniques" edge to the Technique entity by ids.
func (m *UnitMutation) AddTechniqueIDs(ids ...gqlid.TechniqueID) {
	if m.techniques == nil {
		m.techniques = make(map[gqlid.TechniqueID]struct{})
	}
	for i := range ids {
		m.techniques[ids[i]] = struct{}{}
	}
}

// ClearTechniques clears the "techniques" edge to the Technique entity.
func (m *UnitMutation) ClearTechniques() {
	m.clearedtechniques = true
}

// TechniquesCleared reports if the "techniques" edge to the Technique entity was cleared.
func (m *UnitMutation) TechniquesCleared() bool {
	return m.clearedtechniques
}

// RemoveTechniqueIDs removes the "techniques" edge to the Technique entity by IDs.
func (m *UnitMutation) RemoveTechniqueIDs(ids ...gqlid.TechniqueID) {
	if m.removedtechniques == nil {
		m.removedtechniques = make(map[gqlid.TechniqueID]struct{})
	}
	for i := range ids {
		delete(m.techniques, ids[i])
		m.removedtechniques[ids[i]] = struct{}{}
	}
}

// RemovedTechniques returns the removed IDs of the "techniques" edge to the Technique entity.
func (m *UnitMutation) RemovedTechniquesIDs() (ids []gqlid.TechniqueID) {
	for id := range m.removedtechniques {
		ids = append(ids, id)
	}
	return
}

// TechniquesIDs returns the "techniques" edge IDs in the mutation.
func (m *UnitMutation) TechniquesIDs() (ids []gqlid.TechniqueID) {
	for id := range m.techniques {
		ids = append(ids, id)
	}
	return
}

// ResetTechniques resets all changes to the "techniques" edge.
func (m *UnitMutation) ResetTechniques() {
	m.techniques = nil
	m.clearedtechniques = false
	m.removedtechniques = nil
}

// Where appends a list predicates to the UnitMutation builder.
func (m *UnitMutation) Where(ps ...predicate.Unit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Unit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Unit).
func (m *UnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnitMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.course != nil {
		fields = append(fields, unit.FieldCourseID)
	}
	if m.iconImage != nil {
		fields = append(fields, unit.FieldIconImage)
	}
	if m.coverImage != nil {
		fields = append(fields, unit.FieldCoverImage)
	}
	if m.title != nil {
		fields = append(fields, unit.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, unit.FieldSubtitle)
	}
	if m.description != nil {
		fields = append(fields, unit.FieldDescription)
	}
	if m.mastering != nil {
		fields = append(fields, unit.FieldMastering)
	}
	if m.days != nil {
		fields = append(fields, unit.FieldDays)
	}
	if m.color != nil {
		fields = append(fields, unit.FieldColor)
	}
	if m._order != nil {
		fields = append(fields, unit.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldCourseID:
		return m.CourseID()
	case unit.FieldIconImage:
		return m.IconImage()
	case unit.FieldCoverImage:
		return m.CoverImage()
	case unit.FieldTitle:
		return m.Title()
	case unit.FieldSubtitle:
		return m.Subtitle()
	case unit.FieldDescription:
		return m.Description()
	case unit.FieldMastering:
		return m.Mastering()
	case unit.FieldDays:
		return m.Days()
	case unit.FieldColor:
		return m.Color()
	case unit.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unit.FieldCourseID:
		return m.OldCourseID(ctx)
	case unit.FieldIconImage:
		return m.OldIconImage(ctx)
	case unit.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case unit.FieldTitle:
		return m.OldTitle(ctx)
	case unit.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case unit.FieldDescription:
		return m.OldDescription(ctx)
	case unit.FieldMastering:
		return m.OldMastering(ctx)
	case unit.FieldDays:
		return m.OldDays(ctx)
	case unit.FieldColor:
		return m.OldColor(ctx)
	case unit.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Unit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unit.FieldCourseID:
		v, ok := value.(gqlid.CourseID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case unit.FieldIconImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImage(v)
		return nil
	case unit.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case unit.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case unit.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case unit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case unit.FieldMastering:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMastering(v)
		return nil
	case unit.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case unit.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case unit.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnitMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, unit.FieldDays)
	}
	if m.add_order != nil {
		fields = append(fields, unit.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case unit.FieldDays:
		return m.AddedDays()
	case unit.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case unit.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case unit.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Unit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Unit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnitMutation) ResetField(name string) error {
	switch name {
	case unit.FieldCourseID:
		m.ResetCourseID()
		return nil
	case unit.FieldIconImage:
		m.ResetIconImage()
		return nil
	case unit.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case unit.FieldTitle:
		m.ResetTitle()
		return nil
	case unit.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case unit.FieldDescription:
		m.ResetDescription()
		return nil
	case unit.FieldMastering:
		m.ResetMastering()
		return nil
	case unit.FieldDays:
		m.ResetDays()
		return nil
	case unit.FieldColor:
		m.ResetColor()
		return nil
	case unit.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Unit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, unit.EdgeCourse)
	}
	if m.lessons != nil {
		edges = append(edges, unit.EdgeLessons)
	}
	if m.techniques != nil {
		edges = append(edges, unit.EdgeTechniques)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case unit.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.lessons))
		for id := range m.lessons {
			ids = append(ids, id)
		}
		return ids
	case unit.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.techniques))
		for id := range m.techniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlessons != nil {
		edges = append(edges, unit.EdgeLessons)
	}
	if m.removedtechniques != nil {
		edges = append(edges, unit.EdgeTechniques)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case unit.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.removedlessons))
		for id := range m.removedlessons {
			ids = append(ids, id)
		}
		return ids
	case unit.EdgeTechniques:
		ids := make([]ent.Value, 0, len(m.removedtechniques))
		for id := range m.removedtechniques {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, unit.EdgeCourse)
	}
	if m.clearedlessons {
		edges = append(edges, unit.EdgeLessons)
	}
	if m.clearedtechniques {
		edges = append(edges, unit.EdgeTechniques)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnitMutation) EdgeCleared(name string) bool {
	switch name {
	case unit.EdgeCourse:
		return m.clearedcourse
	case unit.EdgeLessons:
		return m.clearedlessons
	case unit.EdgeTechniques:
		return m.clearedtechniques
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnitMutation) ClearEdge(name string) error {
	switch name {
	case unit.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Unit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnitMutation) ResetEdge(name string) error {
	switch name {
	case unit.EdgeCourse:
		m.ResetCourse()
		return nil
	case unit.EdgeLessons:
		m.ResetLessons()
		return nil
	case unit.EdgeTechniques:
		m.ResetTechniques()
		return nil
	}
	return fmt.Errorf("unknown Unit edge %s", name)
}

// UnitTechniqueMutation represents an operation that mutates the UnitTechnique nodes in the graph.
type UnitTechniqueMutation struct {
	config
	op               Op
	typ              string
	position         *int64
	addposition      *int64
	clearedFields    map[string]struct{}
	unit             *gqlid.UnitID
	clearedunit      bool
	technique        *gqlid.TechniqueID
	clearedtechnique bool
	done             bool
	oldValue         func(context.Context) (*UnitTechnique, error)
	predicates       []predicate.UnitTechnique
}

var _ ent.Mutation = (*UnitTechniqueMutation)(nil)

// unittechniqueOption allows management of the mutation configuration using functional options.
type unittechniqueOption func(*UnitTechniqueMutation)

// newUnitTechniqueMutation creates new mutation for the UnitTechnique entity.
func newUnitTechniqueMutation(c config, op Op, opts ...unittechniqueOption) *UnitTechniqueMutation {
	m := &UnitTechniqueMutation{
		config:        c,
		op:            op,
		typ:           TypeUnitTechnique,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitTechniqueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitTechniqueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUnitID sets the "unit_id" field.
func (m *UnitTechniqueMutation) SetUnitID(gi gqlid.UnitID) {
	m.unit = &gi
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *UnitTechniqueMutation) UnitID() (r gqlid.UnitID, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *UnitTechniqueMutation) ResetUnitID() {
	m.unit = nil
}

// SetTechniqueID sets the "technique_id" field.
func (m *UnitTechniqueMutation) SetTechniqueID(gi gqlid.TechniqueID) {
	m.technique = &gi
}

// TechniqueID returns the value of the "technique_id" field in the mutation.
func (m *UnitTechniqueMutation) TechniqueID() (r gqlid.TechniqueID, exists bool) {
	v := m.technique
	if v == nil {
		return
	}
	return *v, true
}

// ResetTechniqueID resets all changes to the "technique_id" field.
func (m *UnitTechniqueMutation) ResetTechniqueID() {
	m.technique = nil
}

// SetPosition sets the "position" field.
func (m *UnitTechniqueMutation) SetPosition(i int64) {
	m.position = &i
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *UnitTechniqueMutation) Position() (r int64, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// AddPosition adds i to the "position" field.
func (m *UnitTechniqueMutation) AddPosition(i int64) {
	if m.addposition != nil {
		*m.addposition += i
	} else {
		m.addposition = &i
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *UnitTechniqueMutation) AddedPosition() (r int64, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *UnitTechniqueMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *UnitTechniqueMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[unittechnique.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *UnitTechniqueMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *UnitTechniqueMutation) UnitIDs() (ids []gqlid.UnitID) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *UnitTechniqueMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// ClearTechnique clears the "technique" edge to the Technique entity.
func (m *UnitTechniqueMutation) ClearTechnique() {
	m.clearedtechnique = true
	m.clearedFields[unittechnique.FieldTechniqueID] = struct{}{}
}

// TechniqueCleared reports if the "technique" edge to the Technique entity was cleared.
func (m *UnitTechniqueMutation) TechniqueCleared() bool {
	return m.clearedtechnique
}

// TechniqueIDs returns the "technique" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TechniqueID instead. It exists only for internal usage by the builders.
func (m *UnitTechniqueMutation) TechniqueIDs() (ids []gqlid.TechniqueID) {
	if id := m.technique; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTechnique resets all changes to the "technique" edge.
func (m *UnitTechniqueMutation) ResetTechnique() {
	m.technique = nil
	m.clearedtechnique = false
}

// Where appends a list predicates to the UnitTechniqueMutation builder.
func (m *UnitTechniqueMutation) Where(ps ...predicate.UnitTechnique) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UnitTechniqueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UnitTechniqueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UnitTechnique, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UnitTechniqueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UnitTechniqueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UnitTechnique).
func (m *UnitTechniqueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UnitTechniqueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.unit != nil {
		fields = append(fields, unittechnique.FieldUnitID)
	}
	if m.technique != nil {
		fields = append(fields, unittechnique.FieldTechniqueID)
	}
	if m.position != nil {
		fields = append(fields, unittechnique.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UnitTechniqueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unittechnique.FieldUnitID:
		return m.UnitID()
	case unittechnique.FieldTechniqueID:
		return m.TechniqueID()
	case unittechnique.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UnitTechniqueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UnitTechnique does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitTechniqueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unittechnique.FieldUnitID:
		v, ok := value.(gqlid.UnitID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case unittechnique.FieldTechniqueID:
		v, ok := value.(gqlid.TechniqueID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechniqueID(v)
		return nil
	case unittechnique.FieldPosition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown UnitTechnique field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UnitTechniqueMutation) AddedFields() []string {
	var fields []string
	if m.addposition != nil {
		fields = append(fields, unittechnique.FieldPosition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UnitTechniqueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case unittechnique.FieldPosition:
		return m.AddedPosition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UnitTechniqueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case unittechnique.FieldPosition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	}
	return fmt.Errorf("unknown UnitTechnique numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UnitTechniqueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UnitTechniqueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitTechniqueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UnitTechnique nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UnitTechniqueMutation) ResetField(name string) error {
	switch name {
	case unittechnique.FieldUnitID:
		m.ResetUnitID()
		return nil
	case unittechnique.FieldTechniqueID:
		m.ResetTechniqueID()
		return nil
	case unittechnique.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown UnitTechnique field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UnitTechniqueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.unit != nil {
		edges = append(edges, unittechnique.EdgeUnit)
	}
	if m.technique != nil {
		edges = append(edges, unittechnique.EdgeTechnique)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UnitTechniqueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unittechnique.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case unittechnique.EdgeTechnique:
		if id := m.technique; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UnitTechniqueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UnitTechniqueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UnitTechniqueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedunit {
		edges = append(edges, unittechnique.EdgeUnit)
	}
	if m.clearedtechnique {
		edges = append(edges, unittechnique.EdgeTechnique)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UnitTechniqueMutation) EdgeCleared(name string) bool {
	switch name {
	case unittechnique.EdgeUnit:
		return m.clearedunit
	case unittechnique.EdgeTechnique:
		return m.clearedtechnique
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UnitTechniqueMutation) ClearEdge(name string) error {
	switch name {
	case unittechnique.EdgeUnit:
		m.ClearUnit()
		return nil
	case unittechnique.EdgeTechnique:
		m.ClearTechnique()
		return nil
	}
	return fmt.Errorf("unknown UnitTechnique unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UnitTechniqueMutation) ResetEdge(name string) error {
	switch name {
	case unittechnique.EdgeUnit:
		m.ResetUnit()
		return nil
	case unittechnique.EdgeTechnique:
		m.ResetTechnique()
		return nil
	}
	return fmt.Errorf("unknown UnitTechnique edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *gqlid.UserID
	firebaseUid    *string
	displayName    *string
	createdAt      *time.Time
	updatedAt      *time.Time
	auth_method    *property.AuthMethod
	email          *string
	email_verified *bool
	password       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id gqlid.UserID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id gqlid.UserID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id gqlid.UserID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]gqlid.UserID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.UserID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirebaseUid sets the "firebaseUid" field.
func (m *UserMutation) SetFirebaseUid(s string) {
	m.firebaseUid = &s
}

// FirebaseUid returns the value of the "firebaseUid" field in the mutation.
func (m *UserMutation) FirebaseUid() (r string, exists bool) {
	v := m.firebaseUid
	if v == nil {
		return
	}
	return *v, true
}

// OldFirebaseUid returns the old "firebaseUid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirebaseUid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirebaseUid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirebaseUid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirebaseUid: %w", err)
	}
	return oldValue.FirebaseUid, nil
}

// ClearFirebaseUid clears the value of the "firebaseUid" field.
func (m *UserMutation) ClearFirebaseUid() {
	m.firebaseUid = nil
	m.clearedFields[user.FieldFirebaseUid] = struct{}{}
}

// FirebaseUidCleared returns if the "firebaseUid" field was cleared in this mutation.
func (m *UserMutation) FirebaseUidCleared() bool {
	_, ok := m.clearedFields[user.FieldFirebaseUid]
	return ok
}

// ResetFirebaseUid resets all changes to the "firebaseUid" field.
func (m *UserMutation) ResetFirebaseUid() {
	m.firebaseUid = nil
	delete(m.clearedFields, user.FieldFirebaseUid)
}

// SetDisplayName sets the "displayName" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.displayName = &s
}

// DisplayName returns the value of the "displayName" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.displayName
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "displayName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "displayName" field.
func (m *UserMutation) ResetDisplayName() {
	m.displayName = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetAuthMethod sets the "auth_method" field.
func (m *UserMutation) SetAuthMethod(pm property.AuthMethod) {
	m.auth_method = &pm
}

// AuthMethod returns the value of the "auth_method" field in the mutation.
func (m *UserMutation) AuthMethod() (r property.AuthMethod, exists bool) {
	v := m.auth_method
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthMethod returns the old "auth_method" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthMethod(ctx context.Context) (v property.AuthMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthMethod: %w", err)
	}
	return oldValue.AuthMethod, nil
}

// ResetAuthMethod resets all changes to the "auth_method" field.
func (m *UserMutation) ResetAuthMethod() {
	m.auth_method = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.firebaseUid != nil {
		fields = append(fields, user.FieldFirebaseUid)
	}
	if m.displayName != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.auth_method != nil {
		fields = append(fields, user.FieldAuthMethod)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirebaseUid:
		return m.FirebaseUid()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldAuthMethod:
		return m.AuthMethod()
	case user.FieldEmail:
		return m.Email()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirebaseUid:
		return m.OldFirebaseUid(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldAuthMethod:
		return m.OldAuthMethod(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirebaseUid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirebaseUid(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldAuthMethod:
		v, ok := value.(property.AuthMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthMethod(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirebaseUid) {
		fields = append(fields, user.FieldFirebaseUid)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirebaseUid:
		m.ClearFirebaseUid()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirebaseUid:
		m.ResetFirebaseUid()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldAuthMethod:
		m.ResetAuthMethod()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserProgressMutation represents an operation that mutates the UserProgress nodes in the graph.
type UserProgressMutation struct {
	config
	op            Op
	typ           string
	id            *gqlid.UserProgressID
	lesson_type   *property.LessonType
	isLast        *bool
	isNext        *bool
	progress      *int64
	addprogress   *int64
	finishedAt    *time.Time
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	user          *gqlid.UserID
	cleareduser   bool
	course        *gqlid.CourseID
	clearedcourse bool
	unit          *gqlid.UnitID
	clearedunit   bool
	lesson        *gqlid.LessonID
	clearedlesson bool
	done          bool
	oldValue      func(context.Context) (*UserProgress, error)
	predicates    []predicate.UserProgress
}

var _ ent.Mutation = (*UserProgressMutation)(nil)

// userprogressOption allows management of the mutation configuration using functional options.
type userprogressOption func(*UserProgressMutation)

// newUserProgressMutation creates new mutation for the UserProgress entity.
func newUserProgressMutation(c config, op Op, opts ...userprogressOption) *UserProgressMutation {
	m := &UserProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProgressID sets the ID field of the mutation.
func withUserProgressID(id gqlid.UserProgressID) userprogressOption {
	return func(m *UserProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProgress
		)
		m.oldValue = func(ctx context.Context) (*UserProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProgress sets the old UserProgress of the mutation.
func withUserProgress(node *UserProgress) userprogressOption {
	return func(m *UserProgressMutation) {
		m.oldValue = func(context.Context) (*UserProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProgress entities.
func (m *UserProgressMutation) SetID(id gqlid.UserProgressID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProgressMutation) ID() (id gqlid.UserProgressID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProgressMutation) IDs(ctx context.Context) ([]gqlid.UserProgressID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []gqlid.UserProgressID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserProgressMutation) SetUserID(gi gqlid.UserID) {
	m.user = &gi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProgressMutation) UserID() (r gqlid.UserID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldUserID(ctx context.Context) (v gqlid.UserID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProgressMutation) ResetUserID() {
	m.user = nil
}

// SetCourseID sets the "course_id" field.
func (m *UserProgressMutation) SetCourseID(gi gqlid.CourseID) {
	m.course = &gi
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *UserProgressMutation) CourseID() (r gqlid.CourseID, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldCourseID(ctx context.Context) (v gqlid.CourseID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *UserProgressMutation) ResetCourseID() {
	m.course = nil
}

// SetUnitID sets the "unit_id" field.
func (m *UserProgressMutation) SetUnitID(gi gqlid.UnitID) {
	m.unit = &gi
}

// UnitID returns the value of the "unit_id" field in the mutation.
func (m *UserProgressMutation) UnitID() (r gqlid.UnitID, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitID returns the old "unit_id" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldUnitID(ctx context.Context) (v gqlid.UnitID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitID: %w", err)
	}
	return oldValue.UnitID, nil
}

// ResetUnitID resets all changes to the "unit_id" field.
func (m *UserProgressMutation) ResetUnitID() {
	m.unit = nil
}

// SetLessonID sets the "lesson_id" field.
func (m *UserProgressMutation) SetLessonID(gi gqlid.LessonID) {
	m.lesson = &gi
}

// LessonID returns the value of the "lesson_id" field in the mutation.
func (m *UserProgressMutation) LessonID() (r gqlid.LessonID, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonID returns the old "lesson_id" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldLessonID(ctx context.Context) (v gqlid.LessonID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonID: %w", err)
	}
	return oldValue.LessonID, nil
}

// ResetLessonID resets all changes to the "lesson_id" field.
func (m *UserProgressMutation) ResetLessonID() {
	m.lesson = nil
}

// SetLessonType sets the "lesson_type" field.
func (m *UserProgressMutation) SetLessonType(pt property.LessonType) {
	m.lesson_type = &pt
}

// LessonType returns the value of the "lesson_type" field in the mutation.
func (m *UserProgressMutation) LessonType() (r property.LessonType, exists bool) {
	v := m.lesson_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonType returns the old "lesson_type" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldLessonType(ctx context.Context) (v property.LessonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonType: %w", err)
	}
	return oldValue.LessonType, nil
}

// ResetLessonType resets all changes to the "lesson_type" field.
func (m *UserProgressMutation) ResetLessonType() {
	m.lesson_type = nil
}

// SetIsLast sets the "isLast" field.
func (m *UserProgressMutation) SetIsLast(b bool) {
	m.isLast = &b
}

// IsLast returns the value of the "isLast" field in the mutation.
func (m *UserProgressMutation) IsLast() (r bool, exists bool) {
	v := m.isLast
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLast returns the old "isLast" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldIsLast(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLast: %w", err)
	}
	return oldValue.IsLast, nil
}

// ResetIsLast resets all changes to the "isLast" field.
func (m *UserProgressMutation) ResetIsLast() {
	m.isLast = nil
}

// SetIsNext sets the "isNext" field.
func (m *UserProgressMutation) SetIsNext(b bool) {
	m.isNext = &b
}

// IsNext returns the value of the "isNext" field in the mutation.
func (m *UserProgressMutation) IsNext() (r bool, exists bool) {
	v := m.isNext
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNext returns the old "isNext" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldIsNext(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNext: %w", err)
	}
	return oldValue.IsNext, nil
}

// ResetIsNext resets all changes to the "isNext" field.
func (m *UserProgressMutation) ResetIsNext() {
	m.isNext = nil
}

// SetProgress sets the "progress" field.
func (m *UserProgressMutation) SetProgress(i int64) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *UserProgressMutation) Progress() (r int64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldProgress(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *UserProgressMutation) AddProgress(i int64) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *UserProgressMutation) AddedProgress() (r int64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *UserProgressMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetFinishedAt sets the "finishedAt" field.
func (m *UserProgressMutation) SetFinishedAt(t time.Time) {
	m.finishedAt = &t
}

// FinishedAt returns the value of the "finishedAt" field in the mutation.
func (m *UserProgressMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finishedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finishedAt" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finishedAt" field.
func (m *UserProgressMutation) ClearFinishedAt() {
	m.finishedAt = nil
	m.clearedFields[userprogress.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finishedAt" field was cleared in this mutation.
func (m *UserProgressMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[userprogress.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finishedAt" field.
func (m *UserProgressMutation) ResetFinishedAt() {
	m.finishedAt = nil
	delete(m.clearedFields, userprogress.FieldFinishedAt)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserProgressMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserProgressMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserProgressMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the UserProgress entity.
// If the UserProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserProgressMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProgressMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userprogress.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProgressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) UserIDs() (ids []gqlid.UserID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProgressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *UserProgressMutation) ClearCourse() {
	m.clearedcourse = true
	m.clearedFields[userprogress.FieldCourseID] = struct{}{}
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *UserProgressMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) CourseIDs() (ids []gqlid.CourseID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *UserProgressMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearUnit clears the "unit" edge to the Unit entity.
func (m *UserProgressMutation) ClearUnit() {
	m.clearedunit = true
	m.clearedFields[userprogress.FieldUnitID] = struct{}{}
}

// UnitCleared reports if the "unit" edge to the Unit entity was cleared.
func (m *UserProgressMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) UnitIDs() (ids []gqlid.UnitID) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *UserProgressMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// ClearLesson clears the "lesson" edge to the Lesson entity.
func (m *UserProgressMutation) ClearLesson() {
	m.clearedlesson = true
	m.clearedFields[userprogress.FieldLessonID] = struct{}{}
}

// LessonCleared reports if the "lesson" edge to the Lesson entity was cleared.
func (m *UserProgressMutation) LessonCleared() bool {
	return m.clearedlesson
}

// LessonIDs returns the "lesson" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonID instead. It exists only for internal usage by the builders.
func (m *UserProgressMutation) LessonIDs() (ids []gqlid.LessonID) {
	if id := m.lesson; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLesson resets all changes to the "lesson" edge.
func (m *UserProgressMutation) ResetLesson() {
	m.lesson = nil
	m.clearedlesson = false
}

// Where appends a list predicates to the UserProgressMutation builder.
func (m *UserProgressMutation) Where(ps ...predicate.UserProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProgress).
func (m *UserProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProgressMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, userprogress.FieldUserID)
	}
	if m.course != nil {
		fields = append(fields, userprogress.FieldCourseID)
	}
	if m.unit != nil {
		fields = append(fields, userprogress.FieldUnitID)
	}
	if m.lesson != nil {
		fields = append(fields, userprogress.FieldLessonID)
	}
	if m.lesson_type != nil {
		fields = append(fields, userprogress.FieldLessonType)
	}
	if m.isLast != nil {
		fields = append(fields, userprogress.FieldIsLast)
	}
	if m.isNext != nil {
		fields = append(fields, userprogress.FieldIsNext)
	}
	if m.progress != nil {
		fields = append(fields, userprogress.FieldProgress)
	}
	if m.finishedAt != nil {
		fields = append(fields, userprogress.FieldFinishedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, userprogress.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, userprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprogress.FieldUserID:
		return m.UserID()
	case userprogress.FieldCourseID:
		return m.CourseID()
	case userprogress.FieldUnitID:
		return m.UnitID()
	case userprogress.FieldLessonID:
		return m.LessonID()
	case userprogress.FieldLessonType:
		return m.LessonType()
	case userprogress.FieldIsLast:
		return m.IsLast()
	case userprogress.FieldIsNext:
		return m.IsNext()
	case userprogress.FieldProgress:
		return m.Progress()
	case userprogress.FieldFinishedAt:
		return m.FinishedAt()
	case userprogress.FieldCreatedAt:
		return m.CreatedAt()
	case userprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprogress.FieldUserID:
		return m.OldUserID(ctx)
	case userprogress.FieldCourseID:
		return m.OldCourseID(ctx)
	case userprogress.FieldUnitID:
		return m.OldUnitID(ctx)
	case userprogress.FieldLessonID:
		return m.OldLessonID(ctx)
	case userprogress.FieldLessonType:
		return m.OldLessonType(ctx)
	case userprogress.FieldIsLast:
		return m.OldIsLast(ctx)
	case userprogress.FieldIsNext:
		return m.OldIsNext(ctx)
	case userprogress.FieldProgress:
		return m.OldProgress(ctx)
	case userprogress.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case userprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprogress.FieldUserID:
		v, ok := value.(gqlid.UserID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userprogress.FieldCourseID:
		v, ok := value.(gqlid.CourseID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case userprogress.FieldUnitID:
		v, ok := value.(gqlid.UnitID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitID(v)
		return nil
	case userprogress.FieldLessonID:
		v, ok := value.(gqlid.LessonID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonID(v)
		return nil
	case userprogress.FieldLessonType:
		v, ok := value.(property.LessonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonType(v)
		return nil
	case userprogress.FieldIsLast:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLast(v)
		return nil
	case userprogress.FieldIsNext:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNext(v)
		return nil
	case userprogress.FieldProgress:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case userprogress.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case userprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProgressMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, userprogress.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userprogress.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userprogress.FieldProgress:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown UserProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprogress.FieldFinishedAt) {
		fields = append(fields, userprogress.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProgressMutation) ClearField(name string) error {
	switch name {
	case userprogress.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProgressMutation) ResetField(name string) error {
	switch name {
	case userprogress.FieldUserID:
		m.ResetUserID()
		return nil
	case userprogress.FieldCourseID:
		m.ResetCourseID()
		return nil
	case userprogress.FieldUnitID:
		m.ResetUnitID()
		return nil
	case userprogress.FieldLessonID:
		m.ResetLessonID()
		return nil
	case userprogress.FieldLessonType:
		m.ResetLessonType()
		return nil
	case userprogress.FieldIsLast:
		m.ResetIsLast()
		return nil
	case userprogress.FieldIsNext:
		m.ResetIsNext()
		return nil
	case userprogress.FieldProgress:
		m.ResetProgress()
		return nil
	case userprogress.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case userprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, userprogress.EdgeUser)
	}
	if m.course != nil {
		edges = append(edges, userprogress.EdgeCourse)
	}
	if m.unit != nil {
		edges = append(edges, userprogress.EdgeUnit)
	}
	if m.lesson != nil {
		edges = append(edges, userprogress.EdgeLesson)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprogress.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userprogress.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case userprogress.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case userprogress.EdgeLesson:
		if id := m.lesson; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, userprogress.EdgeUser)
	}
	if m.clearedcourse {
		edges = append(edges, userprogress.EdgeCourse)
	}
	if m.clearedunit {
		edges = append(edges, userprogress.EdgeUnit)
	}
	if m.clearedlesson {
		edges = append(edges, userprogress.EdgeLesson)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case userprogress.EdgeUser:
		return m.cleareduser
	case userprogress.EdgeCourse:
		return m.clearedcourse
	case userprogress.EdgeUnit:
		return m.clearedunit
	case userprogress.EdgeLesson:
		return m.clearedlesson
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProgressMutation) ClearEdge(name string) error {
	switch name {
	case userprogress.EdgeUser:
		m.ClearUser()
		return nil
	case userprogress.EdgeCourse:
		m.ClearCourse()
		return nil
	case userprogress.EdgeUnit:
		m.ClearUnit()
		return nil
	case userprogress.EdgeLesson:
		m.ClearLesson()
		return nil
	}
	return fmt.Errorf("unknown UserProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProgressMutation) ResetEdge(name string) error {
	switch name {
	case userprogress.EdgeUser:
		m.ResetUser()
		return nil
	case userprogress.EdgeCourse:
		m.ResetCourse()
		return nil
	case userprogress.EdgeUnit:
		m.ResetUnit()
		return nil
	case userprogress.EdgeLesson:
		m.ResetLesson()
		return nil
	}
	return fmt.Errorf("unknown UserProgress edge %s", name)
}
