// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/jhana-app/jhana-app/ent/content"
	"github.com/jhana-app/jhana-app/ent/contentepisode"
	"github.com/jhana-app/jhana-app/ent/contentprogress"
	"github.com/jhana-app/jhana-app/ent/course"
	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/journalrecord"
	"github.com/jhana-app/jhana-app/ent/lesson"
	"github.com/jhana-app/jhana-app/ent/lessonaudio"
	"github.com/jhana-app/jhana-app/ent/technique"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/ent/user"
	"github.com/jhana-app/jhana-app/ent/userprogress"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContentQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ContentQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(content.Columns))
		selectedFields = []string{content.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "episodes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContentEpisodeClient{config: c.config}).Query()
			)
			args := newContentEpisodePaginateArgs(fieldArgs(ctx, new(ContentEpisodeWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newContentEpisodePager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					c.loadTotal = append(c.loadTotal, func(ctx context.Context, nodes []*Content) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID gqlid.ContentID `sql:"content_id"`
							Count  int             `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(content.EpisodesColumn), ids...))
						})
						if err := query.GroupBy(content.EpisodesColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[gqlid.ContentID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					c.loadTotal = append(c.loadTotal, func(_ context.Context, nodes []*Content) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Episodes)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, contentepisodeImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(content.EpisodesColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			c.WithNamedEpisodes(alias, func(wq *ContentEpisodeQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[content.FieldType]; !ok {
				selectedFields = append(selectedFields, content.FieldType)
				fieldSeen[content.FieldType] = struct{}{}
			}
		case "iconimage":
			if _, ok := fieldSeen[content.FieldIconImage]; !ok {
				selectedFields = append(selectedFields, content.FieldIconImage)
				fieldSeen[content.FieldIconImage] = struct{}{}
			}
		case "coverimage":
			if _, ok := fieldSeen[content.FieldCoverImage]; !ok {
				selectedFields = append(selectedFields, content.FieldCoverImage)
				fieldSeen[content.FieldCoverImage] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[content.FieldTitle]; !ok {
				selectedFields = append(selectedFields, content.FieldTitle)
				fieldSeen[content.FieldTitle] = struct{}{}
			}
		case "subtitle":
			if _, ok := fieldSeen[content.FieldSubtitle]; !ok {
				selectedFields = append(selectedFields, content.FieldSubtitle)
				fieldSeen[content.FieldSubtitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[content.FieldDescription]; !ok {
				selectedFields = append(selectedFields, content.FieldDescription)
				fieldSeen[content.FieldDescription] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[content.FieldSource]; !ok {
				selectedFields = append(selectedFields, content.FieldSource)
				fieldSeen[content.FieldSource] = struct{}{}
			}
		case "sourceurl":
			if _, ok := fieldSeen[content.FieldSourceURL]; !ok {
				selectedFields = append(selectedFields, content.FieldSourceURL)
				fieldSeen[content.FieldSourceURL] = struct{}{}
			}
		case "licence":
			if _, ok := fieldSeen[content.FieldLicence]; !ok {
				selectedFields = append(selectedFields, content.FieldLicence)
				fieldSeen[content.FieldLicence] = struct{}{}
			}
		case "licenceurl":
			if _, ok := fieldSeen[content.FieldLicenceURL]; !ok {
				selectedFields = append(selectedFields, content.FieldLicenceURL)
				fieldSeen[content.FieldLicenceURL] = struct{}{}
			}
		case "ishidden":
			if _, ok := fieldSeen[content.FieldIsHidden]; !ok {
				selectedFields = append(selectedFields, content.FieldIsHidden)
				fieldSeen[content.FieldIsHidden] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[content.FieldOrder]; !ok {
				selectedFields = append(selectedFields, content.FieldOrder)
				fieldSeen[content.FieldOrder] = struct{}{}
			}
		case "episodescount":
			if _, ok := fieldSeen[content.FieldEpisodesCount]; !ok {
				selectedFields = append(selectedFields, content.FieldEpisodesCount)
				fieldSeen[content.FieldEpisodesCount] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type contentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContentPaginateOption
}

func newContentPaginateArgs(rv map[string]any) *contentPaginateArgs {
	args := &contentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ContentOrder{Field: &ContentOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithContentOrder(order))
			}
		case *ContentOrder:
			if v != nil {
				args.opts = append(args.opts, WithContentOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ContentWhereInput); ok {
		args.opts = append(args.opts, WithContentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ce *ContentEpisodeQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContentEpisodeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ce, nil
	}
	if err := ce.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ce, nil
}

func (ce *ContentEpisodeQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contentepisode.Columns))
		selectedFields = []string{contentepisode.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "content":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContentClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, contentImplementors)...); err != nil {
				return err
			}
			ce.withContent = query
			if _, ok := fieldSeen[contentepisode.FieldContentID]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldContentID)
				fieldSeen[contentepisode.FieldContentID] = struct{}{}
			}
		case "contentID":
			if _, ok := fieldSeen[contentepisode.FieldContentID]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldContentID)
				fieldSeen[contentepisode.FieldContentID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[contentepisode.FieldType]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldType)
				fieldSeen[contentepisode.FieldType] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[contentepisode.FieldTitle]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldTitle)
				fieldSeen[contentepisode.FieldTitle] = struct{}{}
			}
		case "subtitle":
			if _, ok := fieldSeen[contentepisode.FieldSubtitle]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldSubtitle)
				fieldSeen[contentepisode.FieldSubtitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[contentepisode.FieldDescription]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldDescription)
				fieldSeen[contentepisode.FieldDescription] = struct{}{}
			}
		case "duration":
			if _, ok := fieldSeen[contentepisode.FieldDuration]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldDuration)
				fieldSeen[contentepisode.FieldDuration] = struct{}{}
			}
		case "streamurl":
			if _, ok := fieldSeen[contentepisode.FieldStreamURL]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldStreamURL)
				fieldSeen[contentepisode.FieldStreamURL] = struct{}{}
			}
		case "downloadurl":
			if _, ok := fieldSeen[contentepisode.FieldDownloadURL]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldDownloadURL)
				fieldSeen[contentepisode.FieldDownloadURL] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[contentepisode.FieldSource]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldSource)
				fieldSeen[contentepisode.FieldSource] = struct{}{}
			}
		case "sourceurl":
			if _, ok := fieldSeen[contentepisode.FieldSourceURL]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldSourceURL)
				fieldSeen[contentepisode.FieldSourceURL] = struct{}{}
			}
		case "licence":
			if _, ok := fieldSeen[contentepisode.FieldLicence]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldLicence)
				fieldSeen[contentepisode.FieldLicence] = struct{}{}
			}
		case "licenceurl":
			if _, ok := fieldSeen[contentepisode.FieldLicenceURL]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldLicenceURL)
				fieldSeen[contentepisode.FieldLicenceURL] = struct{}{}
			}
		case "ishidden":
			if _, ok := fieldSeen[contentepisode.FieldIsHidden]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldIsHidden)
				fieldSeen[contentepisode.FieldIsHidden] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[contentepisode.FieldOrder]; !ok {
				selectedFields = append(selectedFields, contentepisode.FieldOrder)
				fieldSeen[contentepisode.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ce.Select(selectedFields...)
	}
	return nil
}

type contentepisodePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContentEpisodePaginateOption
}

func newContentEpisodePaginateArgs(rv map[string]any) *contentepisodePaginateArgs {
	args := &contentepisodePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ContentEpisodeOrder{Field: &ContentEpisodeOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithContentEpisodeOrder(order))
			}
		case *ContentEpisodeOrder:
			if v != nil {
				args.opts = append(args.opts, WithContentEpisodeOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ContentEpisodeWhereInput); ok {
		args.opts = append(args.opts, WithContentEpisodeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cp *ContentProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContentProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cp, nil
	}
	if err := cp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cp, nil
}

func (cp *ContentProgressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contentprogress.Columns))
		selectedFields = []string{contentprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			cp.withUser = query
			if _, ok := fieldSeen[contentprogress.FieldUserID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldUserID)
				fieldSeen[contentprogress.FieldUserID] = struct{}{}
			}

		case "content":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContentClient{config: cp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, contentImplementors)...); err != nil {
				return err
			}
			cp.withContent = query
			if _, ok := fieldSeen[contentprogress.FieldContentID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldContentID)
				fieldSeen[contentprogress.FieldContentID] = struct{}{}
			}

		case "episode":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContentEpisodeClient{config: cp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, contentepisodeImplementors)...); err != nil {
				return err
			}
			cp.withEpisode = query
			if _, ok := fieldSeen[contentprogress.FieldEpisodeID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldEpisodeID)
				fieldSeen[contentprogress.FieldEpisodeID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[contentprogress.FieldUserID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldUserID)
				fieldSeen[contentprogress.FieldUserID] = struct{}{}
			}
		case "contentID":
			if _, ok := fieldSeen[contentprogress.FieldContentID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldContentID)
				fieldSeen[contentprogress.FieldContentID] = struct{}{}
			}
		case "episodeID":
			if _, ok := fieldSeen[contentprogress.FieldEpisodeID]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldEpisodeID)
				fieldSeen[contentprogress.FieldEpisodeID] = struct{}{}
			}
		case "contentType":
			if _, ok := fieldSeen[contentprogress.FieldContentType]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldContentType)
				fieldSeen[contentprogress.FieldContentType] = struct{}{}
			}
		case "progress":
			if _, ok := fieldSeen[contentprogress.FieldProgress]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldProgress)
				fieldSeen[contentprogress.FieldProgress] = struct{}{}
			}
		case "finishedat":
			if _, ok := fieldSeen[contentprogress.FieldFinishedAt]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldFinishedAt)
				fieldSeen[contentprogress.FieldFinishedAt] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[contentprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldCreatedAt)
				fieldSeen[contentprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[contentprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contentprogress.FieldUpdatedAt)
				fieldSeen[contentprogress.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cp.Select(selectedFields...)
	}
	return nil
}

type contentprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContentProgressPaginateOption
}

func newContentProgressPaginateArgs(rv map[string]any) *contentprogressPaginateArgs {
	args := &contentprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContentProgressWhereInput); ok {
		args.opts = append(args.opts, WithContentProgressFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CourseQuery) CollectFields(ctx context.Context, satisfies ...string) (*CourseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CourseQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(course.Columns))
		selectedFields = []string{course.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "units":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UnitClient{config: c.config}).Query()
			)
			args := newUnitPaginateArgs(fieldArgs(ctx, new(UnitWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newUnitPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					c.loadTotal = append(c.loadTotal, func(ctx context.Context, nodes []*Course) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID gqlid.CourseID `sql:"course_id"`
							Count  int            `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(course.UnitsColumn), ids...))
						})
						if err := query.GroupBy(course.UnitsColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[gqlid.CourseID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					c.loadTotal = append(c.loadTotal, func(_ context.Context, nodes []*Course) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Units)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, unitImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(course.UnitsColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			c.WithNamedUnits(alias, func(wq *UnitQuery) {
				*wq = *query
			})
		case "iconimage":
			if _, ok := fieldSeen[course.FieldIconImage]; !ok {
				selectedFields = append(selectedFields, course.FieldIconImage)
				fieldSeen[course.FieldIconImage] = struct{}{}
			}
		case "coverimage":
			if _, ok := fieldSeen[course.FieldCoverImage]; !ok {
				selectedFields = append(selectedFields, course.FieldCoverImage)
				fieldSeen[course.FieldCoverImage] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[course.FieldTitle]; !ok {
				selectedFields = append(selectedFields, course.FieldTitle)
				fieldSeen[course.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[course.FieldDescription]; !ok {
				selectedFields = append(selectedFields, course.FieldDescription)
				fieldSeen[course.FieldDescription] = struct{}{}
			}
		case "color":
			if _, ok := fieldSeen[course.FieldColor]; !ok {
				selectedFields = append(selectedFields, course.FieldColor)
				fieldSeen[course.FieldColor] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[course.FieldActive]; !ok {
				selectedFields = append(selectedFields, course.FieldActive)
				fieldSeen[course.FieldActive] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[course.FieldOrder]; !ok {
				selectedFields = append(selectedFields, course.FieldOrder)
				fieldSeen[course.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type coursePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CoursePaginateOption
}

func newCoursePaginateArgs(rv map[string]any) *coursePaginateArgs {
	args := &coursePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &CourseOrder{Field: &CourseOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCourseOrder(order))
			}
		case *CourseOrder:
			if v != nil {
				args.opts = append(args.opts, WithCourseOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*CourseWhereInput); ok {
		args.opts = append(args.opts, WithCourseFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jr *JournalRecordQuery) CollectFields(ctx context.Context, satisfies ...string) (*JournalRecordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jr, nil
	}
	if err := jr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jr, nil
}

func (jr *JournalRecordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(journalrecord.Columns))
		selectedFields = []string{journalrecord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			jr.withUser = query
			if _, ok := fieldSeen[journalrecord.FieldUserID]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldUserID)
				fieldSeen[journalrecord.FieldUserID] = struct{}{}
			}

		case "lesson":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LessonClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, lessonImplementors)...); err != nil {
				return err
			}
			jr.withLesson = query
			if _, ok := fieldSeen[journalrecord.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldLessonID)
				fieldSeen[journalrecord.FieldLessonID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[journalrecord.FieldUserID]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldUserID)
				fieldSeen[journalrecord.FieldUserID] = struct{}{}
			}
		case "lessonID":
			if _, ok := fieldSeen[journalrecord.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldLessonID)
				fieldSeen[journalrecord.FieldLessonID] = struct{}{}
			}
		case "datetime":
			if _, ok := fieldSeen[journalrecord.FieldDateTime]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldDateTime)
				fieldSeen[journalrecord.FieldDateTime] = struct{}{}
			}
		case "duration":
			if _, ok := fieldSeen[journalrecord.FieldDuration]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldDuration)
				fieldSeen[journalrecord.FieldDuration] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[journalrecord.FieldNote]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldNote)
				fieldSeen[journalrecord.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[journalrecord.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldCreatedAt)
				fieldSeen[journalrecord.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[journalrecord.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, journalrecord.FieldUpdatedAt)
				fieldSeen[journalrecord.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jr.Select(selectedFields...)
	}
	return nil
}

type journalrecordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JournalRecordPaginateOption
}

func newJournalRecordPaginateArgs(rv map[string]any) *journalrecordPaginateArgs {
	args := &journalrecordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JournalRecordOrder{Field: &JournalRecordOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJournalRecordOrder(order))
			}
		case *JournalRecordOrder:
			if v != nil {
				args.opts = append(args.opts, WithJournalRecordOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JournalRecordWhereInput); ok {
		args.opts = append(args.opts, WithJournalRecordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LessonQuery) CollectFields(ctx context.Context, satisfies ...string) (*LessonQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LessonQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(lesson.Columns))
		selectedFields = []string{lesson.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "unit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UnitClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, unitImplementors)...); err != nil {
				return err
			}
			l.withUnit = query
			if _, ok := fieldSeen[lesson.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, lesson.FieldUnitID)
				fieldSeen[lesson.FieldUnitID] = struct{}{}
			}
		case "unitID":
			if _, ok := fieldSeen[lesson.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, lesson.FieldUnitID)
				fieldSeen[lesson.FieldUnitID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[lesson.FieldType]; !ok {
				selectedFields = append(selectedFields, lesson.FieldType)
				fieldSeen[lesson.FieldType] = struct{}{}
			}
		case "iconimage":
			if _, ok := fieldSeen[lesson.FieldIconImage]; !ok {
				selectedFields = append(selectedFields, lesson.FieldIconImage)
				fieldSeen[lesson.FieldIconImage] = struct{}{}
			}
		case "coverimage":
			if _, ok := fieldSeen[lesson.FieldCoverImage]; !ok {
				selectedFields = append(selectedFields, lesson.FieldCoverImage)
				fieldSeen[lesson.FieldCoverImage] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[lesson.FieldTitle]; !ok {
				selectedFields = append(selectedFields, lesson.FieldTitle)
				fieldSeen[lesson.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[lesson.FieldDescription]; !ok {
				selectedFields = append(selectedFields, lesson.FieldDescription)
				fieldSeen[lesson.FieldDescription] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[lesson.FieldOrder]; !ok {
				selectedFields = append(selectedFields, lesson.FieldOrder)
				fieldSeen[lesson.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type lessonPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LessonPaginateOption
}

func newLessonPaginateArgs(rv map[string]any) *lessonPaginateArgs {
	args := &lessonPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &LessonOrder{Field: &LessonOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithLessonOrder(order))
			}
		case *LessonOrder:
			if v != nil {
				args.opts = append(args.opts, WithLessonOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*LessonWhereInput); ok {
		args.opts = append(args.opts, WithLessonFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (la *LessonAudioQuery) CollectFields(ctx context.Context, satisfies ...string) (*LessonAudioQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return la, nil
	}
	if err := la.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return la, nil
}

func (la *LessonAudioQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(lessonaudio.Columns))
		selectedFields = []string{lessonaudio.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "lesson":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LessonClient{config: la.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, lessonImplementors)...); err != nil {
				return err
			}
			la.withLesson = query
			if _, ok := fieldSeen[lessonaudio.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, lessonaudio.FieldLessonID)
				fieldSeen[lessonaudio.FieldLessonID] = struct{}{}
			}
		case "lessonID":
			if _, ok := fieldSeen[lessonaudio.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, lessonaudio.FieldLessonID)
				fieldSeen[lessonaudio.FieldLessonID] = struct{}{}
			}
		case "audiourl":
			if _, ok := fieldSeen[lessonaudio.FieldAudioURL]; !ok {
				selectedFields = append(selectedFields, lessonaudio.FieldAudioURL)
				fieldSeen[lessonaudio.FieldAudioURL] = struct{}{}
			}
		case "duration":
			if _, ok := fieldSeen[lessonaudio.FieldDuration]; !ok {
				selectedFields = append(selectedFields, lessonaudio.FieldDuration)
				fieldSeen[lessonaudio.FieldDuration] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		la.Select(selectedFields...)
	}
	return nil
}

type lessonaudioPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LessonAudioPaginateOption
}

func newLessonAudioPaginateArgs(rv map[string]any) *lessonaudioPaginateArgs {
	args := &lessonaudioPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &LessonAudioOrder{Field: &LessonAudioOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithLessonAudioOrder(order))
			}
		case *LessonAudioOrder:
			if v != nil {
				args.opts = append(args.opts, WithLessonAudioOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*LessonAudioWhereInput); ok {
		args.opts = append(args.opts, WithLessonAudioFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TechniqueQuery) CollectFields(ctx context.Context, satisfies ...string) (*TechniqueQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TechniqueQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(technique.Columns))
		selectedFields = []string{technique.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "unit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UnitClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, unitImplementors)...); err != nil {
				return err
			}
			t.withUnit = query
			if _, ok := fieldSeen[technique.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, technique.FieldUnitID)
				fieldSeen[technique.FieldUnitID] = struct{}{}
			}

		case "lessons":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LessonClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, lessonImplementors)...); err != nil {
				return err
			}
			t.WithNamedLessons(alias, func(wq *LessonQuery) {
				*wq = *query
			})

		case "techniques":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UnitClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, unitImplementors)...); err != nil {
				return err
			}
			t.WithNamedTechniques(alias, func(wq *UnitQuery) {
				*wq = *query
			})
		case "unitID":
			if _, ok := fieldSeen[technique.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, technique.FieldUnitID)
				fieldSeen[technique.FieldUnitID] = struct{}{}
			}
		case "iconimage":
			if _, ok := fieldSeen[technique.FieldIconImage]; !ok {
				selectedFields = append(selectedFields, technique.FieldIconImage)
				fieldSeen[technique.FieldIconImage] = struct{}{}
			}
		case "coverimage":
			if _, ok := fieldSeen[technique.FieldCoverImage]; !ok {
				selectedFields = append(selectedFields, technique.FieldCoverImage)
				fieldSeen[technique.FieldCoverImage] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[technique.FieldTitle]; !ok {
				selectedFields = append(selectedFields, technique.FieldTitle)
				fieldSeen[technique.FieldTitle] = struct{}{}
			}
		case "subtitle":
			if _, ok := fieldSeen[technique.FieldSubtitle]; !ok {
				selectedFields = append(selectedFields, technique.FieldSubtitle)
				fieldSeen[technique.FieldSubtitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[technique.FieldDescription]; !ok {
				selectedFields = append(selectedFields, technique.FieldDescription)
				fieldSeen[technique.FieldDescription] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[technique.FieldOrder]; !ok {
				selectedFields = append(selectedFields, technique.FieldOrder)
				fieldSeen[technique.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type techniquePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TechniquePaginateOption
}

func newTechniquePaginateArgs(rv map[string]any) *techniquePaginateArgs {
	args := &techniquePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TechniqueOrder{Field: &TechniqueOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTechniqueOrder(order))
			}
		case *TechniqueOrder:
			if v != nil {
				args.opts = append(args.opts, WithTechniqueOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TechniqueWhereInput); ok {
		args.opts = append(args.opts, WithTechniqueFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UnitQuery) CollectFields(ctx context.Context, satisfies ...string) (*UnitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UnitQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(unit.Columns))
		selectedFields = []string{unit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "course":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CourseClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, courseImplementors)...); err != nil {
				return err
			}
			u.withCourse = query
			if _, ok := fieldSeen[unit.FieldCourseID]; !ok {
				selectedFields = append(selectedFields, unit.FieldCourseID)
				fieldSeen[unit.FieldCourseID] = struct{}{}
			}

		case "lessons":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LessonClient{config: u.config}).Query()
			)
			args := newLessonPaginateArgs(fieldArgs(ctx, new(LessonWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newLessonPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					u.loadTotal = append(u.loadTotal, func(ctx context.Context, nodes []*Unit) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID gqlid.UnitID `sql:"unit_id"`
							Count  int          `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(unit.LessonsColumn), ids...))
						})
						if err := query.GroupBy(unit.LessonsColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[gqlid.UnitID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				} else {
					u.loadTotal = append(u.loadTotal, func(_ context.Context, nodes []*Unit) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Lessons)
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, lessonImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(unit.LessonsColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			u.WithNamedLessons(alias, func(wq *LessonQuery) {
				*wq = *query
			})
		case "courseID":
			if _, ok := fieldSeen[unit.FieldCourseID]; !ok {
				selectedFields = append(selectedFields, unit.FieldCourseID)
				fieldSeen[unit.FieldCourseID] = struct{}{}
			}
		case "iconimage":
			if _, ok := fieldSeen[unit.FieldIconImage]; !ok {
				selectedFields = append(selectedFields, unit.FieldIconImage)
				fieldSeen[unit.FieldIconImage] = struct{}{}
			}
		case "coverimage":
			if _, ok := fieldSeen[unit.FieldCoverImage]; !ok {
				selectedFields = append(selectedFields, unit.FieldCoverImage)
				fieldSeen[unit.FieldCoverImage] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[unit.FieldTitle]; !ok {
				selectedFields = append(selectedFields, unit.FieldTitle)
				fieldSeen[unit.FieldTitle] = struct{}{}
			}
		case "subtitle":
			if _, ok := fieldSeen[unit.FieldSubtitle]; !ok {
				selectedFields = append(selectedFields, unit.FieldSubtitle)
				fieldSeen[unit.FieldSubtitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[unit.FieldDescription]; !ok {
				selectedFields = append(selectedFields, unit.FieldDescription)
				fieldSeen[unit.FieldDescription] = struct{}{}
			}
		case "mastering":
			if _, ok := fieldSeen[unit.FieldMastering]; !ok {
				selectedFields = append(selectedFields, unit.FieldMastering)
				fieldSeen[unit.FieldMastering] = struct{}{}
			}
		case "days":
			if _, ok := fieldSeen[unit.FieldDays]; !ok {
				selectedFields = append(selectedFields, unit.FieldDays)
				fieldSeen[unit.FieldDays] = struct{}{}
			}
		case "color":
			if _, ok := fieldSeen[unit.FieldColor]; !ok {
				selectedFields = append(selectedFields, unit.FieldColor)
				fieldSeen[unit.FieldColor] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[unit.FieldOrder]; !ok {
				selectedFields = append(selectedFields, unit.FieldOrder)
				fieldSeen[unit.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type unitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UnitPaginateOption
}

func newUnitPaginateArgs(rv map[string]any) *unitPaginateArgs {
	args := &unitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UnitOrder{Field: &UnitOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUnitOrder(order))
			}
		case *UnitOrder:
			if v != nil {
				args.opts = append(args.opts, WithUnitOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UnitWhereInput); ok {
		args.opts = append(args.opts, WithUnitFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "firebaseuid":
			if _, ok := fieldSeen[user.FieldFirebaseUid]; !ok {
				selectedFields = append(selectedFields, user.FieldFirebaseUid)
				fieldSeen[user.FieldFirebaseUid] = struct{}{}
			}
		case "displayname":
			if _, ok := fieldSeen[user.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, user.FieldDisplayName)
				fieldSeen[user.FieldDisplayName] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "authMethod":
			if _, ok := fieldSeen[user.FieldAuthMethod]; !ok {
				selectedFields = append(selectedFields, user.FieldAuthMethod)
				fieldSeen[user.FieldAuthMethod] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "emailVerified":
			if _, ok := fieldSeen[user.FieldEmailVerified]; !ok {
				selectedFields = append(selectedFields, user.FieldEmailVerified)
				fieldSeen[user.FieldEmailVerified] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (up *UserProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return up, nil
	}
	if err := up.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return up, nil
}

func (up *UserProgressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userprogress.Columns))
		selectedFields = []string{userprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: up.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			up.withUser = query
			if _, ok := fieldSeen[userprogress.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldUserID)
				fieldSeen[userprogress.FieldUserID] = struct{}{}
			}

		case "course":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CourseClient{config: up.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, courseImplementors)...); err != nil {
				return err
			}
			up.withCourse = query
			if _, ok := fieldSeen[userprogress.FieldCourseID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldCourseID)
				fieldSeen[userprogress.FieldCourseID] = struct{}{}
			}

		case "unit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UnitClient{config: up.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, unitImplementors)...); err != nil {
				return err
			}
			up.withUnit = query
			if _, ok := fieldSeen[userprogress.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldUnitID)
				fieldSeen[userprogress.FieldUnitID] = struct{}{}
			}

		case "lesson":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LessonClient{config: up.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, lessonImplementors)...); err != nil {
				return err
			}
			up.withLesson = query
			if _, ok := fieldSeen[userprogress.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldLessonID)
				fieldSeen[userprogress.FieldLessonID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[userprogress.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldUserID)
				fieldSeen[userprogress.FieldUserID] = struct{}{}
			}
		case "courseID":
			if _, ok := fieldSeen[userprogress.FieldCourseID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldCourseID)
				fieldSeen[userprogress.FieldCourseID] = struct{}{}
			}
		case "unitID":
			if _, ok := fieldSeen[userprogress.FieldUnitID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldUnitID)
				fieldSeen[userprogress.FieldUnitID] = struct{}{}
			}
		case "lessonID":
			if _, ok := fieldSeen[userprogress.FieldLessonID]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldLessonID)
				fieldSeen[userprogress.FieldLessonID] = struct{}{}
			}
		case "lessonType":
			if _, ok := fieldSeen[userprogress.FieldLessonType]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldLessonType)
				fieldSeen[userprogress.FieldLessonType] = struct{}{}
			}
		case "islast":
			if _, ok := fieldSeen[userprogress.FieldIsLast]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldIsLast)
				fieldSeen[userprogress.FieldIsLast] = struct{}{}
			}
		case "isnext":
			if _, ok := fieldSeen[userprogress.FieldIsNext]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldIsNext)
				fieldSeen[userprogress.FieldIsNext] = struct{}{}
			}
		case "progress":
			if _, ok := fieldSeen[userprogress.FieldProgress]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldProgress)
				fieldSeen[userprogress.FieldProgress] = struct{}{}
			}
		case "finishedat":
			if _, ok := fieldSeen[userprogress.FieldFinishedAt]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldFinishedAt)
				fieldSeen[userprogress.FieldFinishedAt] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[userprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldCreatedAt)
				fieldSeen[userprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[userprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, userprogress.FieldUpdatedAt)
				fieldSeen[userprogress.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		up.Select(selectedFields...)
	}
	return nil
}

type userprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserProgressPaginateOption
}

func newUserProgressPaginateArgs(rv map[string]any) *userprogressPaginateArgs {
	args := &userprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserProgressOrder{Field: &UserProgressOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserProgressOrder(order))
			}
		case *UserProgressOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserProgressOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserProgressWhereInput); ok {
		args.opts = append(args.opts, WithUserProgressFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
