// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/jhana-app/jhana-app/ent/gqlid"
	"github.com/jhana-app/jhana-app/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/jhana-app/jhana-app/ent/authtoken"
	"github.com/jhana-app/jhana-app/ent/content"
	"github.com/jhana-app/jhana-app/ent/contentepisode"
	"github.com/jhana-app/jhana-app/ent/contentprogress"
	"github.com/jhana-app/jhana-app/ent/course"
	"github.com/jhana-app/jhana-app/ent/journalrecord"
	"github.com/jhana-app/jhana-app/ent/lesson"
	"github.com/jhana-app/jhana-app/ent/lessonaudio"
	"github.com/jhana-app/jhana-app/ent/lessontechnique"
	"github.com/jhana-app/jhana-app/ent/technique"
	"github.com/jhana-app/jhana-app/ent/unit"
	"github.com/jhana-app/jhana-app/ent/unittechnique"
	"github.com/jhana-app/jhana-app/ent/user"
	"github.com/jhana-app/jhana-app/ent/userprogress"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthToken is the client for interacting with the AuthToken builders.
	AuthToken *AuthTokenClient
	// Content is the client for interacting with the Content builders.
	Content *ContentClient
	// ContentEpisode is the client for interacting with the ContentEpisode builders.
	ContentEpisode *ContentEpisodeClient
	// ContentProgress is the client for interacting with the ContentProgress builders.
	ContentProgress *ContentProgressClient
	// Course is the client for interacting with the Course builders.
	Course *CourseClient
	// JournalRecord is the client for interacting with the JournalRecord builders.
	JournalRecord *JournalRecordClient
	// Lesson is the client for interacting with the Lesson builders.
	Lesson *LessonClient
	// LessonAudio is the client for interacting with the LessonAudio builders.
	LessonAudio *LessonAudioClient
	// LessonTechnique is the client for interacting with the LessonTechnique builders.
	LessonTechnique *LessonTechniqueClient
	// Technique is the client for interacting with the Technique builders.
	Technique *TechniqueClient
	// Unit is the client for interacting with the Unit builders.
	Unit *UnitClient
	// UnitTechnique is the client for interacting with the UnitTechnique builders.
	UnitTechnique *UnitTechniqueClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserProgress is the client for interacting with the UserProgress builders.
	UserProgress *UserProgressClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthToken = NewAuthTokenClient(c.config)
	c.Content = NewContentClient(c.config)
	c.ContentEpisode = NewContentEpisodeClient(c.config)
	c.ContentProgress = NewContentProgressClient(c.config)
	c.Course = NewCourseClient(c.config)
	c.JournalRecord = NewJournalRecordClient(c.config)
	c.Lesson = NewLessonClient(c.config)
	c.LessonAudio = NewLessonAudioClient(c.config)
	c.LessonTechnique = NewLessonTechniqueClient(c.config)
	c.Technique = NewTechniqueClient(c.config)
	c.Unit = NewUnitClient(c.config)
	c.UnitTechnique = NewUnitTechniqueClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserProgress = NewUserProgressClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AuthToken:       NewAuthTokenClient(cfg),
		Content:         NewContentClient(cfg),
		ContentEpisode:  NewContentEpisodeClient(cfg),
		ContentProgress: NewContentProgressClient(cfg),
		Course:          NewCourseClient(cfg),
		JournalRecord:   NewJournalRecordClient(cfg),
		Lesson:          NewLessonClient(cfg),
		LessonAudio:     NewLessonAudioClient(cfg),
		LessonTechnique: NewLessonTechniqueClient(cfg),
		Technique:       NewTechniqueClient(cfg),
		Unit:            NewUnitClient(cfg),
		UnitTechnique:   NewUnitTechniqueClient(cfg),
		User:            NewUserClient(cfg),
		UserProgress:    NewUserProgressClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AuthToken:       NewAuthTokenClient(cfg),
		Content:         NewContentClient(cfg),
		ContentEpisode:  NewContentEpisodeClient(cfg),
		ContentProgress: NewContentProgressClient(cfg),
		Course:          NewCourseClient(cfg),
		JournalRecord:   NewJournalRecordClient(cfg),
		Lesson:          NewLessonClient(cfg),
		LessonAudio:     NewLessonAudioClient(cfg),
		LessonTechnique: NewLessonTechniqueClient(cfg),
		Technique:       NewTechniqueClient(cfg),
		Unit:            NewUnitClient(cfg),
		UnitTechnique:   NewUnitTechniqueClient(cfg),
		User:            NewUserClient(cfg),
		UserProgress:    NewUserProgressClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuthToken, c.Content, c.ContentEpisode, c.ContentProgress, c.Course,
		c.JournalRecord, c.Lesson, c.LessonAudio, c.LessonTechnique, c.Technique,
		c.Unit, c.UnitTechnique, c.User, c.UserProgress,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuthToken, c.Content, c.ContentEpisode, c.ContentProgress, c.Course,
		c.JournalRecord, c.Lesson, c.LessonAudio, c.LessonTechnique, c.Technique,
		c.Unit, c.UnitTechnique, c.User, c.UserProgress,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthTokenMutation:
		return c.AuthToken.mutate(ctx, m)
	case *ContentMutation:
		return c.Content.mutate(ctx, m)
	case *ContentEpisodeMutation:
		return c.ContentEpisode.mutate(ctx, m)
	case *ContentProgressMutation:
		return c.ContentProgress.mutate(ctx, m)
	case *CourseMutation:
		return c.Course.mutate(ctx, m)
	case *JournalRecordMutation:
		return c.JournalRecord.mutate(ctx, m)
	case *LessonMutation:
		return c.Lesson.mutate(ctx, m)
	case *LessonAudioMutation:
		return c.LessonAudio.mutate(ctx, m)
	case *LessonTechniqueMutation:
		return c.LessonTechnique.mutate(ctx, m)
	case *TechniqueMutation:
		return c.Technique.mutate(ctx, m)
	case *UnitMutation:
		return c.Unit.mutate(ctx, m)
	case *UnitTechniqueMutation:
		return c.UnitTechnique.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserProgressMutation:
		return c.UserProgress.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthTokenClient is a client for the AuthToken schema.
type AuthTokenClient struct {
	config
}

// NewAuthTokenClient returns a client for the AuthToken from the given config.
func NewAuthTokenClient(c config) *AuthTokenClient {
	return &AuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtoken.Hooks(f(g(h())))`.
func (c *AuthTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthToken = append(c.hooks.AuthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authtoken.Intercept(f(g(h())))`.
func (c *AuthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthToken = append(c.inters.AuthToken, interceptors...)
}

// Create returns a builder for creating a AuthToken entity.
func (c *AuthTokenClient) Create() *AuthTokenCreate {
	mutation := newAuthTokenMutation(c.config, OpCreate)
	return &AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthToken entities.
func (c *AuthTokenClient) CreateBulk(builders ...*AuthTokenCreate) *AuthTokenCreateBulk {
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthTokenClient) MapCreateBulk(slice any, setFunc func(*AuthTokenCreate, int)) *AuthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthTokenCreateBulk{err: fmt.Errorf("calling to AuthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthToken.
func (c *AuthTokenClient) Update() *AuthTokenUpdate {
	mutation := newAuthTokenMutation(c.config, OpUpdate)
	return &AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTokenClient) UpdateOne(at *AuthToken) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthToken(at))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTokenClient) UpdateOneID(id gqlid.AuthTokenID) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthTokenID(id))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthToken.
func (c *AuthTokenClient) Delete() *AuthTokenDelete {
	mutation := newAuthTokenMutation(c.config, OpDelete)
	return &AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthTokenClient) DeleteOne(at *AuthToken) *AuthTokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthTokenClient) DeleteOneID(id gqlid.AuthTokenID) *AuthTokenDeleteOne {
	builder := c.Delete().Where(authtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTokenDeleteOne{builder}
}

// Query returns a query builder for AuthToken.
func (c *AuthTokenClient) Query() *AuthTokenQuery {
	return &AuthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthToken entity by its id.
func (c *AuthTokenClient) Get(ctx context.Context, id gqlid.AuthTokenID) (*AuthToken, error) {
	return c.Query().Where(authtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTokenClient) GetX(ctx context.Context, id gqlid.AuthTokenID) *AuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AuthToken.
func (c *AuthTokenClient) QueryUser(at *AuthToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authtoken.Table, authtoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, authtoken.UserTable, authtoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthTokenClient) Hooks() []Hook {
	return c.hooks.AuthToken
}

// Interceptors returns the client interceptors.
func (c *AuthTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthToken
}

func (c *AuthTokenClient) mutate(ctx context.Context, m *AuthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthToken mutation op: %q", m.Op())
	}
}

// ContentClient is a client for the Content schema.
type ContentClient struct {
	config
}

// NewContentClient returns a client for the Content from the given config.
func NewContentClient(c config) *ContentClient {
	return &ContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `content.Hooks(f(g(h())))`.
func (c *ContentClient) Use(hooks ...Hook) {
	c.hooks.Content = append(c.hooks.Content, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `content.Intercept(f(g(h())))`.
func (c *ContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Content = append(c.inters.Content, interceptors...)
}

// Create returns a builder for creating a Content entity.
func (c *ContentClient) Create() *ContentCreate {
	mutation := newContentMutation(c.config, OpCreate)
	return &ContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Content entities.
func (c *ContentClient) CreateBulk(builders ...*ContentCreate) *ContentCreateBulk {
	return &ContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContentClient) MapCreateBulk(slice any, setFunc func(*ContentCreate, int)) *ContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContentCreateBulk{err: fmt.Errorf("calling to ContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Content.
func (c *ContentClient) Update() *ContentUpdate {
	mutation := newContentMutation(c.config, OpUpdate)
	return &ContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContentClient) UpdateOne(co *Content) *ContentUpdateOne {
	mutation := newContentMutation(c.config, OpUpdateOne, withContent(co))
	return &ContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContentClient) UpdateOneID(id gqlid.ContentID) *ContentUpdateOne {
	mutation := newContentMutation(c.config, OpUpdateOne, withContentID(id))
	return &ContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Content.
func (c *ContentClient) Delete() *ContentDelete {
	mutation := newContentMutation(c.config, OpDelete)
	return &ContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContentClient) DeleteOne(co *Content) *ContentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContentClient) DeleteOneID(id gqlid.ContentID) *ContentDeleteOne {
	builder := c.Delete().Where(content.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContentDeleteOne{builder}
}

// Query returns a query builder for Content.
func (c *ContentClient) Query() *ContentQuery {
	return &ContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContent},
		inters: c.Interceptors(),
	}
}

// Get returns a Content entity by its id.
func (c *ContentClient) Get(ctx context.Context, id gqlid.ContentID) (*Content, error) {
	return c.Query().Where(content.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContentClient) GetX(ctx context.Context, id gqlid.ContentID) *Content {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEpisodes queries the episodes edge of a Content.
func (c *ContentClient) QueryEpisodes(co *Content) *ContentEpisodeQuery {
	query := (&ContentEpisodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(content.Table, content.FieldID, id),
			sqlgraph.To(contentepisode.Table, contentepisode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, content.EpisodesTable, content.EpisodesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContentClient) Hooks() []Hook {
	return c.hooks.Content
}

// Interceptors returns the client interceptors.
func (c *ContentClient) Interceptors() []Interceptor {
	return c.inters.Content
}

func (c *ContentClient) mutate(ctx context.Context, m *ContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Content mutation op: %q", m.Op())
	}
}

// ContentEpisodeClient is a client for the ContentEpisode schema.
type ContentEpisodeClient struct {
	config
}

// NewContentEpisodeClient returns a client for the ContentEpisode from the given config.
func NewContentEpisodeClient(c config) *ContentEpisodeClient {
	return &ContentEpisodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contentepisode.Hooks(f(g(h())))`.
func (c *ContentEpisodeClient) Use(hooks ...Hook) {
	c.hooks.ContentEpisode = append(c.hooks.ContentEpisode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contentepisode.Intercept(f(g(h())))`.
func (c *ContentEpisodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContentEpisode = append(c.inters.ContentEpisode, interceptors...)
}

// Create returns a builder for creating a ContentEpisode entity.
func (c *ContentEpisodeClient) Create() *ContentEpisodeCreate {
	mutation := newContentEpisodeMutation(c.config, OpCreate)
	return &ContentEpisodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContentEpisode entities.
func (c *ContentEpisodeClient) CreateBulk(builders ...*ContentEpisodeCreate) *ContentEpisodeCreateBulk {
	return &ContentEpisodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContentEpisodeClient) MapCreateBulk(slice any, setFunc func(*ContentEpisodeCreate, int)) *ContentEpisodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContentEpisodeCreateBulk{err: fmt.Errorf("calling to ContentEpisodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContentEpisodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContentEpisodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContentEpisode.
func (c *ContentEpisodeClient) Update() *ContentEpisodeUpdate {
	mutation := newContentEpisodeMutation(c.config, OpUpdate)
	return &ContentEpisodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContentEpisodeClient) UpdateOne(ce *ContentEpisode) *ContentEpisodeUpdateOne {
	mutation := newContentEpisodeMutation(c.config, OpUpdateOne, withContentEpisode(ce))
	return &ContentEpisodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContentEpisodeClient) UpdateOneID(id gqlid.ContentEpisodeID) *ContentEpisodeUpdateOne {
	mutation := newContentEpisodeMutation(c.config, OpUpdateOne, withContentEpisodeID(id))
	return &ContentEpisodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContentEpisode.
func (c *ContentEpisodeClient) Delete() *ContentEpisodeDelete {
	mutation := newContentEpisodeMutation(c.config, OpDelete)
	return &ContentEpisodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContentEpisodeClient) DeleteOne(ce *ContentEpisode) *ContentEpisodeDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContentEpisodeClient) DeleteOneID(id gqlid.ContentEpisodeID) *ContentEpisodeDeleteOne {
	builder := c.Delete().Where(contentepisode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContentEpisodeDeleteOne{builder}
}

// Query returns a query builder for ContentEpisode.
func (c *ContentEpisodeClient) Query() *ContentEpisodeQuery {
	return &ContentEpisodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContentEpisode},
		inters: c.Interceptors(),
	}
}

// Get returns a ContentEpisode entity by its id.
func (c *ContentEpisodeClient) Get(ctx context.Context, id gqlid.ContentEpisodeID) (*ContentEpisode, error) {
	return c.Query().Where(contentepisode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContentEpisodeClient) GetX(ctx context.Context, id gqlid.ContentEpisodeID) *ContentEpisode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContent queries the content edge of a ContentEpisode.
func (c *ContentEpisodeClient) QueryContent(ce *ContentEpisode) *ContentQuery {
	query := (&ContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentepisode.Table, contentepisode.FieldID, id),
			sqlgraph.To(content.Table, content.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, contentepisode.ContentTable, contentepisode.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContentEpisodeClient) Hooks() []Hook {
	return c.hooks.ContentEpisode
}

// Interceptors returns the client interceptors.
func (c *ContentEpisodeClient) Interceptors() []Interceptor {
	return c.inters.ContentEpisode
}

func (c *ContentEpisodeClient) mutate(ctx context.Context, m *ContentEpisodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContentEpisodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContentEpisodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContentEpisodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContentEpisodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ContentEpisode mutation op: %q", m.Op())
	}
}

// ContentProgressClient is a client for the ContentProgress schema.
type ContentProgressClient struct {
	config
}

// NewContentProgressClient returns a client for the ContentProgress from the given config.
func NewContentProgressClient(c config) *ContentProgressClient {
	return &ContentProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contentprogress.Hooks(f(g(h())))`.
func (c *ContentProgressClient) Use(hooks ...Hook) {
	c.hooks.ContentProgress = append(c.hooks.ContentProgress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contentprogress.Intercept(f(g(h())))`.
func (c *ContentProgressClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContentProgress = append(c.inters.ContentProgress, interceptors...)
}

// Create returns a builder for creating a ContentProgress entity.
func (c *ContentProgressClient) Create() *ContentProgressCreate {
	mutation := newContentProgressMutation(c.config, OpCreate)
	return &ContentProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContentProgress entities.
func (c *ContentProgressClient) CreateBulk(builders ...*ContentProgressCreate) *ContentProgressCreateBulk {
	return &ContentProgressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContentProgressClient) MapCreateBulk(slice any, setFunc func(*ContentProgressCreate, int)) *ContentProgressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContentProgressCreateBulk{err: fmt.Errorf("calling to ContentProgressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContentProgressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContentProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContentProgress.
func (c *ContentProgressClient) Update() *ContentProgressUpdate {
	mutation := newContentProgressMutation(c.config, OpUpdate)
	return &ContentProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContentProgressClient) UpdateOne(cp *ContentProgress) *ContentProgressUpdateOne {
	mutation := newContentProgressMutation(c.config, OpUpdateOne, withContentProgress(cp))
	return &ContentProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContentProgressClient) UpdateOneID(id gqlid.ContentProgressID) *ContentProgressUpdateOne {
	mutation := newContentProgressMutation(c.config, OpUpdateOne, withContentProgressID(id))
	return &ContentProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContentProgress.
func (c *ContentProgressClient) Delete() *ContentProgressDelete {
	mutation := newContentProgressMutation(c.config, OpDelete)
	return &ContentProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContentProgressClient) DeleteOne(cp *ContentProgress) *ContentProgressDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContentProgressClient) DeleteOneID(id gqlid.ContentProgressID) *ContentProgressDeleteOne {
	builder := c.Delete().Where(contentprogress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContentProgressDeleteOne{builder}
}

// Query returns a query builder for ContentProgress.
func (c *ContentProgressClient) Query() *ContentProgressQuery {
	return &ContentProgressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContentProgress},
		inters: c.Interceptors(),
	}
}

// Get returns a ContentProgress entity by its id.
func (c *ContentProgressClient) Get(ctx context.Context, id gqlid.ContentProgressID) (*ContentProgress, error) {
	return c.Query().Where(contentprogress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContentProgressClient) GetX(ctx context.Context, id gqlid.ContentProgressID) *ContentProgress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a ContentProgress.
func (c *ContentProgressClient) QueryUser(cp *ContentProgress) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentprogress.Table, contentprogress.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, contentprogress.UserTable, contentprogress.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContent queries the content edge of a ContentProgress.
func (c *ContentProgressClient) QueryContent(cp *ContentProgress) *ContentQuery {
	query := (&ContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentprogress.Table, contentprogress.FieldID, id),
			sqlgraph.To(content.Table, content.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, contentprogress.ContentTable, contentprogress.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEpisode queries the episode edge of a ContentProgress.
func (c *ContentProgressClient) QueryEpisode(cp *ContentProgress) *ContentEpisodeQuery {
	query := (&ContentEpisodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentprogress.Table, contentprogress.FieldID, id),
			sqlgraph.To(contentepisode.Table, contentepisode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, contentprogress.EpisodeTable, contentprogress.EpisodeColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContentProgressClient) Hooks() []Hook {
	return c.hooks.ContentProgress
}

// Interceptors returns the client interceptors.
func (c *ContentProgressClient) Interceptors() []Interceptor {
	return c.inters.ContentProgress
}

func (c *ContentProgressClient) mutate(ctx context.Context, m *ContentProgressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContentProgressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContentProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContentProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContentProgressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ContentProgress mutation op: %q", m.Op())
	}
}

// CourseClient is a client for the Course schema.
type CourseClient struct {
	config
}

// NewCourseClient returns a client for the Course from the given config.
func NewCourseClient(c config) *CourseClient {
	return &CourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `course.Hooks(f(g(h())))`.
func (c *CourseClient) Use(hooks ...Hook) {
	c.hooks.Course = append(c.hooks.Course, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `course.Intercept(f(g(h())))`.
func (c *CourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Course = append(c.inters.Course, interceptors...)
}

// Create returns a builder for creating a Course entity.
func (c *CourseClient) Create() *CourseCreate {
	mutation := newCourseMutation(c.config, OpCreate)
	return &CourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Course entities.
func (c *CourseClient) CreateBulk(builders ...*CourseCreate) *CourseCreateBulk {
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CourseClient) MapCreateBulk(slice any, setFunc func(*CourseCreate, int)) *CourseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CourseCreateBulk{err: fmt.Errorf("calling to CourseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CourseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Course.
func (c *CourseClient) Update() *CourseUpdate {
	mutation := newCourseMutation(c.config, OpUpdate)
	return &CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseClient) UpdateOne(co *Course) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourse(co))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseClient) UpdateOneID(id gqlid.CourseID) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourseID(id))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Course.
func (c *CourseClient) Delete() *CourseDelete {
	mutation := newCourseMutation(c.config, OpDelete)
	return &CourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseClient) DeleteOne(co *Course) *CourseDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseClient) DeleteOneID(id gqlid.CourseID) *CourseDeleteOne {
	builder := c.Delete().Where(course.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseDeleteOne{builder}
}

// Query returns a query builder for Course.
func (c *CourseClient) Query() *CourseQuery {
	return &CourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Course entity by its id.
func (c *CourseClient) Get(ctx context.Context, id gqlid.CourseID) (*Course, error) {
	return c.Query().Where(course.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseClient) GetX(ctx context.Context, id gqlid.CourseID) *Course {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUnits queries the units edge of a Course.
func (c *CourseClient) QueryUnits(co *Course) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, course.UnitsTable, course.UnitsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseClient) Hooks() []Hook {
	return c.hooks.Course
}

// Interceptors returns the client interceptors.
func (c *CourseClient) Interceptors() []Interceptor {
	return c.inters.Course
}

func (c *CourseClient) mutate(ctx context.Context, m *CourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Course mutation op: %q", m.Op())
	}
}

// JournalRecordClient is a client for the JournalRecord schema.
type JournalRecordClient struct {
	config
}

// NewJournalRecordClient returns a client for the JournalRecord from the given config.
func NewJournalRecordClient(c config) *JournalRecordClient {
	return &JournalRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `journalrecord.Hooks(f(g(h())))`.
func (c *JournalRecordClient) Use(hooks ...Hook) {
	c.hooks.JournalRecord = append(c.hooks.JournalRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `journalrecord.Intercept(f(g(h())))`.
func (c *JournalRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.JournalRecord = append(c.inters.JournalRecord, interceptors...)
}

// Create returns a builder for creating a JournalRecord entity.
func (c *JournalRecordClient) Create() *JournalRecordCreate {
	mutation := newJournalRecordMutation(c.config, OpCreate)
	return &JournalRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JournalRecord entities.
func (c *JournalRecordClient) CreateBulk(builders ...*JournalRecordCreate) *JournalRecordCreateBulk {
	return &JournalRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JournalRecordClient) MapCreateBulk(slice any, setFunc func(*JournalRecordCreate, int)) *JournalRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JournalRecordCreateBulk{err: fmt.Errorf("calling to JournalRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JournalRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JournalRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JournalRecord.
func (c *JournalRecordClient) Update() *JournalRecordUpdate {
	mutation := newJournalRecordMutation(c.config, OpUpdate)
	return &JournalRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JournalRecordClient) UpdateOne(jr *JournalRecord) *JournalRecordUpdateOne {
	mutation := newJournalRecordMutation(c.config, OpUpdateOne, withJournalRecord(jr))
	return &JournalRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JournalRecordClient) UpdateOneID(id gqlid.JournalRecordID) *JournalRecordUpdateOne {
	mutation := newJournalRecordMutation(c.config, OpUpdateOne, withJournalRecordID(id))
	return &JournalRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JournalRecord.
func (c *JournalRecordClient) Delete() *JournalRecordDelete {
	mutation := newJournalRecordMutation(c.config, OpDelete)
	return &JournalRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JournalRecordClient) DeleteOne(jr *JournalRecord) *JournalRecordDeleteOne {
	return c.DeleteOneID(jr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JournalRecordClient) DeleteOneID(id gqlid.JournalRecordID) *JournalRecordDeleteOne {
	builder := c.Delete().Where(journalrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JournalRecordDeleteOne{builder}
}

// Query returns a query builder for JournalRecord.
func (c *JournalRecordClient) Query() *JournalRecordQuery {
	return &JournalRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJournalRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a JournalRecord entity by its id.
func (c *JournalRecordClient) Get(ctx context.Context, id gqlid.JournalRecordID) (*JournalRecord, error) {
	return c.Query().Where(journalrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JournalRecordClient) GetX(ctx context.Context, id gqlid.JournalRecordID) *JournalRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a JournalRecord.
func (c *JournalRecordClient) QueryUser(jr *JournalRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := jr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalrecord.Table, journalrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, journalrecord.UserTable, journalrecord.UserColumn),
		)
		fromV = sqlgraph.Neighbors(jr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLesson queries the lesson edge of a JournalRecord.
func (c *JournalRecordClient) QueryLesson(jr *JournalRecord) *LessonQuery {
	query := (&LessonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := jr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(journalrecord.Table, journalrecord.FieldID, id),
			sqlgraph.To(lesson.Table, lesson.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, journalrecord.LessonTable, journalrecord.LessonColumn),
		)
		fromV = sqlgraph.Neighbors(jr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JournalRecordClient) Hooks() []Hook {
	return c.hooks.JournalRecord
}

// Interceptors returns the client interceptors.
func (c *JournalRecordClient) Interceptors() []Interceptor {
	return c.inters.JournalRecord
}

func (c *JournalRecordClient) mutate(ctx context.Context, m *JournalRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JournalRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JournalRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JournalRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JournalRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JournalRecord mutation op: %q", m.Op())
	}
}

// LessonClient is a client for the Lesson schema.
type LessonClient struct {
	config
}

// NewLessonClient returns a client for the Lesson from the given config.
func NewLessonClient(c config) *LessonClient {
	return &LessonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lesson.Hooks(f(g(h())))`.
func (c *LessonClient) Use(hooks ...Hook) {
	c.hooks.Lesson = append(c.hooks.Lesson, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lesson.Intercept(f(g(h())))`.
func (c *LessonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lesson = append(c.inters.Lesson, interceptors...)
}

// Create returns a builder for creating a Lesson entity.
func (c *LessonClient) Create() *LessonCreate {
	mutation := newLessonMutation(c.config, OpCreate)
	return &LessonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lesson entities.
func (c *LessonClient) CreateBulk(builders ...*LessonCreate) *LessonCreateBulk {
	return &LessonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LessonClient) MapCreateBulk(slice any, setFunc func(*LessonCreate, int)) *LessonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LessonCreateBulk{err: fmt.Errorf("calling to LessonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LessonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LessonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lesson.
func (c *LessonClient) Update() *LessonUpdate {
	mutation := newLessonMutation(c.config, OpUpdate)
	return &LessonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LessonClient) UpdateOne(l *Lesson) *LessonUpdateOne {
	mutation := newLessonMutation(c.config, OpUpdateOne, withLesson(l))
	return &LessonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LessonClient) UpdateOneID(id gqlid.LessonID) *LessonUpdateOne {
	mutation := newLessonMutation(c.config, OpUpdateOne, withLessonID(id))
	return &LessonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lesson.
func (c *LessonClient) Delete() *LessonDelete {
	mutation := newLessonMutation(c.config, OpDelete)
	return &LessonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LessonClient) DeleteOne(l *Lesson) *LessonDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LessonClient) DeleteOneID(id gqlid.LessonID) *LessonDeleteOne {
	builder := c.Delete().Where(lesson.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LessonDeleteOne{builder}
}

// Query returns a query builder for Lesson.
func (c *LessonClient) Query() *LessonQuery {
	return &LessonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLesson},
		inters: c.Interceptors(),
	}
}

// Get returns a Lesson entity by its id.
func (c *LessonClient) Get(ctx context.Context, id gqlid.LessonID) (*Lesson, error) {
	return c.Query().Where(lesson.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LessonClient) GetX(ctx context.Context, id gqlid.LessonID) *Lesson {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUnit queries the unit edge of a Lesson.
func (c *LessonClient) QueryUnit(l *Lesson) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lesson.Table, lesson.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, lesson.UnitTable, lesson.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Lesson.
func (c *LessonClient) QueryTechniques(l *Lesson) *TechniqueQuery {
	query := (&TechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lesson.Table, lesson.FieldID, id),
			sqlgraph.To(technique.Table, technique.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, lesson.TechniquesTable, lesson.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAudios queries the audios edge of a Lesson.
func (c *LessonClient) QueryAudios(l *Lesson) *LessonAudioQuery {
	query := (&LessonAudioClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lesson.Table, lesson.FieldID, id),
			sqlgraph.To(lessonaudio.Table, lessonaudio.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, lesson.AudiosTable, lesson.AudiosColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLessonTechniques queries the lessonTechniques edge of a Lesson.
func (c *LessonClient) QueryLessonTechniques(l *Lesson) *LessonTechniqueQuery {
	query := (&LessonTechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lesson.Table, lesson.FieldID, id),
			sqlgraph.To(lessontechnique.Table, lessontechnique.LessonColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, lesson.LessonTechniquesTable, lesson.LessonTechniquesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LessonClient) Hooks() []Hook {
	return c.hooks.Lesson
}

// Interceptors returns the client interceptors.
func (c *LessonClient) Interceptors() []Interceptor {
	return c.inters.Lesson
}

func (c *LessonClient) mutate(ctx context.Context, m *LessonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LessonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LessonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LessonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LessonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lesson mutation op: %q", m.Op())
	}
}

// LessonAudioClient is a client for the LessonAudio schema.
type LessonAudioClient struct {
	config
}

// NewLessonAudioClient returns a client for the LessonAudio from the given config.
func NewLessonAudioClient(c config) *LessonAudioClient {
	return &LessonAudioClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lessonaudio.Hooks(f(g(h())))`.
func (c *LessonAudioClient) Use(hooks ...Hook) {
	c.hooks.LessonAudio = append(c.hooks.LessonAudio, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lessonaudio.Intercept(f(g(h())))`.
func (c *LessonAudioClient) Intercept(interceptors ...Interceptor) {
	c.inters.LessonAudio = append(c.inters.LessonAudio, interceptors...)
}

// Create returns a builder for creating a LessonAudio entity.
func (c *LessonAudioClient) Create() *LessonAudioCreate {
	mutation := newLessonAudioMutation(c.config, OpCreate)
	return &LessonAudioCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LessonAudio entities.
func (c *LessonAudioClient) CreateBulk(builders ...*LessonAudioCreate) *LessonAudioCreateBulk {
	return &LessonAudioCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LessonAudioClient) MapCreateBulk(slice any, setFunc func(*LessonAudioCreate, int)) *LessonAudioCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LessonAudioCreateBulk{err: fmt.Errorf("calling to LessonAudioClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LessonAudioCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LessonAudioCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LessonAudio.
func (c *LessonAudioClient) Update() *LessonAudioUpdate {
	mutation := newLessonAudioMutation(c.config, OpUpdate)
	return &LessonAudioUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LessonAudioClient) UpdateOne(la *LessonAudio) *LessonAudioUpdateOne {
	mutation := newLessonAudioMutation(c.config, OpUpdateOne, withLessonAudio(la))
	return &LessonAudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LessonAudioClient) UpdateOneID(id gqlid.LessonAudioID) *LessonAudioUpdateOne {
	mutation := newLessonAudioMutation(c.config, OpUpdateOne, withLessonAudioID(id))
	return &LessonAudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LessonAudio.
func (c *LessonAudioClient) Delete() *LessonAudioDelete {
	mutation := newLessonAudioMutation(c.config, OpDelete)
	return &LessonAudioDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LessonAudioClient) DeleteOne(la *LessonAudio) *LessonAudioDeleteOne {
	return c.DeleteOneID(la.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LessonAudioClient) DeleteOneID(id gqlid.LessonAudioID) *LessonAudioDeleteOne {
	builder := c.Delete().Where(lessonaudio.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LessonAudioDeleteOne{builder}
}

// Query returns a query builder for LessonAudio.
func (c *LessonAudioClient) Query() *LessonAudioQuery {
	return &LessonAudioQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLessonAudio},
		inters: c.Interceptors(),
	}
}

// Get returns a LessonAudio entity by its id.
func (c *LessonAudioClient) Get(ctx context.Context, id gqlid.LessonAudioID) (*LessonAudio, error) {
	return c.Query().Where(lessonaudio.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LessonAudioClient) GetX(ctx context.Context, id gqlid.LessonAudioID) *LessonAudio {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLesson queries the lesson edge of a LessonAudio.
func (c *LessonAudioClient) QueryLesson(la *LessonAudio) *LessonQuery {
	query := (&LessonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := la.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lessonaudio.Table, lessonaudio.FieldID, id),
			sqlgraph.To(lesson.Table, lesson.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, lessonaudio.LessonTable, lessonaudio.LessonColumn),
		)
		fromV = sqlgraph.Neighbors(la.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LessonAudioClient) Hooks() []Hook {
	return c.hooks.LessonAudio
}

// Interceptors returns the client interceptors.
func (c *LessonAudioClient) Interceptors() []Interceptor {
	return c.inters.LessonAudio
}

func (c *LessonAudioClient) mutate(ctx context.Context, m *LessonAudioMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LessonAudioCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LessonAudioUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LessonAudioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LessonAudioDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LessonAudio mutation op: %q", m.Op())
	}
}

// LessonTechniqueClient is a client for the LessonTechnique schema.
type LessonTechniqueClient struct {
	config
}

// NewLessonTechniqueClient returns a client for the LessonTechnique from the given config.
func NewLessonTechniqueClient(c config) *LessonTechniqueClient {
	return &LessonTechniqueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lessontechnique.Hooks(f(g(h())))`.
func (c *LessonTechniqueClient) Use(hooks ...Hook) {
	c.hooks.LessonTechnique = append(c.hooks.LessonTechnique, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lessontechnique.Intercept(f(g(h())))`.
func (c *LessonTechniqueClient) Intercept(interceptors ...Interceptor) {
	c.inters.LessonTechnique = append(c.inters.LessonTechnique, interceptors...)
}

// Create returns a builder for creating a LessonTechnique entity.
func (c *LessonTechniqueClient) Create() *LessonTechniqueCreate {
	mutation := newLessonTechniqueMutation(c.config, OpCreate)
	return &LessonTechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LessonTechnique entities.
func (c *LessonTechniqueClient) CreateBulk(builders ...*LessonTechniqueCreate) *LessonTechniqueCreateBulk {
	return &LessonTechniqueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LessonTechniqueClient) MapCreateBulk(slice any, setFunc func(*LessonTechniqueCreate, int)) *LessonTechniqueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LessonTechniqueCreateBulk{err: fmt.Errorf("calling to LessonTechniqueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LessonTechniqueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LessonTechniqueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LessonTechnique.
func (c *LessonTechniqueClient) Update() *LessonTechniqueUpdate {
	mutation := newLessonTechniqueMutation(c.config, OpUpdate)
	return &LessonTechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LessonTechniqueClient) UpdateOne(lt *LessonTechnique) *LessonTechniqueUpdateOne {
	mutation := newLessonTechniqueMutation(c.config, OpUpdateOne)
	mutation.lesson = &lt.LessonID
	mutation.technique = &lt.TechniqueID
	return &LessonTechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LessonTechnique.
func (c *LessonTechniqueClient) Delete() *LessonTechniqueDelete {
	mutation := newLessonTechniqueMutation(c.config, OpDelete)
	return &LessonTechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for LessonTechnique.
func (c *LessonTechniqueClient) Query() *LessonTechniqueQuery {
	return &LessonTechniqueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLessonTechnique},
		inters: c.Interceptors(),
	}
}

// QueryLesson queries the lesson edge of a LessonTechnique.
func (c *LessonTechniqueClient) QueryLesson(lt *LessonTechnique) *LessonQuery {
	return c.Query().
		Where(lessontechnique.LessonID(lt.LessonID), lessontechnique.TechniqueID(lt.TechniqueID)).
		QueryLesson()
}

// QueryTechnique queries the technique edge of a LessonTechnique.
func (c *LessonTechniqueClient) QueryTechnique(lt *LessonTechnique) *TechniqueQuery {
	return c.Query().
		Where(lessontechnique.LessonID(lt.LessonID), lessontechnique.TechniqueID(lt.TechniqueID)).
		QueryTechnique()
}

// Hooks returns the client hooks.
func (c *LessonTechniqueClient) Hooks() []Hook {
	return c.hooks.LessonTechnique
}

// Interceptors returns the client interceptors.
func (c *LessonTechniqueClient) Interceptors() []Interceptor {
	return c.inters.LessonTechnique
}

func (c *LessonTechniqueClient) mutate(ctx context.Context, m *LessonTechniqueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LessonTechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LessonTechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LessonTechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LessonTechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LessonTechnique mutation op: %q", m.Op())
	}
}

// TechniqueClient is a client for the Technique schema.
type TechniqueClient struct {
	config
}

// NewTechniqueClient returns a client for the Technique from the given config.
func NewTechniqueClient(c config) *TechniqueClient {
	return &TechniqueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `technique.Hooks(f(g(h())))`.
func (c *TechniqueClient) Use(hooks ...Hook) {
	c.hooks.Technique = append(c.hooks.Technique, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `technique.Intercept(f(g(h())))`.
func (c *TechniqueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Technique = append(c.inters.Technique, interceptors...)
}

// Create returns a builder for creating a Technique entity.
func (c *TechniqueClient) Create() *TechniqueCreate {
	mutation := newTechniqueMutation(c.config, OpCreate)
	return &TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Technique entities.
func (c *TechniqueClient) CreateBulk(builders ...*TechniqueCreate) *TechniqueCreateBulk {
	return &TechniqueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TechniqueClient) MapCreateBulk(slice any, setFunc func(*TechniqueCreate, int)) *TechniqueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TechniqueCreateBulk{err: fmt.Errorf("calling to TechniqueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TechniqueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TechniqueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Technique.
func (c *TechniqueClient) Update() *TechniqueUpdate {
	mutation := newTechniqueMutation(c.config, OpUpdate)
	return &TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TechniqueClient) UpdateOne(t *Technique) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechnique(t))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TechniqueClient) UpdateOneID(id gqlid.TechniqueID) *TechniqueUpdateOne {
	mutation := newTechniqueMutation(c.config, OpUpdateOne, withTechniqueID(id))
	return &TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Technique.
func (c *TechniqueClient) Delete() *TechniqueDelete {
	mutation := newTechniqueMutation(c.config, OpDelete)
	return &TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TechniqueClient) DeleteOne(t *Technique) *TechniqueDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TechniqueClient) DeleteOneID(id gqlid.TechniqueID) *TechniqueDeleteOne {
	builder := c.Delete().Where(technique.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TechniqueDeleteOne{builder}
}

// Query returns a query builder for Technique.
func (c *TechniqueClient) Query() *TechniqueQuery {
	return &TechniqueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTechnique},
		inters: c.Interceptors(),
	}
}

// Get returns a Technique entity by its id.
func (c *TechniqueClient) Get(ctx context.Context, id gqlid.TechniqueID) (*Technique, error) {
	return c.Query().Where(technique.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TechniqueClient) GetX(ctx context.Context, id gqlid.TechniqueID) *Technique {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUnit queries the unit edge of a Technique.
func (c *TechniqueClient) QueryUnit(t *Technique) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, technique.UnitTable, technique.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLessons queries the lessons edge of a Technique.
func (c *TechniqueClient) QueryLessons(t *Technique) *LessonQuery {
	query := (&LessonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(lesson.Table, lesson.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, technique.LessonsTable, technique.LessonsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Technique.
func (c *TechniqueClient) QueryTechniques(t *Technique) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, technique.TechniquesTable, technique.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLessonTechniques queries the lessonTechniques edge of a Technique.
func (c *TechniqueClient) QueryLessonTechniques(t *Technique) *LessonTechniqueQuery {
	query := (&LessonTechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(lessontechnique.Table, lessontechnique.TechniqueColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, technique.LessonTechniquesTable, technique.LessonTechniquesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnitTechniques queries the unitTechniques edge of a Technique.
func (c *TechniqueClient) QueryUnitTechniques(t *Technique) *UnitTechniqueQuery {
	query := (&UnitTechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(technique.Table, technique.FieldID, id),
			sqlgraph.To(unittechnique.Table, unittechnique.TechniqueColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, technique.UnitTechniquesTable, technique.UnitTechniquesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TechniqueClient) Hooks() []Hook {
	return c.hooks.Technique
}

// Interceptors returns the client interceptors.
func (c *TechniqueClient) Interceptors() []Interceptor {
	return c.inters.Technique
}

func (c *TechniqueClient) mutate(ctx context.Context, m *TechniqueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Technique mutation op: %q", m.Op())
	}
}

// UnitClient is a client for the Unit schema.
type UnitClient struct {
	config
}

// NewUnitClient returns a client for the Unit from the given config.
func NewUnitClient(c config) *UnitClient {
	return &UnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unit.Hooks(f(g(h())))`.
func (c *UnitClient) Use(hooks ...Hook) {
	c.hooks.Unit = append(c.hooks.Unit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unit.Intercept(f(g(h())))`.
func (c *UnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Unit = append(c.inters.Unit, interceptors...)
}

// Create returns a builder for creating a Unit entity.
func (c *UnitClient) Create() *UnitCreate {
	mutation := newUnitMutation(c.config, OpCreate)
	return &UnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Unit entities.
func (c *UnitClient) CreateBulk(builders ...*UnitCreate) *UnitCreateBulk {
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitClient) MapCreateBulk(slice any, setFunc func(*UnitCreate, int)) *UnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitCreateBulk{err: fmt.Errorf("calling to UnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Unit.
func (c *UnitClient) Update() *UnitUpdate {
	mutation := newUnitMutation(c.config, OpUpdate)
	return &UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitClient) UpdateOne(u *Unit) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnit(u))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UnitClient) UpdateOneID(id gqlid.UnitID) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnitID(id))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Unit.
func (c *UnitClient) Delete() *UnitDelete {
	mutation := newUnitMutation(c.config, OpDelete)
	return &UnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UnitClient) DeleteOne(u *Unit) *UnitDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UnitClient) DeleteOneID(id gqlid.UnitID) *UnitDeleteOne {
	builder := c.Delete().Where(unit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UnitDeleteOne{builder}
}

// Query returns a query builder for Unit.
func (c *UnitClient) Query() *UnitQuery {
	return &UnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a Unit entity by its id.
func (c *UnitClient) Get(ctx context.Context, id gqlid.UnitID) (*Unit, error) {
	return c.Query().Where(unit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UnitClient) GetX(ctx context.Context, id gqlid.UnitID) *Unit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a Unit.
func (c *UnitClient) QueryCourse(u *Unit) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, unit.CourseTable, unit.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLessons queries the lessons edge of a Unit.
func (c *UnitClient) QueryLessons(u *Unit) *LessonQuery {
	query := (&LessonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(lesson.Table, lesson.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, unit.LessonsTable, unit.LessonsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTechniques queries the techniques edge of a Unit.
func (c *UnitClient) QueryTechniques(u *Unit) *TechniqueQuery {
	query := (&TechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(technique.Table, technique.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, unit.TechniquesTable, unit.TechniquesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnitTechniques queries the unitTechniques edge of a Unit.
func (c *UnitClient) QueryUnitTechniques(u *Unit) *UnitTechniqueQuery {
	query := (&UnitTechniqueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(unittechnique.Table, unittechnique.UnitColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, unit.UnitTechniquesTable, unit.UnitTechniquesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UnitClient) Hooks() []Hook {
	return c.hooks.Unit
}

// Interceptors returns the client interceptors.
func (c *UnitClient) Interceptors() []Interceptor {
	return c.inters.Unit
}

func (c *UnitClient) mutate(ctx context.Context, m *UnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Unit mutation op: %q", m.Op())
	}
}

// UnitTechniqueClient is a client for the UnitTechnique schema.
type UnitTechniqueClient struct {
	config
}

// NewUnitTechniqueClient returns a client for the UnitTechnique from the given config.
func NewUnitTechniqueClient(c config) *UnitTechniqueClient {
	return &UnitTechniqueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unittechnique.Hooks(f(g(h())))`.
func (c *UnitTechniqueClient) Use(hooks ...Hook) {
	c.hooks.UnitTechnique = append(c.hooks.UnitTechnique, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unittechnique.Intercept(f(g(h())))`.
func (c *UnitTechniqueClient) Intercept(interceptors ...Interceptor) {
	c.inters.UnitTechnique = append(c.inters.UnitTechnique, interceptors...)
}

// Create returns a builder for creating a UnitTechnique entity.
func (c *UnitTechniqueClient) Create() *UnitTechniqueCreate {
	mutation := newUnitTechniqueMutation(c.config, OpCreate)
	return &UnitTechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UnitTechnique entities.
func (c *UnitTechniqueClient) CreateBulk(builders ...*UnitTechniqueCreate) *UnitTechniqueCreateBulk {
	return &UnitTechniqueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitTechniqueClient) MapCreateBulk(slice any, setFunc func(*UnitTechniqueCreate, int)) *UnitTechniqueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitTechniqueCreateBulk{err: fmt.Errorf("calling to UnitTechniqueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitTechniqueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitTechniqueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UnitTechnique.
func (c *UnitTechniqueClient) Update() *UnitTechniqueUpdate {
	mutation := newUnitTechniqueMutation(c.config, OpUpdate)
	return &UnitTechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitTechniqueClient) UpdateOne(ut *UnitTechnique) *UnitTechniqueUpdateOne {
	mutation := newUnitTechniqueMutation(c.config, OpUpdateOne)
	mutation.unit = &ut.UnitID
	mutation.technique = &ut.TechniqueID
	return &UnitTechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UnitTechnique.
func (c *UnitTechniqueClient) Delete() *UnitTechniqueDelete {
	mutation := newUnitTechniqueMutation(c.config, OpDelete)
	return &UnitTechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UnitTechnique.
func (c *UnitTechniqueClient) Query() *UnitTechniqueQuery {
	return &UnitTechniqueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnitTechnique},
		inters: c.Interceptors(),
	}
}

// QueryUnit queries the unit edge of a UnitTechnique.
func (c *UnitTechniqueClient) QueryUnit(ut *UnitTechnique) *UnitQuery {
	return c.Query().
		Where(unittechnique.UnitID(ut.UnitID), unittechnique.TechniqueID(ut.TechniqueID)).
		QueryUnit()
}

// QueryTechnique queries the technique edge of a UnitTechnique.
func (c *UnitTechniqueClient) QueryTechnique(ut *UnitTechnique) *TechniqueQuery {
	return c.Query().
		Where(unittechnique.UnitID(ut.UnitID), unittechnique.TechniqueID(ut.TechniqueID)).
		QueryTechnique()
}

// Hooks returns the client hooks.
func (c *UnitTechniqueClient) Hooks() []Hook {
	return c.hooks.UnitTechnique
}

// Interceptors returns the client interceptors.
func (c *UnitTechniqueClient) Interceptors() []Interceptor {
	return c.inters.UnitTechnique
}

func (c *UnitTechniqueClient) mutate(ctx context.Context, m *UnitTechniqueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitTechniqueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitTechniqueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitTechniqueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitTechniqueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UnitTechnique mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id gqlid.UserID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id gqlid.UserID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id gqlid.UserID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id gqlid.UserID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserProgressClient is a client for the UserProgress schema.
type UserProgressClient struct {
	config
}

// NewUserProgressClient returns a client for the UserProgress from the given config.
func NewUserProgressClient(c config) *UserProgressClient {
	return &UserProgressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userprogress.Hooks(f(g(h())))`.
func (c *UserProgressClient) Use(hooks ...Hook) {
	c.hooks.UserProgress = append(c.hooks.UserProgress, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userprogress.Intercept(f(g(h())))`.
func (c *UserProgressClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserProgress = append(c.inters.UserProgress, interceptors...)
}

// Create returns a builder for creating a UserProgress entity.
func (c *UserProgressClient) Create() *UserProgressCreate {
	mutation := newUserProgressMutation(c.config, OpCreate)
	return &UserProgressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProgress entities.
func (c *UserProgressClient) CreateBulk(builders ...*UserProgressCreate) *UserProgressCreateBulk {
	return &UserProgressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserProgressClient) MapCreateBulk(slice any, setFunc func(*UserProgressCreate, int)) *UserProgressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserProgressCreateBulk{err: fmt.Errorf("calling to UserProgressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserProgressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserProgressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProgress.
func (c *UserProgressClient) Update() *UserProgressUpdate {
	mutation := newUserProgressMutation(c.config, OpUpdate)
	return &UserProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProgressClient) UpdateOne(up *UserProgress) *UserProgressUpdateOne {
	mutation := newUserProgressMutation(c.config, OpUpdateOne, withUserProgress(up))
	return &UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProgressClient) UpdateOneID(id gqlid.UserProgressID) *UserProgressUpdateOne {
	mutation := newUserProgressMutation(c.config, OpUpdateOne, withUserProgressID(id))
	return &UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProgress.
func (c *UserProgressClient) Delete() *UserProgressDelete {
	mutation := newUserProgressMutation(c.config, OpDelete)
	return &UserProgressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserProgressClient) DeleteOne(up *UserProgress) *UserProgressDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserProgressClient) DeleteOneID(id gqlid.UserProgressID) *UserProgressDeleteOne {
	builder := c.Delete().Where(userprogress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProgressDeleteOne{builder}
}

// Query returns a query builder for UserProgress.
func (c *UserProgressClient) Query() *UserProgressQuery {
	return &UserProgressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserProgress},
		inters: c.Interceptors(),
	}
}

// Get returns a UserProgress entity by its id.
func (c *UserProgressClient) Get(ctx context.Context, id gqlid.UserProgressID) (*UserProgress, error) {
	return c.Query().Where(userprogress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProgressClient) GetX(ctx context.Context, id gqlid.UserProgressID) *UserProgress {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserProgress.
func (c *UserProgressClient) QueryUser(up *UserProgress) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userprogress.UserTable, userprogress.UserColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a UserProgress.
func (c *UserProgressClient) QueryCourse(up *UserProgress) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userprogress.CourseTable, userprogress.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnit queries the unit edge of a UserProgress.
func (c *UserProgressClient) QueryUnit(up *UserProgress) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userprogress.UnitTable, userprogress.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLesson queries the lesson edge of a UserProgress.
func (c *UserProgressClient) QueryLesson(up *UserProgress) *LessonQuery {
	query := (&LessonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprogress.Table, userprogress.FieldID, id),
			sqlgraph.To(lesson.Table, lesson.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userprogress.LessonTable, userprogress.LessonColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProgressClient) Hooks() []Hook {
	return c.hooks.UserProgress
}

// Interceptors returns the client interceptors.
func (c *UserProgressClient) Interceptors() []Interceptor {
	return c.inters.UserProgress
}

func (c *UserProgressClient) mutate(ctx context.Context, m *UserProgressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserProgressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserProgressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserProgressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserProgressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserProgress mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuthToken, Content, ContentEpisode, ContentProgress, Course, JournalRecord,
		Lesson, LessonAudio, LessonTechnique, Technique, Unit, UnitTechnique, User,
		UserProgress []ent.Hook
	}
	inters struct {
		AuthToken, Content, ContentEpisode, ContentProgress, Course, JournalRecord,
		Lesson, LessonAudio, LessonTechnique, Technique, Unit, UnitTechnique, User,
		UserProgress []ent.Interceptor
	}
)
